<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>flutter_rust_bridge</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Part I: Core</li><li class="chapter-item expanded "><a href="quickstart.html"><strong aria-hidden="true">1.</strong> üß≠ Quickstart</a></li><li class="chapter-item expanded "><a href="tutorial_with_flutter.html"><strong aria-hidden="true">2.</strong> üìö Tutorial: A Flutter+Rust app</a></li><li class="chapter-item expanded "><a href="feature.html"><strong aria-hidden="true">3.</strong> üéº Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="feature/lang.html"><strong aria-hidden="true">3.1.</strong> Language translations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="feature/lang_simple.html"><strong aria-hidden="true">3.1.1.</strong> Simple correspondence</a></li><li class="chapter-item expanded "><a href="feature/lang_vec.html"><strong aria-hidden="true">3.1.2.</strong> Vec and array</a></li><li class="chapter-item expanded "><a href="feature/lang_struct.html"><strong aria-hidden="true">3.1.3.</strong> Struct</a></li><li class="chapter-item expanded "><a href="feature/lang_enum.html"><strong aria-hidden="true">3.1.4.</strong> Enum</a></li><li class="chapter-item expanded "><a href="feature/lang_external.html"><strong aria-hidden="true">3.1.5.</strong> External types</a></li><li class="chapter-item expanded "><a href="feature/lang_option.html"><strong aria-hidden="true">3.1.6.</strong> Option</a></li><li class="chapter-item expanded "><a href="feature/lang_methods.html"><strong aria-hidden="true">3.1.7.</strong> Methods</a></li><li class="chapter-item expanded "><a href="feature/lang_return_types.html"><strong aria-hidden="true">3.1.8.</strong> Return types</a></li></ol></li><li class="chapter-item expanded "><a href="feature/zero_copy.html"><strong aria-hidden="true">3.2.</strong> Zero copy</a></li><li class="chapter-item expanded "><a href="feature/stream.html"><strong aria-hidden="true">3.3.</strong> Stream / Iterator</a></li><li class="chapter-item expanded "><a href="feature/async_dart.html"><strong aria-hidden="true">3.4.</strong> Async in Dart</a></li><li class="chapter-item expanded "><a href="feature/sync_dart.html"><strong aria-hidden="true">3.5.</strong> Sync in Dart</a></li><li class="chapter-item expanded "><a href="feature/concurrency.html"><strong aria-hidden="true">3.6.</strong> Concurrency</a></li><li class="chapter-item expanded "><a href="feature/handler.html"><strong aria-hidden="true">3.7.</strong> Handler</a></li><li class="chapter-item expanded "><a href="feature/init.html"><strong aria-hidden="true">3.8.</strong> Initialization</a></li><li class="chapter-item expanded "><a href="feature/async_rust.html"><strong aria-hidden="true">3.9.</strong> Async in Rust</a></li><li class="chapter-item expanded "><a href="feature/multiple_files.html"><strong aria-hidden="true">3.10.</strong> Multiple files</a></li><li class="chapter-item expanded "><a href="feature/build_rs.html"><strong aria-hidden="true">3.11.</strong> Run in build.rs</a></li><li class="chapter-item expanded "><a href="feature/cancelable_task.html"><strong aria-hidden="true">3.12.</strong> Cancellable tasks</a></li><li class="chapter-item expanded "><a href="feature/object_pool.html"><strong aria-hidden="true">3.13.</strong> Object pools</a></li><li class="chapter-item expanded "><a href="feature/wasm.html"><strong aria-hidden="true">3.14.</strong> WASM</a></li><li class="chapter-item expanded "><a href="feature/misc.html"><strong aria-hidden="true">3.15.</strong> Miscellaneous</a></li><li class="chapter-item expanded "><a href="feature/logging.html"><strong aria-hidden="true">3.16.</strong> Logging</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Part II: User Guide</li><li class="chapter-item expanded "><a href="template.html"><strong aria-hidden="true">4.</strong> Create new projects from a template</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="template/setup.html"><strong aria-hidden="true">4.1.</strong> Creating a new project</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="template/setup_android.html"><strong aria-hidden="true">4.1.1.</strong> Android setup</a></li><li class="chapter-item expanded "><a href="template/setup_ios.html"><strong aria-hidden="true">4.1.2.</strong> iOS setup</a></li><li class="chapter-item expanded "><a href="template/setup_web.html"><strong aria-hidden="true">4.1.3.</strong> Web setup</a></li><li class="chapter-item expanded "><a href="template/setup_desktop.html"><strong aria-hidden="true">4.1.4.</strong> Windows and Linux</a></li><li class="chapter-item expanded "><a href="template/setup_others.html"><strong aria-hidden="true">4.1.5.</strong> Other platforms</a></li></ol></li><li class="chapter-item expanded "><a href="template/tour.html"><strong aria-hidden="true">4.2.</strong> Template tour</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="template/tour_api.html"><strong aria-hidden="true">4.2.1.</strong> native/src/api.rs</a></li><li class="chapter-item expanded "><a href="template/tour_gradle.html"><strong aria-hidden="true">4.2.2.</strong> android/app/build.gradle</a></li><li class="chapter-item expanded "><a href="template/tour_native_proj.html"><strong aria-hidden="true">4.2.3.</strong> native/native.xcodeproj</a></li><li class="chapter-item expanded "><a href="template/tour_justfile.html"><strong aria-hidden="true">4.2.4.</strong> justfile</a></li><li class="chapter-item expanded "><a href="template/tour_cmake.html"><strong aria-hidden="true">4.2.5.</strong> rust.cmake</a></li></ol></li><li class="chapter-item expanded "><a href="template/generate.html"><strong aria-hidden="true">4.3.</strong> Generating code</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="template/generate_install.html"><strong aria-hidden="true">4.3.1.</strong> Installing codegen</a></li><li class="chapter-item expanded "><a href="template/generate_adding_code.html"><strong aria-hidden="true">4.3.2.</strong> Adding new code</a></li><li class="chapter-item expanded "><a href="template/generate_build_runner.html"><strong aria-hidden="true">4.3.3.</strong> Using build_runner</a></li><li class="chapter-item expanded "><a href="template/generate_finish.html"><strong aria-hidden="true">4.3.4.</strong> Wrapping up</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="integrate.html"><strong aria-hidden="true">5.</strong> Integrating with existing projects</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integrate/new_crate.html"><strong aria-hidden="true">5.1.</strong> Creating a new crate</a></li><li class="chapter-item expanded "><a href="integrate/deps.html"><strong aria-hidden="true">5.2.</strong> Installing dependencies</a></li><li class="chapter-item expanded "><a href="integrate/android.html"><strong aria-hidden="true">5.3.</strong> Integrating with Android</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integrate/android_tasks.html"><strong aria-hidden="true">5.3.1.</strong> Hooking onto tasks</a></li><li class="chapter-item expanded "><a href="integrate/android_cmake.html"><strong aria-hidden="true">5.3.2.</strong> CMake with Gradle</a></li></ol></li><li class="chapter-item expanded "><a href="integrate/ios.html"><strong aria-hidden="true">5.4.</strong> Integrating with iOS/MacOS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="integrate/ios_proj.html"><strong aria-hidden="true">5.4.1.</strong> Creating the Rust project</a></li><li class="chapter-item expanded "><a href="integrate/ios_linking.html"><strong aria-hidden="true">5.4.2.</strong> Linking the project</a></li><li class="chapter-item expanded "><a href="integrate/ios_gen.html"><strong aria-hidden="true">5.4.3.</strong> Generating bindings</a></li><li class="chapter-item expanded "><a href="integrate/ios_headers.html"><strong aria-hidden="true">5.4.4.</strong> Using dummy headers</a></li></ol></li><li class="chapter-item expanded "><a href="integrate/desktop.html"><strong aria-hidden="true">5.5.</strong> Integrating with Windows and Linux</a></li><li class="chapter-item expanded "><a href="integrate/web.html"><strong aria-hidden="true">5.6.</strong> Integrating with Web</a></li><li class="chapter-item expanded "><a href="integrate/usage.html"><strong aria-hidden="true">5.7.</strong> Using the dynamic library</a></li><li class="chapter-item expanded "><a href="integrate/finish.html"><strong aria-hidden="true">5.8.</strong> Wrapping up</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Part III: Contributor Guide</li><li class="chapter-item expanded "><a href="contributing/overview.html"><strong aria-hidden="true">6.</strong> Overview</a></li><li class="chapter-item expanded "><a href="contributing/design.html"><strong aria-hidden="true">7.</strong> Overall design</a></li><li class="chapter-item expanded "><a href="contributing/appendix.html"><strong aria-hidden="true">8.</strong> Appendix</a></li><li class="chapter-item expanded affix "><li class="part-title">Part IV: More Doc</li><li class="chapter-item expanded "><a href="tutorial_pure_dart.html"><strong aria-hidden="true">9.</strong> Tutorial: Pure Dart</a></li><li class="chapter-item expanded "><a href="safety.html"><strong aria-hidden="true">10.</strong> Safety concerns</a></li><li class="chapter-item expanded "><a href="troubleshooting.html"><strong aria-hidden="true">11.</strong> Troubleshooting</a></li><li class="chapter-item expanded "><a href="command_line.html"><strong aria-hidden="true">12.</strong> Command line arguments</a></li><li class="chapter-item expanded "><a href="set_up_from_scratch.html"><strong aria-hidden="true">13.</strong> Set up Flutter/Dart+Rust support from scratch</a></li><li class="chapter-item expanded "><a href="build_wasm.html"><strong aria-hidden="true">14.</strong> Building a WASM binary manually</a></li><li class="chapter-item expanded "><a href="wasm_limitations.html"><strong aria-hidden="true">15.</strong> Limitations of WASM</a></li><li class="chapter-item expanded "><a href="article.html"><strong aria-hidden="true">16.</strong> Articles</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="article/async_in_rust.html"><strong aria-hidden="true">16.1.</strong> Async in Rust</a></li><li class="chapter-item expanded "><a href="article/generate_multiple_files.html"><strong aria-hidden="true">16.2.</strong> Generate multiple files</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">flutter_rust_bridge</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="flutter_rust_bridge-high-level-memory-safe-binding-generator-for-flutterdart---rust"><a class="header" href="#flutter_rust_bridge-high-level-memory-safe-binding-generator-for-flutterdart---rust"><a href="https://github.com/fzyzcjy/flutter_rust_bridge">flutter_rust_bridge</a>: High-level memory-safe binding generator for Flutter/Dart &lt;-&gt; Rust</a></h1>
<p><a href="https://crates.io/crates/flutter_rust_bridge"><img src="https://img.shields.io/crates/v/flutter_rust_bridge.svg" alt="Rust Package" /></a>
<a href="https://pub.dev/packages/flutter_rust_bridge"><img src="https://img.shields.io/pub/v/flutter_rust_bridge.svg" alt="Flutter Package" /></a>
<a href="https://github.com/fzyzcjy/flutter_rust_bridge"><img src="https://img.shields.io/github/stars/fzyzcjy/flutter_rust_bridge" alt="Stars" /></a>
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/actions/workflows/ci.yaml"><img src="https://github.com/fzyzcjy/flutter_rust_bridge/actions/workflows/ci.yaml/badge.svg" alt="CI" /></a>
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/actions/workflows/post_release.yaml"><img src="https://github.com/fzyzcjy/flutter_rust_bridge/actions/workflows/post_release.yaml/badge.svg" alt="Example" /></a>
<a href="https://app.codacy.com/gh/fzyzcjy/flutter_rust_bridge?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=fzyzcjy/flutter_rust_bridge&amp;utm_campaign=Badge_Grade_Settings"><img src="https://api.codacy.com/project/badge/Grade/6afbdad19e7245adbf9e9771777be3d7" alt="Codacy Badge" /></a></p>
<p><img src="https://github.com/fzyzcjy/flutter_rust_bridge/raw/master/book/logo.png" alt="Logo" /></p>
<p>Want to combine the best between <a href="https://flutter.dev/">Flutter</a>, a cross-platform hot-reload rapid-development UI toolkit, and <a href="https://www.rust-lang.org/">Rust</a>, a language empowering everyone to build reliable and efficient software? Here it comes!</p>
<h2 id="-advantages"><a class="header" href="#-advantages">üöÄ Advantages</a></h2>
<ul>
<li><strong>Memory-safe</strong>: Never need to think about malloc/free.</li>
<li><strong>Feature-rich</strong>: <code>enum</code>s with values, platform-optimized <code>Vec</code>, possibly recursive <code>struct</code>, zero-copy big arrays, <code>Stream</code> (iterator) abstraction, error (<code>Result</code>) handling, cancellable tasks, concurrency control, and more. See full features <a href="https://fzyzcjy.github.io/flutter_rust_bridge/feature.html">here</a>. </li>
<li><strong>Async programming</strong>: Rust code will never block the Flutter. Call Rust naturally from Flutter's main isolate (thread).</li>
<li><strong>Lightweight</strong>: This is not a huge framework that includes everything, so you are free to use your favorite Flutter and Rust libraries. <sub>For example, state-management with Flutter library (e.g. MobX) can be elegant and simple (contrary to implementing in Rust); implementing a photo manipulation algorithm in Rust will be fast and safe (countrary to implementing in Flutter).</sub></li>
<li><strong>Cross-platform</strong>: Android, iOS, Windows, Linux, MacOS, and Web.</li>
<li><strong>Easy to code-review &amp; convince yourself</strong>: This package simply simulates how humans  write boilerplate code. If you want to convince yourself (or your team) that it is safe, there is not much code to look at. No magic at all! (<a href="https://fzyzcjy.github.io/flutter_rust_bridge/safety.html">More about</a> safety concerns.)</li>
<li><strong>Fast</strong>: It is only a thin (though feature-rich) wrapper, without overhead such as protobuf serialization, thus performant. (More <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/318#issuecomment-1034536815">benchmarks</a> later) <small>(Throw away components like thread-pool to make it even faster)</small></li>
<li><strong>Pure-Dart compatible:</strong> Despite the name, this package is 100% compatible with <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/pure_dart/README.md">pure</a> Dart.</li>
</ul>
<h2 id="-user-guide"><a class="header" href="#-user-guide">üí° User Guide</a></h2>
<p>Check out <a href="https://fzyzcjy.github.io/flutter_rust_bridge/">the user guide</a> for <a href="https://fzyzcjy.github.io/flutter_rust_bridge/quickstart.html">show-me-the-code</a>, <a href="https://fzyzcjy.github.io/flutter_rust_bridge/tutorial_with_flutter.html">tutorials</a>, <a href="https://fzyzcjy.github.io/flutter_rust_bridge/feature.html">features</a> and much more.</p>
<h2 id="-ps-convenient-flutter-tests"><a class="header" href="#-ps-convenient-flutter-tests">üìé P.S. Convenient Flutter tests</a></h2>
<p>If you want to write and debug tests in Flutter conveniently, with action history, time travelling, screenshots, rapid re-execution, video recordings, interactive mode and more, here is my another open-source library: https://github.com/fzyzcjy/flutter_convenient_test.</p>
<h2 id="-contributors"><a class="header" href="#-contributors">‚ú® Contributors</a></h2>
<!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section -->
<p><a href="index.html#contributors-"><img src="https://img.shields.io/badge/all_contributors-31-orange.svg?style=flat-square" alt="All Contributors" /></a></p>
<!-- ALL-CONTRIBUTORS-BADGE:END -->
<p>Thanks goes to these wonderful people (<a href="https://allcontributors.org/docs/en/emoji-key">emoji key</a> following <a href="https://github.com/all-contributors/all-contributors">all-contributors</a> specification):</p>
<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tbody>
    <tr>
      <td align="center"><a href="https://github.com/fzyzcjy"><img src="https://avatars.githubusercontent.com/u/5236035?v=4?s=100" width="100px;" alt=""/><br /><sub><b>fzyzcjy</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=fzyzcjy" title="Code">üíª</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=fzyzcjy" title="Documentation">üìñ</a> <a href="index.html#example-fzyzcjy" title="Examples">üí°</a> <a href="index.html#ideas-fzyzcjy" title="Ideas, Planning, & Feedback">ü§î</a> <a href="index.html#maintenance-fzyzcjy" title="Maintenance">üöß</a></td>
      <td align="center"><a href="https://github.com/Desdaemon"><img src="https://avatars.githubusercontent.com/u/36768030?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Viet Dinh</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Desdaemon" title="Code">üíª</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Desdaemon" title="Tests">‚ö†Ô∏è</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Desdaemon" title="Documentation">üìñ</a></td>
      <td align="center"><a href="https://github.com/SecondFlight"><img src="https://avatars.githubusercontent.com/u/6700184?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Joshua Wade</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=SecondFlight" title="Code">üíª</a></td>
      <td align="center"><a href="https://github.com/smw-wagnerma"><img src="https://avatars.githubusercontent.com/u/66412697?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Marcel</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=smw-wagnerma" title="Code">üíª</a></td>
      <td align="center"><a href="https://github.com/rustui"><img src="https://avatars.githubusercontent.com/u/90625190?v=4?s=100" width="100px;" alt=""/><br /><sub><b>rustui</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=rustui" title="Documentation">üìñ</a></td>
      <td align="center"><a href="https://adventures.michaelfbryan.com/"><img src="https://avatars.githubusercontent.com/u/17380079?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Michael Bryan</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Michael-F-Bryan" title="Code">üíª</a></td>
      <td align="center"><a href="https://bus710.net"><img src="https://avatars.githubusercontent.com/u/8920680?v=4?s=100" width="100px;" alt=""/><br /><sub><b>bus710</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=bus710" title="Documentation">üìñ</a></td>
    </tr>
    <tr>
      <td align="center"><a href="https://scholar.google.com/citations?user=RbAto7EAAAAJ"><img src="https://avatars.githubusercontent.com/u/1213857?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Sebastian Urban</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=surban" title="Code">üíª</a></td>
      <td align="center"><a href="https://github.com/trobanga"><img src="https://avatars.githubusercontent.com/u/8888869?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Daniel</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=trobanga" title="Code">üíª</a></td>
      <td align="center"><a href="https://github.com/AlienKevin"><img src="https://avatars.githubusercontent.com/u/22850071?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Kevin Li</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=AlienKevin" title="Code">üíª</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=AlienKevin" title="Documentation">üìñ</a></td>
      <td align="center"><a href="https://valeth.me"><img src="https://avatars.githubusercontent.com/u/3198362?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Patrick Auernig</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=valeth" title="Code">üíª</a></td>
      <td align="center"><a href="https://antonok.com"><img src="https://avatars.githubusercontent.com/u/22821309?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Anton Lazarev</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=antonok-edm" title="Code">üíª</a></td>
      <td align="center"><a href="https://github.com/Unoqwy"><img src="https://avatars.githubusercontent.com/u/65187632?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Unoqwy</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Unoqwy" title="Code">üíª</a></td>
      <td align="center"><a href="https://feber.dev"><img src="https://avatars.githubusercontent.com/u/1727318?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Febrian Setianto</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=feber" title="Documentation">üìñ</a></td>
    </tr>
    <tr>
      <td align="center"><a href="https://github.com/Syndim"><img src="https://avatars.githubusercontent.com/u/835035?v=4?s=100" width="100px;" alt=""/><br /><sub><b>syndim</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=syndim" title="Code">üíª</a></td>
      <td align="center"><a href="https://github.com/sagudev"><img src="https://avatars.githubusercontent.com/u/16504129?v=4?s=100" width="100px;" alt=""/><br /><sub><b>sagu</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=sagudev" title="Code">üíª</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=sagudev" title="Documentation">üìñ</a></td>
      <td align="center"><a href="https://bandism.net/"><img src="https://avatars.githubusercontent.com/u/22633385?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Ikko Ashimine</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=eltociear" title="Documentation">üìñ</a></td>
      <td align="center"><a href="https://github.com/alanlzhang"><img src="https://avatars.githubusercontent.com/u/59032810?v=4?s=100" width="100px;" alt=""/><br /><sub><b>alanlzhang</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=alanlzhang" title="Code">üíª</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=alanlzhang" title="Documentation">üìñ</a></td>
      <td align="center"><a href="https://github.com/sccheruku"><img src="https://avatars.githubusercontent.com/u/5800058?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Sai Chaitanya</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=sccheruku" title="Code">üíª</a></td>
      <td align="center"><a href="https://ares.zone (ÂõΩÂÜÖ)"><img src="https://avatars.githubusercontent.com/u/40336192?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Ares Andrew</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=TENX-S" title="Documentation">üìñ</a></td>
      <td align="center"><a href="https://github.com/raphaelrobert"><img src="https://avatars.githubusercontent.com/u/9882746?v=4?s=100" width="100px;" alt=""/><br /><sub><b>raphaelrobert</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=raphaelrobert" title="Documentation">üìñ</a></td>
    </tr>
    <tr>
      <td align="center"><a href="https://github.com/thomas725"><img src="https://avatars.githubusercontent.com/u/68635351?v=4?s=100" width="100px;" alt=""/><br /><sub><b>thomas725</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=thomas725" title="Documentation">üìñ</a></td>
      <td align="center"><a href="https://dport.me"><img src="https://avatars.githubusercontent.com/u/7816187?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Daniel Porteous (dport)</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=banool" title="Documentation">üìñ</a></td>
      <td align="center"><a href="https://github.com/w-ensink"><img src="https://avatars.githubusercontent.com/u/46427708?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Wouter Ensink</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=w-ensink" title="Documentation">üìñ</a></td>
      <td align="center"><a href="https://github.com/dbsxdbsx"><img src="https://avatars.githubusercontent.com/u/17372655?v=4?s=100" width="100px;" alt=""/><br /><sub><b>ËÄÅËë£</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=dbsxdbsx" title="Code">üíª</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=dbsxdbsx" title="Documentation">üìñ</a></td>
      <td align="center"><a href="https://github.com/lattice0"><img src="https://avatars.githubusercontent.com/u/6632321?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Lattice 0</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=lattice0" title="Code">üíª</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=lattice0" title="Documentation">üìñ</a></td>
      <td align="center"><a href="https://soeur.dev"><img src="https://avatars.githubusercontent.com/u/26034975?v=4?s=100" width="100px;" alt=""/><br /><sub><b>orange soeur</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=juzi5201314" title="Documentation">üìñ</a></td>
      <td align="center"><a href="https://github.com/Roms1383"><img src="https://avatars.githubusercontent.com/u/21016014?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Rom's</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Roms1383" title="Code">üíª</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Roms1383" title="Documentation">üìñ</a></td>
    </tr>
    <tr>
      <td align="center"><a href="https://github.com/Cupnfish"><img src="https://avatars.githubusercontent.com/u/40173605?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Cupnfish</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Cupnfish" title="Code">üíª</a></td>
      <td align="center"><a href="https://github.com/SoLongAndThanksForAllThePizza"><img src="https://avatars.githubusercontent.com/u/103753680?v=4?s=100" width="100px;" alt=""/><br /><sub><b>SoLongAndThanksForAllThePizza</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=SoLongAndThanksForAllThePizza" title="Code">üíª</a> <a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=SoLongAndThanksForAllThePizza" title="Documentation">üìñ</a></td>
      <td align="center"><a href="https://github.com/Stonks3141"><img src="https://avatars.githubusercontent.com/u/82178396?v=4?s=100" width="100px;" alt=""/><br /><sub><b>Sam Nystrom</b></sub></a><br /><a href="https://github.com/fzyzcjy/flutter_rust_bridge/commits?author=Stonks3141" title="Documentation">üìñ</a></td>
    </tr>
  </tbody>
</table>
<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->
<!-- ALL-CONTRIBUTORS-LIST:END -->
<p>More specifically, thanks for all these contributions:</p>
<ul>
<li><a href="https://github.com/Desdaemon">Desdaemon</a>: Support not only simple enums but also enums with fields which gets translated to native enum or freezed class in Dart. Support the Option type as nullable types in Dart. Support Vec of Strings type. Support comments in code. Add marker attributes for future usage. Add Linux and Windows support for with-flutter example, and make CI works for that. Avoid parameter collision. Overhaul the documentation and add several chapters to demonstrate configuring a Flutter+Rust project in all five platforms. Refactor command module. Precompiled binary CI workflow. Fix bugs. Add support for the Web platform, parallel to the existing mobile/desktop platforms, via WASM and JavaScript as intermediate values. GitHub retry actions.</li>
<li><a href="https://github.com/SecondFlight">SecondFlight</a>: Allow structs and enums to be imported from other files within the crate by creating source graph. Auto-create relavent dir. Fix <code>store_dart_post_cobject</code> error with ffigen 6.0.</li>
<li><a href="https://github.com/Unoqwy">Unoqwy</a>: Add struct mirrors, such that types in the external crates can be imported and used without redefining and copying.</li>
<li><a href="https://github.com/antonok-edm">antonok-edm</a>: Avoid converting syn types to strings before parsing to improve code and be more robust.</li>
<li><a href="https://github.com/lattice0">lattice0</a>: Support methods, such that Rust struct impls can be converted to Dart class methods. StreamSink at any argument.</li>
<li><a href="https://github.com/sagudev">sagudev</a>: Make code generator a <code>lib</code>. Add error types. Depend on <code>cbindgen</code>. Fix LLVM paths. Update deps. Fix CI errors.</li>
<li><a href="https://github.com/surban">surban</a>: Support unit return type. Skip unresolvable modules. Ignore prefer_const_constructors. Non-final Dart fields.</li>
<li><a href="https://github.com/trobanga">trobanga</a>: Add support for <code>[T;N]</code> structs. Add <code>usize</code> support. Add a cmd argument. Separate dart tests.</li>
<li><a href="https://github.com/Roms1383">Roms1383</a>: Fix build_runner calling bug. Remove global <code>ffigen</code> dependency. Improve version check. Fix enum name-variant conflicts. Update CI. Update header comments. Code cleanup.</li>
<li><a href="https://github.com/dbsxdbsx">dbsxdbsx</a>: Allow generating multiple Rust and Dart files.</li>
<li><a href="https://github.com/SoLongAndThanksForAllThePizza">SoLongAndThanksForAllThePizza</a>: Refactor and enhance SyncReturn to support more types.</li>
<li><a href="https://github.com/alanlzhang">alanlzhang</a>: Add generation for Dart metadata. Enhance module parser.</li>
<li><a href="https://github.com/AlienKevin">AlienKevin</a>: Add flutter example for macOS. Add doc for Android NDK bug.</li>
<li><a href="https://github.com/efc-mw">efc-mw</a>: Improve Windows encoding handling.</li>
<li><a href="https://github.com/valeth">valeth</a>: Rename callFfi's port.</li>
<li><a href="https://github.com/Cupnfish">Cupnfish</a>: Allow multi mirror.</li>
<li><a href="https://github.com/sccheruku">sccheruku</a>: Prevent double-generating utility.</li>
<li><a href="https://github.com/w-ensink">w-ensink</a>: Improve doc. Fix CI. Refactor. Add tests.</li>
<li><a href="https://github.com/Michael-F-Bryan">Michael-F-Bryan</a>: Detect broken bindings.</li>
<li><a href="https://github.com/bus710">bus710</a>: Add a case in troubleshooting.</li>
<li><a href="https://github.com/Syndim">Syndim</a>: Add a bracket to box.</li>
<li><a href="https://github.com/banool">banool</a>: Fix symbol-stripping doc.</li>
<li><a href="https://github.com/TENX-S">TENX-S</a>: Improve doc. Reproduce a bug.</li>
<li><a href="https://github.com/raphaelrobert">raphaelrobert</a>: Remove oudated doc.</li>
<li><a href="https://github.com/thomas725">thomas725</a>: Improve doc.</li>
<li><a href="https://github.com/juzi5201314">juzi5201314</a>: Improve doc.</li>
<li><a href="https://github.com/Stonks3141">Stonks3141</a>: Fix doc credit.</li>
<li><a href="https://github.com/feber">feber</a>: Fix doc link.</li>
<li><a href="https://github.com/rustui">rustui</a>: Fix a typo.</li>
<li><a href="https://github.com/eltociear">eltociear</a>: Fix a typo.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>Write down Rust functions and types normally.</p>
<pre><code class="language-rust ignore">// A normal Rust function ...
pub fn draw_tree(root: TreeNode, mode: DrawMode) -&gt; Result&lt;Vec&lt;u8&gt;&gt; { /* ... */ }

// ... with rich types
pub struct TreeNode { pub value: String, pub children: Vec&lt;MyTreeNode&gt; }
pub enum DrawMode { Colorful {palette: String}, Grayscale }
</code></pre>
<p>Install the code generator <code>flutter_rust_bridge_codegen</code>:</p>
<pre><code class="language-bash">cargo install flutter_rust_bridge_codegen
# or with cargo-binstall
cargo binstall flutter_rust_bridge_codegen
# or with scoop (Windows)
scoop bucket add frb https://github.com/Desdaemon/scoop-repo
scoop install flutter_rust_bridge_codegen
# or with Homebrew
brew install desdaemon/repo/flutter_rust_bridge_codegen
</code></pre>
<p><small>(Remark: Thanks @Desdaemon for scripts to publish to brew/scoop)</small></p>
<p>Then run the code generator.</p>
<p><small>Remark: It needs some installation steps. You may refer to <a href="tutorial_with_flutter.html">the tutorial</a>, <a href="template.html">create new projects from a template</a> or <a href="integrate.html">integrating with existing projects</a> for details.</small></p>
<pre><code class="language-bash">flutter_rust_bridge_codegen --rust-input path/to/api.rs \
                            --dart-output path/to/bridge_generated.dart
</code></pre>
<p>With bindings automatically generated, use it seamlessly in Flutter/Dart:</p>
<pre><code class="language-dart">api.drawTree(TreeNode(value: &quot;root&quot;, ...), Colorful(palette: &quot;viridis&quot;));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-a-flutterrust-app"><a class="header" href="#tutorial-a-flutterrust-app">Tutorial: A Flutter+Rust app</a></h1>
<p>In this tutorial, let us draw a <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot set</a> (a well-known infinite-resolution &quot;image&quot; generated by a simple math formula). The image is plotted in Flutter UI, generated by Rust algorithm, and communicated via this library.</p>
<!-- markdownlint-disable MD033 -->
<details>
<summary>(Click to see: What is a Mandelbrot set)</summary>
<p>The Mandelbrot set is the set of complex numbers <code>c</code> for which the function <code>f_c(z)=z^{2}+c</code> does not diverge to infinity when iterated from <code>z=0</code>. Images of the Mandelbrot set exhibit an elaborate and infinitely complicated boundary that reveals progressively ever-finer recursive detail at increasing magnifications.</p>
<p align="center">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Mandelbrot_sequence_new.gif/220px-Mandelbrot_sequence_new.gif">
</p>
<p>Image credit: <a href="https://en.wikipedia.org/wiki/User:Simpsons_contributor">Simpsons contributor</a></p>
</details>
<h2 id="get-code"><a class="header" href="#get-code">Get code</a></h2>
<p>Please <a href="https://flutter.dev/docs/get-started/install">install Flutter</a> (optionally with <a href="https://flutter.dev/desktop">desktop support</a> if you want to run app on desktop instead of cellphones), <a href="https://www.rust-lang.org/learn/get-started">install Rust</a>, and have some familiarity with them. Then get the example codebase:</p>
<pre><code class="language-shell">git clone https://github.com/fzyzcjy/flutter_rust_bridge &amp;&amp; cd flutter_rust_bridge/frb_example/with_flutter
</code></pre>
<h2 id="optional-run-generator"><a class="header" href="#optional-run-generator">Optional: Run generator</a></h2>
<p>This step is optional, since I have generated the source code already (in quickstart). Even if you do it, you should not see anything changed.</p>
<p>As soon as you make any modification to <code>api.rs</code>, you need to run codegen again. More informations about requirements for code generation can be seen in the <a href="integrate/deps.html">Installing dependencies</a> section.</p>
<h2 id="run-app"><a class="header" href="#run-app">Run app</a></h2>
<h3 id="prelogue-command-details"><a class="header" href="#prelogue-command-details">Prelogue: Command details</a></h3>
<p>The <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/workflows/ci.yaml">CI workflow</a> is useful if you want details of each command. The <code>flutter_android_test</code>, <code>flutter_ios_test</code>, <code>flutter_windows_test</code>, <code>flutter_macos_test</code> and <code>flutter_linux_test</code> demonstrates the exact commands needed to run this tutorial codebase from a brand new machine.</p>
<h3 id="android-app"><a class="header" href="#android-app">Android app</a></h3>
<p>Append line <code>ANDROID_NDK=(path to NDK)</code> to <code>android/gradle.properties</code> and run <code>cargo ndk -o ../android/app/src/main/jniLibs build</code>. Then run the Flutter app normally such as <code>flutter run</code>.</p>
<p><strong>Remark</strong>: <a href="https://stackoverflow.com/q/69515032/4619958">This tutorial</a> will help you automatically execute <code>cargo</code> builds when building Flutter app.</p>
<h3 id="ios-app"><a class="header" href="#ios-app">iOS app</a></h3>
<p>Modify <code>Cargo.toml</code> to change <code>cdylib</code> to <code>staticlib</code>, then run <code>cargo lipo &amp;&amp; cp target/universal/debug/libflutter_rust_bridge_example.a ../ios/Runner</code> to build Rust and copy the static library. Then run the Flutter app normally such as <code>flutter run</code>.</p>
<p><strong>Remark</strong>: <a href="https://stackoverflow.com/q/69515032/4619958">This tutorial</a> will help you automatically execute <code>cargo</code> builds when building Flutter app.</p>
<h3 id="windows-app"><a class="header" href="#windows-app">Windows app</a></h3>
<p>Run it directly using <code>flutter run</code> assuming <a href="https://flutter.dev/desktop#set-up">Flutter desktop support</a> has been configured. More details can be seen in <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/66">#66</a>.</p>
<h3 id="linux-app"><a class="header" href="#linux-app">Linux app</a></h3>
<p>Same as Windows. If you install Flutter through <code>snap</code>, please be wary of <a href="https://github.com/canonical/flutter-snap/issues/53">#53</a>.</p>
<h3 id="macos-app"><a class="header" href="#macos-app">MacOS app</a></h3>
<p>Same as Windows. (P.S. Under the hood, <code>cargo-xcode</code> is used to automate the process)</p>
<h3 id="web-as-a-webpage"><a class="header" href="#web-as-a-webpage">Web (as a webpage)</a></h3>
<p>Install <code>flutter_rust_bridge_serve</code> to simplify the process of building and serving a WASM binary.
See <a href="template/setup_web.html">Web setup</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>In this chapter, we are going to demonstrate the features. Please use the menu bar at the left / left-top of the page to navigate.</p>
<h2 id="prelogue"><a class="header" href="#prelogue">Prelogue</a></h2>
<h3 id="what-this-library-is-and-is-not"><a class="header" href="#what-this-library-is-and-is-not">What this library is and is not</a></h3>
<p>This library is nothing but a code generator that helps your Flutter/Dart functions call Rust functions. It only generates some boilerplate code that you will manually write down otherwise. Moreover, we have provided detailed tutorials for you to play with examples, set up brand new apps, and integrate with existing apps.</p>
<p>Of course, you may still need to have some basic familiarity with Flutter/Dart, Rust, and its <a href="https://flutter.dev/docs/development/platform-integration/c-interop">ffi</a>.</p>
<h3 id="full-examples"><a class="header" href="#full-examples">Full examples</a></h3>
<p>If you want to look at a lot of examples - I have to warn you, really too many - have a look at <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/pure_dart/rust/src/api.rs">pure_dart's api.rs</a>. It contains all tests for this library.</p>
<p>In addition, when you are quite familiar with the basic example, you can then take a look at <a href="https://github.com/fzyzcjy/flutter_rust_bridge/tree/master/frb_example/pure_dart_multi/rust/src">pure_dart_multi</a>. This example contains multiple blocks of APIs instead of one, which is quite useful for complex projects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-translations"><a class="header" href="#language-translations">Language translations</a></h1>
<p>In this section, we will show how various language features are translated between Rust and Dart.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-correspondence"><a class="header" href="#simple-correspondence">Simple correspondence</a></h1>
<p>Here is a brief glance showing what the code generator can generate (non-exhaustive). Some rows have hyper-links pointing to more detailed explanations.</p>
<div class="table-wrapper"><table><thead><tr><th>Rust</th><th>Dart</th></tr></thead><tbody>
<tr><td><a href="feature/lang_vec.html"><code>Vec&lt;u8&gt;</code>, <code>Vec&lt;i8&gt;</code>..</a></td><td><code>Uint8List</code>, <code>Int8List</code>, ..</td></tr>
<tr><td><a href="feature/lang_vec.html"><code>Vec&lt;T&gt;</code></a></td><td><code>List&lt;T&gt;</code></td></tr>
<tr><td><a href="feature/lang_vec.html"><code>[T; N]</code></a></td><td><code>List&lt;T&gt;</code></td></tr>
<tr><td><a href="feature/lang_struct.html"><code>struct { .. }</code>, <code>struct( .. )</code></a></td><td><code>class</code></td></tr>
<tr><td><a href="feature/lang_enum.html"><code>enum { A, B }</code></a></td><td><code>enum</code></td></tr>
<tr><td><a href="feature/lang_enum.html"><code>enum { A(..) }</code></a></td><td><code>@freezed class</code></td></tr>
<tr><td><a href="feature/lang_external.html"><code>use ...</code></a></td><td>act normally</td></tr>
<tr><td><a href="feature/lang_option.html"><code>Option&lt;T&gt;</code></a></td><td><code>T?</code></td></tr>
<tr><td><code>Box&lt;T&gt;</code></td><td><code>T</code></td></tr>
<tr><td>comments</td><td>same</td></tr>
<tr><td><code>Result::Err</code>, panic</td><td><code>throw Exception</code></td></tr>
<tr><td><code>i8</code>, <code>u8</code>, .., <code>usize</code></td><td><code>int</code></td></tr>
<tr><td><code>f32</code>, <code>f64</code></td><td><code>double</code></td></tr>
<tr><td><code>bool</code></td><td><code>bool</code></td></tr>
<tr><td><code>String</code></td><td><code>String</code></td></tr>
<tr><td><code>()</code></td><td><code>void</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="vec-and-array"><a class="header" href="#vec-and-array">Vec and array</a></h1>
<h2 id="vecu8-veci8-"><a class="header" href="#vecu8-veci8-"><code>Vec&lt;u8&gt;</code>, <code>Vec&lt;i8&gt;</code>, ...</a></h2>
<p>In Dart, when you want to express a long byte array such as a big image or some binary blob, people normally use <code>Uint8List</code> instead of <code>List&lt;int&gt;</code> since the former is much performant. <code>flutter_rust_bridge</code> takes this into consideration for you. When you have <code>Vec&lt;u8&gt;</code> (or <code>Vec&lt;i8&gt;</code>, or <code>Vec&lt;i32&gt;</code>, etc), it will be translated it into <code>Uint8List</code> or its friends.</p>
<h2 id="vect"><a class="header" href="#vect"><code>Vec&lt;T&gt;</code></a></h2>
<p>When you have normal <code>Vec&lt;T&gt;</code> for <code>T</code> types other than <code>u8</code>, <code>i8</code> etc, it will be converted to normal <code>List&lt;T&gt;</code>.</p>
<h2 id="t-n"><a class="header" href="#t-n"><code>[T; N]</code></a></h2>
<p>Since Dart does not have special treatment for static-sized arrays, it is converted to <code>List&lt;T&gt;</code> as well.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-rust noplayground">pub fn draw_tree(tree: Vec&lt;TreeNode&gt;) -&gt; Vec&lt;u8&gt; { ... }
</code></pre>
<p>Becomes:</p>
<pre><code class="language-Dart">Future&lt;Uint8List&gt; drawTree({required List&lt;TreeNode&gt; tree});
</code></pre>
<p>Remark: If you are curious about <code>Future</code>, have a look at <a href="feature/async_dart.html">this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs"><code>struct</code>s</a></h1>
<p>Normal Rust structs are supported. You can even use recursive fields, such as <code>pub struct TreeNode { pub value: String, pub children: Vec&lt;MyTreeNode&gt;, pub parent: Box&lt;MyTreeNode&gt; }</code>.</p>
<p>If a struct field has type being a struct or an enum, please add a <code>Box</code> on it, or it will lead to compile-time error. For example, <code>struct A {b: B}</code> should be <code>struct A {b: Box&lt;B&gt;}</code> instead.</p>
<h2 id="tuple-structs"><a class="header" href="#tuple-structs">Tuple structs</a></h2>
<p>Tuple structs <code>struct Foo(A, B)</code> are translated as <code>class Foo { A field0; B field1; }</code>, since Dart does not have anonymous fields.</p>
<h2 id="non-final-fields"><a class="header" href="#non-final-fields">Non-final fields</a></h2>
<p>By adding <code>#[frb(non_final)]</code> to a field of struct, the corresponding field in Dart will be non-final. By default, we make all generated fields final because of Rust's philosophy - immutable by default.</p>
<h2 id="dart-metadata-annotations"><a class="header" href="#dart-metadata-annotations">Dart metadata annotations</a></h2>
<p>You can add dart metadata annotations using <code>dart_metadata</code> parameter in <code>frb</code> macro.</p>
<ul>
<li>For annotations that are prelude by dart (e.g. <code>@deprecated</code>), just put annotation as a Rust literal.</li>
<li>If importing is needed, then add importing part behind the annotation string. Currently two forms of importing supported:
<ul>
<li><code>import 'somepackage'</code></li>
<li><code>import 'somepackage' as somename</code>, where <code>somename</code> will be the prefix of the annotation</li>
</ul>
</li>
<li>Multiple annotations are seperated by comma <code>,</code>.</li>
</ul>
<p>See below for an example.</p>
<h2 id="freezed-dart-classes"><a class="header" href="#freezed-dart-classes"><code>freezed</code> Dart classes</a></h2>
<p>If you want the generated Dart class to be <a href="https://pub.dev/packages/freezed"><code>freezed</code></a> (which is like data-classes in other languages like Kotlin), simply put <code>#[frb(dart_metadata=(&quot;freezed&quot;))]</code> and it will generate everything needed for you.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<h3 id="example-1-recursive-fields"><a class="header" href="#example-1-recursive-fields">Example 1: Recursive fields</a></h3>
<pre><code class="language-rust noplayground">pub struct MyTreeNode {
    pub value: Vec&lt;u8&gt;,
    pub children: Vec&lt;MyTreeNode&gt;,
}
</code></pre>
<p>Becomes:</p>
<pre><code class="language-Dart">class MyTreeNode {
  final Uint8List value;
  final List&lt;MyTreeNode&gt; children;
  MyTreeNode({required this.value, required this.children});
}
</code></pre>
<p>Remark: If you are curious about <code>Future</code>, have a look at <a href="feature/async_dart.html">this</a>.</p>
<h3 id="example-2-metadata"><a class="header" href="#example-2-metadata">Example 2: Metadata</a></h3>
<pre><code class="language-rust noplayground">#[frb(dart_metadata=(&quot;freezed&quot;, &quot;immutable&quot; import &quot;package:meta/meta.dart&quot; as meta))]
pub struct UserId {
    pub value: u32,
}
</code></pre>
<p>Becomes:</p>
<pre><code class="language-dart">import 'package:meta/meta.dart' as meta;

@freezed
@meta.immutable
class UserId with _$UserId {
  const factory UserId({
    required int value,
  }) = _UserId;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums"><code>enum</code>s</a></h1>
<p>Rust's <code>enum</code> are known to be very expressive and powerful - it allows each enum variant to have different associated data. Dart does not have such things in built-in enums, but no worries - we will automatically translate it into the equivalent using the <code>freezed</code> Dart library. The syntax for <code>freezed</code> may look a bit strange at the first glance, but please look at <a href="https://pub.dev/packages/freezed">its doc</a> and see its powerfulness.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><code class="language-rust noplayground">pub enum KitchenSink {
    Empty,
    Primitives {
        /// Dart field comment
        int32: i32,
        float64: f64,
        boolean: bool,
    },
    Nested(Box&lt;KitchenSink&gt;),
    Optional(
        /// Comment on anonymous field
        Option&lt;i32&gt;,
        Option&lt;i32&gt;,
    ),
    Buffer(ZeroCopyBuffer&lt;Vec&lt;u8&gt;&gt;),
    Enums(Weekdays),
}
</code></pre>
<p>Becomes:</p>
<pre><code class="language-Dart">@freezed
class KitchenSink with _$KitchenSink {
  /// Comment on variant
  const factory KitchenSink.empty() = Empty;
  const factory KitchenSink.primitives({
    /// Dart field comment
    required int int32,
    required double float64,
    required bool boolean,
  }) = Primitives;
  const factory KitchenSink.nested(
    KitchenSink field0,
  ) = Nested;
  const factory KitchenSink.optional([
    /// Comment on anonymous field
    int? field0,
    int? field1,
  ]) = Optional;
  const factory KitchenSink.buffer(
    Uint8List field0,
  ) = Buffer;
  const factory KitchenSink.enums(
    Weekdays field0,
  ) = Enums;
}
</code></pre>
<p>And they are powered with <a href="https://pub.dev/packages/freezed">all functionalities</a> of <code>freezed</code>.</p>
<p>Remark: If you are curious about <code>Future</code>, have a look at <a href="feature/async_dart.html">this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-types"><a class="header" href="#external-types">External types</a></h1>
<h2 id="types-in-other-files-within-the-same-crate"><a class="header" href="#types-in-other-files-within-the-same-crate">Types in other files within the same crate</a></h2>
<p>Imported symbols can be used normally. For example, with <code>use crate::data::{MyEnum, MyStruct};</code>, you can use <code>MyEnum</code> or <code>MyStruct</code> in your code normally.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-rust noplayground">use crate::data::{MyEnum, MyStruct};

pub fn use_imported_things(my_struct: MyStruct, my_enum: MyEnum) { ... }
</code></pre>
<p>Becomes:</p>
<pre><code class="language-Dart">// Well it just behaves normally as you expect
Future&lt;void&gt; useImportedThings({required MyStruct myStruct, required MyEnum myEnum});
</code></pre>
<p>Remark: If you are curious about <code>Future</code>, have a look at <a href="feature/async_dart.html">this</a>.</p>
<h2 id="types-in-other-crates"><a class="header" href="#types-in-other-crates">Types in other crates</a></h2>
<p>The feature is called &quot;mirroring&quot;. In short, you need to define the type again mirroring the external type that you want to use. That definition is only used at code-generation time to tell <code>flutter_rust_bridge</code> type information. To see exact grammar, have a look at the example below.</p>
<p>No need to worry whether this breaks the DRY principle, or what happens when you accidentially write down a wrong field. This is because <em>compile errors will happen</em> if your mirrored type is not exactly same as the original type.</p>
<p>More information: <a href="https://github.com/fzyzcjy/flutter_rust_bridge/pull/352">#352</a></p>
<p>When multiple structs have the same fields, you can mirror them <em>once</em> using grammar like <code>#[frb(mirror(FirstStruct, SecondStruct, ThirdStruct))]</code>. (<a href="https://github.com/fzyzcjy/flutter_rust_bridge/pull/619">#619</a>)</p>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-rust noplayground">// Mirroring example:
// The goal of mirroring is to use external objects without needing to convert them with an intermediate type
// In this case, the struct ApplicationSettings is defined in another crate (called external-lib)

// To use an external type with mirroring, it MUST be imported publicly (aka. re-export)
pub use external_lib::{ApplicationEnv, ApplicationMode, ApplicationSettings};

// To mirror an external struct, you need to define a placeholder type with the same definition
#[frb(mirror(ApplicationSettings))]
pub struct _ApplicationSettings {
    pub name: String,
    pub version: String,
    pub mode: ApplicationMode,
    pub env: Box&lt;ApplicationEnv&gt;,
}

// It works with basic enums too
// Enums with struct variants are not yet supported
#[frb(mirror(ApplicationMode))]
pub enum _ApplicationMode {
    Standalone,
    Embedded,
}

#[frb(mirror(ApplicationEnv))]
pub struct _ApplicationEnv {
    pub vars: Vec&lt;String&gt;,
}

// This function can directly return an object of the external type ApplicationSettings because it has a mirror
pub fn get_app_settings() -&gt; ApplicationSettings {
    external_lib::get_app_settings()
}

// Similarly, receiving an object from Dart works. Please note that the mirror definition must match entirely and the original struct must have all its fields public.
pub fn is_app_embedded(app_settings: ApplicationSettings) -&gt; bool {
    // println!(&quot;env: {}&quot;, app_settings.env.vars[0]);
    match app_settings.mode {
        ApplicationMode::Standalone =&gt; false,
        ApplicationMode::Embedded =&gt; true,
    }
}
</code></pre>
<p>Another example using one struct to mirror multiple structs:</p>
<pre><code class="language-rust noplayground">// *no* need to do these
#[frb(mirror(MessageId))]
pub struct MId(pub [u8; 32]);
#[frb(mirror(BlobId))]
pub struct BId(pub [u8; 32]);
#[frb(mirror(FeedId))]
pub struct FId(pub [u8; 32]);

// simply do this is sufficient
#[frb(mirror(MessageId, BlobId, FeedId))]
pub struct Id(pub [u8; 32]);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options"><a class="header" href="#options"><code>Option</code>s</a></h1>
<p>Dart has special syntaxs for nullable variables - the <code>?</code> symbol, and we translate <code>Option</code> into <code>?</code> automatically. You may refer to <a href="https://dart.dev/null-safety">the official doc</a> for more information. </p>
<p>In addition, <code>flutter_rust_bridge</code> also understands the <code>required</code> keyword in Dart: If an argument is not-null, it is marked as <code>required</code> since you have to provide a value. On the other hand, if it is nullable, no <code>required</code> is needed since by Dart's convention a null is there in absence of manually providing a value.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<pre><code class="language-rust noplayground">pub struct Element {
    pub tag: Option&lt;String&gt;,
    pub text: Option&lt;String&gt;,
    pub attributes: Option&lt;Vec&lt;Attribute&gt;&gt;,
    pub children: Option&lt;Vec&lt;Element&gt;&gt;,
}

pub fn parse(mode: String, document: Option&lt;String&gt;) -&gt; Option&lt;Element&gt; { ... }
</code></pre>
<p>Becomes:</p>
<pre><code class="language-Dart">Future&lt;Element?&gt; handleOptionalStruct({required String mode, String? document});

class Element {
  final String? tag;
  final String? text;
  final List&lt;Attribute&gt;? attributes;
  final List&lt;Element&gt;? children;
  Element({this.tag, this.text, this.attributes, this.children});
}
</code></pre>
<p>Remark: If you are curious about <code>Future</code>, have a look at <a href="feature/async_dart.html">this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<p>There is support for structs with methods. Both static methods, and non-static methods are supported.</p>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre><code class="language-rust noplayground">pub struct SumWith { pub x: u32 }

impl SumWith {
    pub fn sum(&amp;self, y: u32) -&gt; u32 { self.x + y }
    pub fn sum_static(x: u32, y: u32) -&gt; u32 { x + y }
}
</code></pre>
<p>Becomes:</p>
<pre><code class="language-Dart">class SumWith {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  final int x;

  SumWith({
    required this.bridge,
    required this.x,
  });

  Future&lt;int&gt; sum({required int y, dynamic hint}) =&gt; ..
  static Future&lt;int&gt; sum({required int x, required int y, dynamic hint}) =&gt; ..
}
</code></pre>
<p>Remark: If you are curious about <code>Future</code>, have a look at <a href="feature/async_dart.html">this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return-types"><a class="header" href="#return-types">Return Types</a></h1>
<p>The return type can be either <code>anyhow::Result&lt;YourType&gt;</code>, or <code>YourType</code> directly.</p>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<pre><code class="language-rust noplayground">pub fn f(a: i32, b: i32) -&gt; i32 { a + b }

pub fn g(a: i32, b: i32) -&gt; anyhow::Result&lt;i32&gt; { Ok(a + b) }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-copy"><a class="header" href="#zero-copy">Zero copy</a></h1>
<p><code>ZeroCopyBuffer&lt;Vec&lt;u8&gt;&gt;</code> (and its friends like <code>ZeroCopyBuffer&lt;Vec&lt;i8&gt;&gt;</code>) sends the data from Rust to Dart without making copies<sup class="footnote-reference"><a href="#1">1</a></sup>. Thus, you save the time of copying data, which can be large if your data is big (such as a high-resolution image).</p>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<pre><code class="language-rust noplayground">pub fn draw_tree(tree: Vec&lt;TreeNode&gt;) -&gt; ZeroCopyBuffer&lt;Vec&lt;u8&gt;&gt; { ... }
</code></pre>
<p>Becomes:</p>
<pre><code class="language-Dart">Future&lt;Uint8List&gt; drawTree({required List&lt;TreeNode&gt; tree});
</code></pre>
<p>The generated Dart code looks exactly the same as the case without <code>ZeroCopyBuffer</code>. However, the internal implementation changes and there is no memory copy at all!</p>
<p>Remark: If you are curious about <code>Future</code>, have a look at <a href="feature/async_dart.html">this</a>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Not currently supported on Web, and will fallback to copying the buffer.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stream--iterator"><a class="header" href="#stream--iterator"><code>Stream</code> / <code>Iterator</code></a></h1>
<p>What is <code>Stream</code>? In short: call once, return multiple times; like <code>Iterator</code>s.</p>
<p>Flutter's <a href="https://dart.dev/tutorials/language/streams">Stream</a> is a powerful abstraction. When using it as the return value of Rust function, we can allow the scenario that we call function once, and then return multiple times.</p>
<p>For example, your Rust function may run computationally heavy algorithms, and for every hundreds of milliseconds, it finds out a new piece of the full solution. In this case, it can immediately give that piece to Flutter, then Flutter can render it to UI immediately. Therefore, users do not need to wait for the full algorithm to finish before he can see some partial results on the user interface.</p>
<p>As for the details, a Rust function with signature like <code>fn f(sink: StreamSink&lt;T&gt;, ..) -&gt; Result&lt;()&gt;</code> is translated to a Dart function  <code>Stream&lt;T&gt; f(..)</code>.</p>
<p>Notice that, you can hold that <code>StreamSink</code> forever, and use it freely even <em>after the Rust function itself returns</em>. The logger example below also demonstrates this (the <code>create_log_stream</code> returns almost immediately, while you can use the <code>StreamSink</code> after, say, an hour).</p>
<p>The <code>StreamSink</code> can be placed at any location. For example, <code>fn f(a: i32, b: StreamSink&lt;String&gt;)</code> and <code>fn f(a: StreamSink&lt;String&gt;, b: i32)</code> are both valid.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>See <a href="feature/logging.html">logging examples</a> which uses streams extensively.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-in-dart"><a class="header" href="#asynchronous-in-dart">Asynchronous in Dart</a></h1>
<p>This library generates functions that are <em>asynchronous</em> in Dart by default. So you will see <code>fn f(..) -&gt; String</code> becomes <code>Future&lt;String&gt; f(..)</code> with that interesting <code>Future</code>.</p>
<p>Why? Flutter UI is single-threaded. If you use the intuitive synchronous approach, just like what you will (have to) do with plain-old Flutter bindings, your UI will be <em>stuck</em> as long as your Rust code is executing. If your Rust code run for 100ms for a heavy computation, your UI will fully freeze for 100ms and the users will not be happy.</p>
<p>On the other hand, with the generated asynchronous bindings in Dart, you can simply call functions directly in main isolate (thread) of Dart/Flutter, and Rust code will not block the Flutter UI.</p>
<p>Indeed async and <code>Future</code>s is almost everywhere in Flutter/Dart, and it has very good built-in support. So no worries about it ;)</p>
<p>Remark: A common mistake is to call Rust code in <em>another</em> Dart isolate (i.e. &quot;thread&quot;) instead of the main isolate. That is completely not needed, and will only make your life harder. As is described above, even if your Rust code computes for 100ms, the async call will only take, say, 0.1ms, and will not block your UI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronous-in-dart"><a class="header" href="#synchronous-in-dart">Synchronous in Dart</a></h1>
<p>If you need to generate synchronous functions in Dart, you can use <code>SyncReturn&lt;T&gt;</code> as the return type.</p>
<p>We suggest only do this for very quick Rust functions, or the Dart UI will be blocked.</p>
<p>Currently, <code>SyncReturn</code> supports <code>String</code>, <code>Vec&lt;u8&gt;</code> and primitive types(<code>bool</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>f32</code>, <code>f64</code>). Please open an issue if you need other types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<p>Multiple Rust functions can be running at the same time, and they will be running concurrently. This is because by default we use a thread pool to execute the Rust functions. However, you can fully customize this behavior (and even throw away the thread pool).</p>
<h2 id="example-9"><a class="header" href="#example-9">Example</a></h2>
<p>Consider the following Rust code:</p>
<pre><code class="language-rust noplayground">pub fn compute() {
  thread::sleep(Duration::from_millis(1000));
}
</code></pre>
<p>And the following Dart code using it:</p>
<pre><code class="language-dart">var a = compute();
var b = compute();
var c = compute();
await Future.wait([a, b, c]); // You may need to learn `Future` and `async` in Dart to understand this
</code></pre>
<p>Then it will take 1 second instead of 3 seconds to complete the code, because multiple <code>compute</code> can run concurrently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handler"><a class="header" href="#handler">Handler</a></h1>
<p>By default, the <code>DefaultHandler</code> is used. You can implement your own <code>Handler</code> doing whatever you want. In order to do this, create a variable named <code>FLUTTER_RUST_BRIDGE_HANDLER</code> in the Rust input file (probably using <code>lazy_static</code>). You may not need to create a brand new struct implementing <code>Handler</code>, but instead, use the <code>SimpleHandler</code> and customize its generic arguments such as its <code>Executor</code>.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="example-report-errors-to-your-backend-in-addition-to-telling-dart"><a class="header" href="#example-report-errors-to-your-backend-in-addition-to-telling-dart">Example: Report errors to your backend in addition to telling Dart</a></h3>
<pre><code class="language-rust noplayground">pub struct MyErrorHandler(ReportDartErrorHandler);

impl ErrorHandler for MyErrorHandler {
    fn handle_error(&amp;self, port: i64, error: handler::Error) {
        send_error_to_your_backend(&amp;error);
        self.0.handle_error(port, error)
    }
    
    ...
}
</code></pre>
<h3 id="example-log-when-execution-starts-and-ends"><a class="header" href="#example-log-when-execution-starts-and-ends">Example: Log when execution starts and ends</a></h3>
<pre><code class="language-rust noplayground">pub struct MyExecutor(ThreadPoolExecutor&lt;MyErrorHandler&gt;);

impl Executor for MyExecutor {
    fn execute&lt;TaskFn, TaskRet&gt;(&amp;self, wrap_info: WrapInfo, task: TaskFn) {
        let debug_name_string = wrap_info.debug_name.to_string();
        self.thread_pool_executor
            .execute(wrap_info, move |task_callback| {
                Self::log_around(&amp;debug_name_string, move || task(task_callback))
            })
    }
}

impl MyExecutor {
    fn log_around&lt;F, R&gt;(debug_name: &amp;str, f: F) -&gt; R where F: FnOnce() -&gt; R {
        let start = Instant::now();
        debug!(&quot;(Rust) execute [{}] start&quot;, debug_name);
        let ret = f();
        debug!(&quot;(Rust) execute [{}] end delta_time={}ms&quot;, debug_name, start.elapsed().as_millis());
        ret
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initialization"><a class="header" href="#initialization">Initialization</a></h1>
<p>If you want that feature, have a look at <code>FlutterRustBridgeSetupMixin</code> in the Dart side. (More documentaions to be added; you can create an issue if you have questions now.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-in-rust"><a class="header" href="#async-in-rust">Async in Rust</a></h1>
<p>To use async/await or return a Future type from your Rust functions, please refer to <a href="feature/../article/async_in_rust.html">this documentation</a>. If you have interest in more integrated generator, please create and issue.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-files"><a class="header" href="#multiple-files">Multiple files</a></h1>
<p>When having a large project, it is often insufficient to put everything in a single <code>api.rs</code>, but instead we may want to separate it into <code>api_of_one_module.rs</code>, <code>api_of_another_module.rs</code>, etc. That is why we have this feature.</p>
<p>Basically, just specify all input Rust files and all output locations and we are done. Here is an example:</p>
<pre><code class="language-shell">flutter_rust_bridge_codegen \
  --rust-input &quot;$REPO_DIR/native/src/api_1.rs&quot; &quot;$REPO_DIR/native/src/api_2.rs&quot; \
  --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_1.dart&quot; &quot;$REPO_DIR/lib/bridge_generated_api_2.dart&quot; \
  --class-name ApiClass1 ApiClass2 \
  --rust-output generated_api_1 generated_api_2
</code></pre>
<p>For more details, have a look at <a href="feature/../article/generate_multiple_files.html">this article</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-in-buildrs"><a class="header" href="#run-in-buildrs">Run in <code>build.rs</code></a></h1>
<p>There are basically two approaches to execute the code generator. The first and most evident approach is to directly execute the <code>flutter_rust_bridge</code> in command line.</p>
<p>The second approach is to integrate it into <code>build.rs</code> of your project. With this approach, the code generator is automatically triggered whenever you build your Rust project. For example configuration, have a look at this <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/pure_dart/rust/build.rs">build.rs</a> file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cancellable-tasks"><a class="header" href="#cancellable-tasks">Cancellable tasks</a></h1>
<p>When the Rust code is computationally heavy, you may want to cancel it at the middle when, for example, the user does not need it anymore. Then the precious computation power can be saved.</p>
<p>Installation: Currently, the feature is complete, and I have used it in my own app for a long time. (I have not merge this PR to the main repo just because I need to figure out how to put those code as if in <code>api.rs</code>.) Thus, visit <a href="https://github.com/fzyzcjy/flutter_rust_bridge/pull/333">#333</a> and copy the code directly to your project, and use it as normal.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-pools"><a class="header" href="#object-pools">Object pools</a></h1>
<p>When there are some big objects in the Rust side, you may not want to copy them between Rust and Dart over and over again. That is when object pools become useful: You only pass around a &quot;object handle&quot; (indeed just a few integers) between Rust and Dart, and the Rust side will convert that handle from and to the real object.</p>
<p>Installation: Same as <a href="feature/cancelable_task.html">cancelable tasks</a>, please see doc there.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm"><a class="header" href="#wasm">WASM</a></h1>
<p><code>flutter_rust_bridge_codegen</code> can also generate code to run in browsers using
<code>wasm_bindgen</code>. To generate WASM-specifc files, pass in these two options to your
invocation:</p>
<pre><code class="language-shell">flutter_rust_bridge_codegen .. --wasm --dart-decl-output &lt;DECL&gt;
</code></pre>
<p>where <code>DECL</code> is the path to the common class/function declarations file.
For example, if you emit your Dart bridge to <code>lib/bridge_generated.dart</code>,
you can put the declarations file at <code>lib/bridge_definitions.dart</code></p>
<p>By default this will create several new files:</p>
<pre><code>‚îú‚îÄ‚îÄ lib
‚îÇ   ‚îú‚îÄ‚îÄ bridge_definitions.dart
‚îÇ   ‚îú‚îÄ‚îÄ bridge_generated.io.dart
‚îÇ   ‚îî‚îÄ‚îÄ bridge_generated.web.dart
‚îî‚îÄ‚îÄ native/src
    ‚îú‚îÄ‚îÄ bridge_generated.io.rs
    ‚îî‚îÄ‚îÄ bridge_generated.web.rs
</code></pre>
<p>The <code>.io</code> and <code>.web</code> modules implement platform-specific helpers. This
split is mandatory for Dart due to its module system, however if you prefer to keep the Rust bridge in a single file pass the <code>--inline-rust</code>
flag as well.</p>
<p>Check out <a href="feature/../integrate/web.html">Integrating with Web</a> for instructions
on how to consume the web bridge.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h1>
<h2 id="separate-generated-definitions-from-implementations"><a class="header" href="#separate-generated-definitions-from-implementations">Separate generated definitions from implementations</a></h2>
<p>The generated <code>bridge_generated.dart</code> by default contains definitions of the APIs as well as the implementations. With the flag <code>--dart-decl-output</code>, the two can be separated, and the definitions will not contain anything like <code>dart:ffi</code>.</p>
<p>More information: <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/298">#298</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>Since I have seen some questions asking how logging can be implemented with a Flutter + Rust application, here are some examples.</p>
<h2 id="logger-in-production"><a class="header" href="#logger-in-production">Logger in production</a></h2>
<p>In my own app in production, I use the following strategy for Rust logging: Use normal Rust logging methods, such as <code>info!</code> and <code>debug!</code> macros. The logs are consumed in two places: They are printed via platform-specific methods (like android Logcat and iOS NSLog), and also use a Stream to send them to the Dart side such that my Dart code and further process it using the same pipeline as normal Dart logs (e.g. save to a file, send to server, etc).</p>
<p>The <em>full</em> code related to logging in my app can be seen here: <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/486">#486</a>.</p>
<h2 id="simple-logger"><a class="header" href="#simple-logger">Simple logger</a></h2>
<p>Let us implement a simple logging system (adapted from the logging system I use with <code>flutter_rust_bridge</code> in my app in production), where Rust code can send logs to Dart code.</p>
<p>The Rust <code>api.rs</code>:</p>
<pre><code class="language-rust noplayground">pub struct LogEntry {
    pub time_millis: i64,
    pub level: i32,
    pub tag: String,
    pub msg: String,
}

// Simplified just for demonstration.
// To compile, you need a OnceCell, or Mutex, or RwLock
// Also see https://github.com/fzyzcjy/flutter_rust_bridge/issues/398
lazy_static! { static ref log_stream_sink: StreamSink&lt;LogEntry&gt;; }

pub fn create_log_stream(s: StreamSink&lt;LogEntry&gt;) {
    stream_sink = s;
}
</code></pre>
<p>Now Rust will probably complain at you because <code>IntoDart</code> is not implemented for <code>LogEntry</code>. This is expected, because <code>flutter_rust_bridge</code> will generate this trait implementation for you.
To fix this error you should just rerun <code>flutter_rust_bridge_codegen</code>.</p>
<p>Generated Dart code:</p>
<pre><code class="language-Dart">Stream&lt;LogEntry&gt; createLogStream();
</code></pre>
<p>Now let us use it in Dart:</p>
<pre><code class="language-dart">Future&lt;void&gt; setup() async {
    createLogStream().listen((event) {
      print('log from rust: ${event.level} ${event.tag} ${event.msg} ${event.timeMillis}');
    });
}
</code></pre>
<p>And now we can happily log anything in Rust:</p>
<pre><code class="language-rust noplayground">log_stream_sink.add(LogEntry { msg: &quot;hello I am a log from Rust&quot;, ... })
</code></pre>
<p>Of course, you can implement a logger following the Rust's <code>log</code> crate wrapping this raw stream sink, then you can use standard Rust logging mechanisms like <code>info!</code>. I exactly did that in my project.</p>
<h3 id="example-simple-timer"><a class="header" href="#example-simple-timer">Example: Simple timer</a></h3>
<p>Credits: <a href="https://gist.github.com/Desdaemon/be5da0a1c6b4724f20093ef434959744">this</a> and <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/347">#347</a>.</p>
<pre><code class="language-rust noplayground">use anyhow::Result;
use std::{thread::sleep, time::Duration};

use flutter_rust_bridge::StreamSink;

const ONE_SECOND: Duration = Duration::from_secs(1);

// can't omit the return type yet, this is a bug
pub fn tick(sink: StreamSink&lt;i32&gt;) -&gt; Result&lt;()&gt; {
    let mut ticks = 0;
    loop {
        sink.add(ticks);
        sleep(ONE_SECOND);
        if ticks == i32::MAX {
            break;
        }
        ticks += 1;
    }
    Ok(())
}
</code></pre>
<p>And use it in Dart:</p>
<pre><code class="language-dart">import 'package:flutter/material.dart';
import 'ffi.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const MyHomePage(title: 'Flutter Demo Home Page'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({Key? key, required this.title}) : super(key: key);
  final String title;

  @override
  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();
}

class _MyHomePageState extends State&lt;MyHomePage&gt; {
  late Stream&lt;int&gt; ticks;

  @override
  void initState() {
    super.initState();
    ticks = api.tick();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: &lt;Widget&gt;[
            const Text(&quot;Time since starting Rust stream&quot;),
            StreamBuilder&lt;int&gt;(
              stream: ticks,
              builder: (context, snap) {
                final style = Theme.of(context).textTheme.headline4;
                final error = snap.error;
                if (error != null)
                  return Tooltip(
                      message: error.toString(),
                      child: Text('Error', style: style));

                final data = snap.data;
                if (data != null) return Text('$data second(s)', style: style);

                return const CircularProgressIndicator();
              },
            )
          ],
        ),
      ),
    );
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-new-projects-from-a-template"><a class="header" href="#create-new-projects-from-a-template">Create new projects from a template</a></h1>
<p>In this chapter, we are going to use create your own project from a code template. It seems a bit long, but it is just because we have tried to describe <em>every detail</em> that you may encounter.</p>
<p><strong>Remark:</strong> Most complexity does <em>not</em> come from this library, <code>flutter_rust_bridge</code> - it is as same complex as using raw Dart/Flutter FFI with Rust. In other words, it is the Dart/Flutter + Rust toolchain that takes time to set up.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-new-project"><a class="header" href="#creating-a-new-project">Creating a new project</a></h1>
<p>Start by creating a repository using the template from <a href="https://github.com/Desdaemon/flutter_rust_bridge_template">flutter_rust_bridge_template</a>
and cloning it. This template is set up to be able to <code>flutter run</code> for most platforms
that Flutter supports.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android-setup"><a class="header" href="#android-setup">Android setup</a></h1>
<p>For Android, a few components are required to get started:</p>
<h2 id="rust-targets"><a class="header" href="#rust-targets">Rust targets</a></h2>
<p>If you have not already done so, cross-compiling to Android requires some additional
targets which can easily be added:</p>
<pre><code class="language-shell">rustup target add \
    aarch64-linux-android \
    armv7-linux-androideabi \
    x86_64-linux-android \
    i686-linux-android
</code></pre>
<h2 id="jdk-8"><a class="header" href="#jdk-8">JDK 8</a></h2>
<p>Android Studio depends on the <code>javax</code> library being present in the Java runtime, and the only reliable way to ensure this is to install an older version of Java. On Unix-like systems, you can use <a href="https://asdf-vm.com/">asdf</a> or similar tools to manage your Java versions, and the template defines a known working version of Java in the <code>.tool-versions</code> file.</p>
<h2 id="android-ndk"><a class="header" href="#android-ndk">Android NDK</a></h2>
<blockquote>
<p>Android Studio &gt; SDK Manager &gt; SDK Tools &gt; uncheck Hide Obsolete Packages &gt; NDK (version 22)</p>
</blockquote>
<p>The <a href="https://developer.android.com/ndk">Android NDK</a>, or Native Development Kit, enables code written in other
languages to be run on the JVM via the <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html">Java Native Interface</a>, or JNI for short. In this case, we would like to pass the dynamic libraries created by Cargo to be included in the bundle when we run or build the project.</p>
<p>After following the instructions above, the NDK should be installed in your <code>$ANDROID_SDK_HOME/ndk</code> folder, where ANDROID_SDK_HOME usually is:</p>
<ul>
<li>on Windows: <code>%APPDATA%\Local\Android\sdk</code></li>
<li>on MacOS: <code>~/Library/Android/sdk</code></li>
<li>on Linux: set via the environment variable ANDROID_SDK_HOME, or <code>~/Android/sdk</code></li>
</ul>
<p><a href="https://github.com/rust-lang/rust/pull/85806">An issue</a> regarding building Rust's <code>core</code> library against the latest NDK means that as of writing only NDK versions 22 and older can be used.</p>
<h2 id="android_ndk-gradle-property"><a class="header" href="#android_ndk-gradle-property"><code>ANDROID_NDK</code> Gradle property</a></h2>
<pre><code class="language-shell">echo &quot;ANDROID_NDK=(path to NDK)&quot; &gt;&gt; ~/.gradle/gradle.properties
</code></pre>
<p>Next, you need to make this NDK visible to Gradle. The way to do this depends on your current system and is unlikely to be portable, but generally you can add a <code>gradle.properties</code> in your <code>~/.gradle</code> folder like this:</p>
<pre><code>ANDROID_NDK=(path to NDK)
</code></pre>
<p>or edit one of the <code>gradle.properties</code> that resides within the <code>android</code> folder.</p>
<h2 id="cargo-ndk"><a class="header" href="#cargo-ndk"><a href="https://github.com/bbqsrc/cargo-ndk">cargo-ndk</a></a></h2>
<pre><code class="language-shell">cargo install cargo-ndk --version 2.6.0
</code></pre>
<p><a href="https://github.com/bbqsrc/cargo-ndk">cargo-ndk</a> is a Cargo plugin for compiling code suitable for plugging into
the JNI without additional configuration. Run the above command to install.
Version 2.7.0 of cargo-ndk introduced changes that breaked support for NDK
version 22 so 2.6.0 must be used for now.</p>
<h2 id="alternative-ndk-setup"><a class="header" href="#alternative-ndk-setup">Alternative NDK setup</a></h2>
<p>You can alternatively use the latest version of the Android NDK which is greater than 22.
However, this requires a hack to prevent the <a href="https://github.com/bbqsrc/cargo-ndk/issues/22">unable to find library -lgcc error</a>.</p>
<h3 id="android-ndk-1"><a class="header" href="#android-ndk-1">Android NDK</a></h3>
<p>Install the latest NDK:</p>
<blockquote>
<p>Android Studio &gt; SDK Manager &gt; SDK Tools &gt; NDK (Side by side)</p>
</blockquote>
<p>Click on OK at the bottom right corner to start the installation.</p>
<h3 id="cargo-ndk-1"><a class="header" href="#cargo-ndk-1"><a href="https://github.com/bbqsrc/cargo-ndk">cargo-ndk</a></a></h3>
<p>You should install <code>cargo-ndk</code> version 2.7.0 or above which works for
Android NDK versions greater than 22.</p>
<pre><code>cargo install cargo-ndk --version ^2.7.0
</code></pre>
<p>A workaround may be under development in the cargo-ndk project. Until it is finished,
you need to manually create four text files to redirect calls from libgcc to libunwind (<a href="https://github.com/rust-lang/rust/pull/85806#issuecomment-1096266946">reference</a>):</p>
<ol>
<li>
<p>Find out all the 4 folders containing file <code>libunwind.a</code>.</p>
<ul>
<li>
<p>On Windows, it is similar to:</p>
<pre><code>C:\Users\Administrator\AppData\Local\Android\Sdk\ndk\24.0.8215888\toolchains\llvm\prebuilt\windows-x86_64\lib64\clang\14.0.1\lib\linux\x86_64\
</code></pre>
</li>
<li>
<p>On macOS Monterey, it is similar to:</p>
<pre><code>~/Library/Android/sdk/ndk/24.0.8215888/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/14.0.1/lib/linux/x86_64/
</code></pre>
</li>
</ul>
<p>The three other folders end with <code>aarch64</code>, <code>arm</code>,    <code>i386</code> instead of <code>x86_64</code>.</p>
</li>
<li>
<p>Create 4 text files named <code>libgcc.a</code> in the four folders mentioned above with this contents</p>
<pre><code>INPUT(-lunwind)
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios-setup"><a class="header" href="#ios-setup">iOS setup</a></h1>
<p>iOS requires some additional Rust targets for cross-compilation:</p>
<pre><code class="language-bash"># 64 bit targets (real device &amp; simulator):
rustup target add aarch64-apple-ios x86_64-apple-ios
# New simulator target for Xcode 12 and later
rustup target add aarch64-apple-ios-sim
# 32 bit targets (you probably don't need these):
rustup target add armv7-apple-ios i386-apple-ios
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-setup"><a class="header" href="#web-setup">Web setup</a></h1>
<p>Building on web requires nightly Rust, the <code>wasm32-unknown-unknown</code> target
and <a href="https://rustwasm.github.io/wasm-pack/">wasm-pack</a>, which can be installed using these commands:</p>
<pre><code class="language-bash">rustup toolchain install nightly
rustup +nightly component add rust-src
rustup +nightly target add wasm32-unknown-unknown
# either of these
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
cargo install wasm-pack
</code></pre>
<p>Optionally (but highly recommended), install <code>flutter_rust_bridge_serve</code>
to expedite the process of building the WASM binary and setting up HTTP headers:</p>
<pre><code class="language-bash"># in your Flutter/Dart package
flutter pub add flutter_rust_bridge
# then run this instead of &quot;flutter web -d chrome&quot;
dart run flutter_rust_bridge:serve
# or install globally
dart pub global activate flutter_rust_bridge
flutter_rust_bridge_serve
</code></pre>
<h2 id="limitations-of-wasm"><a class="header" href="#limitations-of-wasm">Limitations of WASM</a></h2>
<p>Running code on the Web entails several restrictions on the kinds of code that
can be executed. Please refer to <a href="template/../wasm_limitations.html">Limitations of WASM</a>
to see if your code is compatiable with WASM.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-and-linux"><a class="header" href="#windows-and-linux">Windows and Linux</a></h1>
<p>Windows and Linux share the same build system (CMake), making setup for these two
platforms the easiest even from scratch. The template uses <a href="https://github.com/corrosion-rs/corrosion">Corrosion</a> to expedite the process, which has to clone and initialize the builder first. If you are running builds continuously, it might be a good idea to follow <a href="https://github.com/corrosion-rs/corrosion#installation">this guide</a> to learn how to install <a href="https://github.com/corrosion-rs/corrosion">Corrosion</a> permanently onto your system. Once that's done, go ahead and modify <code>rust.cmake</code> in <code>windows</code> and <code>linux</code>:</p>
<pre><code class="language-diff">-# find_package(Corrosion REQUIRED)
+find_package(Corrosion REQUIRED)

-include(FetchContent)
-
-FetchContent_Declare(
-    Corrosion
-    GIT_REPOSITORY https://github.com/AndrewGaspar/corrosion.git
-    GIT_TAG origin/master # Optionally specify a version tag or branch here
-)
-
-FetchContent_MakeAvailable(Corrosion)
</code></pre>
<h2 id="troubleshooting-cmake-on-linux"><a class="header" href="#troubleshooting-cmake-on-linux">Troubleshooting: CMake on Linux</a></h2>
<p>The minimum version of CMake required to use <a href="https://github.com/corrosion-rs/corrosion">Corrosion</a> is 3.12, which is not the version set
by default in <code>CMakeLists.txt</code>. You will need to modify this line in <code>linux/CMakeLists.txt</code>:</p>
<pre><code class="language-diff">-cmake_minimum_required(VERSION 3.10)
+cmake_minimum_required(VERSION 3.12)
</code></pre>
<p>However, this has a separate issue of disallowing Flutter SDK installations via Snap to build,
as these are bundled with a non-upgradeable CMake 3.10. If possible, it is recommended to install
Flutter manually using the command line. This issue may be resolved once
<a href="https://github.com/canonical/flutter-snap/pull/61">canonical/flutter-snap#61</a> lands.</p>
<p>A workaround is to ignore <code>rust.cmake</code> and manually configure CMake to build and bundle the Rust library, as suggested by
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/318#issuecomment-1038751426">this comment</a>
in the case of Flutter on ARM Linux.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-platforms"><a class="header" href="#other-platforms">Other platforms</a></h1>
<p>For all remaining platforms, there are no required setup steps to take, apart from those listed in <a href="https://docs.flutter.dev/desktop">Desktop support for Flutter</a>. If you need to check your progress, run <code>flutter doctor -v</code> and it will display the status of your toolchain and any actionable steps. The rest of this page
documents additional hints for each of the platforms that might be useful for newcomers to
Flutter and/or Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-tour"><a class="header" href="#template-tour">Template tour</a></h1>
<p><img src="template/success.png" alt="success-screen" /></p>
<p>Congratulations! üéâ You should have a working Flutter app equipped with
a Rust runtime component. This section is meant to be a gentle introduction to the details of Rust integration with the existing Flutter toolchain. Feel free to skip forward to <a href="template/generate.html">Generating code</a> to learn how to write new code, or visit
<a href="template/../integrate.html">Integrating with existing projects</a> to add Rust to your preexisting Flutter project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nativesrcapirs"><a class="header" href="#nativesrcapirs"><code>native/src/api.rs</code></a></h1>
<p>This is the default entry point for your library. Only functions defined here will be eligible for codegen.
Functions may use types not defined in this file as parameter or return types, but those types must have
been imported through <code>pub use</code> so that they are visible from <code>native/src/bridge_generated.rs</code>.</p>
<p>Only types defined within the current crate are eligible for codegen.
Furthermore, structs and enums may only comprise of types that are themselves eligible.</p>
<p>To review the subset of currently eligible functions and types, see <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/pure_dart/rust/src/api.rs">the example file here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="androidappbuildgradle"><a class="header" href="#androidappbuildgradle"><code>android/app/build.gradle</code></a></h1>
<p>This file is part of the default Flutter build process for Android apps.
The template injects additional hooks to run <a href="https://lib.rs/crates/cargo-ndk"><code>cargo-ndk</code></a>
upon invoking <code>flutter run</code>. This method is explained more in detail in
<a href="template/../integrate/android_tasks.html">Hooking onto tasks</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nativenativexcodeproj"><a class="header" href="#nativenativexcodeproj"><code>native/native.xcodeproj</code></a></h1>
<p>This is the Xcode project folder for the Rust native library generated by <a href="https://lib.rs/crates/cargo-xcode"><code>cargo-xcode</code></a>.
The iOS and MacOS root projects import this folder as a <em>subproject</em> and depends on it during
build-time.</p>
<p>It is important that the suitable <code>crate-type</code>s are configured for your target devices.
Make sure these lines exist in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;lib&quot;, &quot;cdylib&quot;, &quot;staticlib&quot;]
</code></pre>
<p>where</p>
<ul>
<li><code>lib</code> is required for non-library targets, such as tests and benchmarks</li>
<li><code>staticlib</code> is required for iOS</li>
<li><code>cdylib</code> for all other platforms</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="justfile"><a class="header" href="#justfile"><code>justfile</code></a></h1>
<p>This file defines the recipes for the <a href="https://github.com/casey/just">just</a> command runner, in a similar vein to <code>make</code> and Makefile. <a href="https://github.com/casey/just">just</a> is built using Rust and improves upon the traditional Makefile syntax with better support for
conditionals, arguments, cross-platform compatibility and more.</p>
<p>One non-trivial feature of <a href="https://github.com/casey/just">just</a> utilized by this template is the
conditional LLVM flag for MacOS. On certain setups, a <code>brew install llvm</code> does not make the LLVM libraries visible to other executables, which causes problems for <code>ffigen</code>, a C-to-Dart codegen that <code>flutter_rust_bridge_codegen</code> uses under the hood.</p>
<p>Running <code>just</code> by default runs the <code>gen</code> and <code>lint</code> tasks.</p>
<h2 id="just-gen"><a class="header" href="#just-gen"><code>just gen</code></a></h2>
<p>Generates the Rust bindings and puts them into the correct folders.
The <a href="template/generate.html">Generating new code</a> section goes into detail how to modify
this task to perform side jobs as well.</p>
<h2 id="just-lint"><a class="header" href="#just-lint"><code>just lint</code></a></h2>
<p>Runs the default linters for Dart and Rust.</p>
<h2 id="just-clean"><a class="header" href="#just-clean"><code>just clean</code></a></h2>
<p>Runs the default clean commands for Flutter and Rust.
Useful when you want to debug build-related issues.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustcmake"><a class="header" href="#rustcmake"><code>rust.cmake</code></a></h1>
<p>In <code>windows</code> and <code>linux</code> are two identical files named <code>rust.cmake</code>.
These files are included in the existing <code>CMakeLists.txt</code> that Flutter uses
to compile its applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-code"><a class="header" href="#generating-code">Generating code</a></h1>
<p>This section assumes you followed the instructions in <a href="template/template.html">Creating a new project</a>, and has successfully <code>flutter run</code> on your target device.</p>
<p>Up until now, all the code necessary for executing the program has been supplied for you, so there was no need to install anything. We will now look at how to create new Rust code, generate the necessary glue code and use them in Dart.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-codegen"><a class="header" href="#installing-codegen">Installing codegen</a></h1>
<p>More informations in the <a href="template/../integrate/deps.html">Installing dependencies</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-new-code"><a class="header" href="#adding-new-code">Adding new code</a></h1>
<p>Let's say we need to change <code>Platform</code> such that we don't really care about whether it
is running on Intel or Apple Silicon, but we would like to keep this information so
downlevel code can act on it. We would like to merge <code>MacApple</code> and <code>MacIntel</code> into a
single <code>MacOs(String)</code> that contains the current CPU architecture. Go ahead and update
<code>native/src/api.rs</code>:</p>
<pre><code class="language-diff"> pub enum Platform {
     ..
-    MacIntel,
-    MacApple,
+    MacOs(String),
     ..
 }
</code></pre>
<p>Now run <code>just</code> and see that your binding code now has changed.</p>
<h2 id="troubleshooting-please-supply-one-or-more-pathtollvm"><a class="header" href="#troubleshooting-please-supply-one-or-more-pathtollvm">Troubleshooting: &quot;Please supply one or more path/to/llvm...&quot;</a></h2>
<p>A common issue with <code>ffigen</code> is that its detection of the LLVM installation is not reliable
across platforms. Especially for MacOS and the split between x86-64 and arm64 binaries,
you might have to modify <code>justfile</code> to explicitly point to its location:</p>
<pre><code>llvm_path := if os() == &quot;macos&quot; {
    &quot;--llvm-path /opt/homebrew/opt/llvm&quot;
} else {
    &quot;&quot;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-build_runner"><a class="header" href="#using-build_runner">Using <code>build_runner</code></a></h1>
<p>Inspect your <code>lib/bridge_generated.dart</code> and you will see that the definition of <code>Platform</code> has changed:</p>
<pre><code class="language-dart">@freezed
class Platform with _$Platform {
    const factory Platform.unknown() = Unknown;
    const factory Platform.android() = Android;
    const factory Platforn.ios() = Ios;
    const factory Platform.windows() = Windows;
    const factory Platform.unix() = Unix;
    const factory Platform.macOs(
        String field0,
    ) = MacOs;
    const factory Platform.wasm() = Wasm;
}
</code></pre>
<p>It is no longer a plain enum, but a full-blown enum class with variants! As it is right now, this code
cannot compile yet since it is missing some components, namely the <a href="https://pub.dev/packages/freezed"><code>freezed</code></a> library. <a href="https://pub.dev/packages/freezed"><code>freezed</code></a> is a
codegen library similar to those we've encountered thus far, but generates more Dart code instead.
All such libraries perform their code generation upon invoking <code>build_runner</code>, i.e. when <code>flutter pub run build_runner build</code> is executed.</p>
<p>Regardless, to make this code compile again, we need to make a few changes:</p>
<ul>
<li>Run the following commands to add the latest version of <a href="https://pub.dev/packages/freezed"><code>freezed</code></a>:</li>
</ul>
<pre><code class="language-shell">flutter pub add -d build_runner
flutter pub add -d freezed
flutter pub add freezed_annotation
</code></pre>
<ul>
<li>Update <code>justfile</code> to run <code>build_runner</code> after Rust codegen:</li>
</ul>
<pre><code class="language-diff"> gen:
     ..
     # Uncomment this line to invoke build_runner as well
-    # flutter pub run build_runner build
+    flutter pub run build_runner build
</code></pre>
<p>Now calling <code>just</code> will generate both the Rust bindings <em>and</em> the Dart library code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping up</a></h1>
<p>With our new definition of <code>Platform</code> in place, we can rewrite the previous code to make use
of it! Here is an example of what you can do with freezed enums.</p>
<p>In <code>lib/main.dart</code>:</p>
<pre><code class="language-diff">- final text = const {
-   Platform.Android: 'Android',
-   Platform.Ios: 'iOS',
-   Platform.MacApple: 'MacOS with Apple Silicon',
-   Platform.MacIntel: 'MacOS',
-   Platform.Windows: 'Windows',
-   Platform.Unix: 'Unix',
-   Platform.Wasm: 'the Web',
- }[platform] ??
- 'Unknown OS';
+ final text = platform.when(
+   android: () =&gt; 'Android',
+   ios: () =&gt; 'iOS',
+   macOs: (arch) =&gt; 'MacOS on $arch',
+   windows: () =&gt; 'Windows',
+   unix: () =&gt; 'Unix',
+   wasm: () =&gt; 'the Web',
+ );
</code></pre>
<p>In <code>native/src/api.rs</code>:</p>
<pre><code class="language-diff">     } else if cfg!(target_os = &quot;ios&quot;) {
         Platform::Ios
     } else if cfg!(all(target_os = &quot;macos&quot;, target_arch = &quot;aarch64&quot;)) {
-        Platform::MacApple
+        Platform::MacOs(&quot;Apple Silicon&quot;.into())
     } else if cfg!(target_os = &quot;macos&quot;) {
-        Platform::MacIntel
+        Platform::MacOs(&quot;Intel&quot;.into())
     } else if cfg!(target_family = &quot;wasm&quot;) {
         Platform::Wasm
     } else if cfg!(unix) {
</code></pre>
<p>When you <code>flutter run</code>, you should get something like this:
<img src="template/macos_intel.png" alt="macos-intel" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-existing-projects"><a class="header" href="#integrating-with-existing-projects">Integrating with existing projects</a></h1>
<p>This guide is an intermediate-level introduction to integrating Rust with
an existing Flutter project. If you are new to Rust or configuring
build processes in general, we suggest looking at <a href="template/tour.html">the template tour</a>
to learn about the moving parts behind a <code>flutter run</code>.</p>
<p>Before following this guide, upgrade your Flutter SDK, and if possible
refresh your native build folders (<code>android</code>, <code>ios</code>, etc.) to make the process
as straightforward as possible.</p>
<p><strong>Remark:</strong> Most complexity does <em>not</em> come from this library, <code>flutter_rust_bridge</code> - it is as same complex as using raw Dart/Flutter FFI with Rust. In other words, it is the Dart/Flutter + Rust toolchain that takes time to set up.</p>
<h2 id="using-the-flutter_rust_bridge-brick"><a class="header" href="#using-the-flutter_rust_bridge-brick">Using the <code>flutter_rust_bridge</code> brick</a></h2>
<p>The following sections cover how to set up Rust support from scratch for completeness' sake,
however for your convenience you can also use the <a href="https://brickhub.dev/bricks/flutter_rust_bridge/"><code>fluttter_rust_bridge</code> brick</a>
to scaffold most of<sup class="footnote-reference"><a href="#1">1</a></sup> the code written here.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Some setup steps are still required even with the brick, which we will go into more detail in the later sections.
The brick is a work-in-progress.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-new-crate"><a class="header" href="#creating-a-new-crate">Creating a new crate</a></h1>
<p>First, if you haven't done so already, create a new crate within your project directory
using <code>cargo new --lib</code>. It is recommended that the crate root is a sibling of the other native build
folders for ease of config, e.g.:</p>
<pre><code>‚îú‚îÄ‚îÄ android
‚îú‚îÄ‚îÄ ios
‚îú‚îÄ‚îÄ lib
‚îú‚îÄ‚îÄ linux
‚îú‚îÄ‚îÄ macos
‚îú‚îÄ‚îÄ $crate
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ src
‚îú‚îÄ‚îÄ test
‚îú‚îÄ‚îÄ web
‚îî‚îÄ‚îÄ windows
</code></pre>
<p>Throughout this section we will refer to your crate name as $crate. Unless otherwise noted, the crate folder
and the crate name will be used interchangeably.</p>
<p>Next, add these two lines to your <code>Cargo.toml</code>:</p>
<pre><code class="language-diff">+[lib]
+crate-type = [&quot;staticlib&quot;, &quot;cdylib&quot;]
</code></pre>
<p>This configures your crate to be output as a static library for MacOS and iOS,
and a dynamic library on other platforms. Configure this to your needs.
If you would like to write tests or benchmarks, append <code>&quot;rlib&quot;</code> to the list
as well.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-dependencies"><a class="header" href="#installing-dependencies">Installing dependencies</a></h1>
<p>Next, we need to install a few build-time and runtime dependencies.</p>
<h2 id="build-time-dependencies"><a class="header" href="#build-time-dependencies">Build-time dependencies</a></h2>
<p>These depdencies are required only in build-time:</p>
<ul>
<li><a href="https://lib.rs/crates/flutter_rust_bridge_codegen"><code>flutter_rust_bridge_codegen</code></a>, the core codegen for Rust-Dart glue code</li>
<li><a href="https://pub.dev/packages/ffigen"><code>ffigen</code></a>, to generate Dart code from C headers</li>
<li>A working installation of LLVM, see <a href="https://pub.dev/packages/ffigen#installing-llvm">Installing LLVM</a>, used by <code>ffigen</code></li>
<li>(Optional) <a href="https://lib.rs/crates/cargo-xcode"><code>cargo-xcode</code></a>, if you want to generate Xcode projects for iOS and MacOS</li>
</ul>
<p>An easy way to install most of these dependencies is to run:</p>
<ul>
<li>
<p>dart project</p>
<pre><code class="language-bash">cargo install flutter_rust_bridge_codegen
dart pub add --dev ffigen &amp;&amp; dart pub add ffi
# if building for iOS or MacOS
cargo install cargo-xcode
</code></pre>
</li>
<li>
<p>flutter project</p>
<pre><code class="language-bash">cargo install flutter_rust_bridge_codegen
flutter pub add --dev ffigen &amp;&amp; flutter pub add ffi
# if building for iOS or MacOS
cargo install cargo-xcode
</code></pre>
</li>
</ul>
<p>Alternatively, each of these dependencies may provide prebuilt binaries. Check with
your package manager and review them individually.</p>
<h2 id="dart-dependencies"><a class="header" href="#dart-dependencies">Dart dependencies</a></h2>
<p>On the Dart side, <code>flutter_rust_bridge</code> is the required runtime component of
<code>flutter_rust_bridge_codegen</code>. If you plan to use enum structs in Rust, the
following dependencies are also needed:</p>
<ul>
<li><code>build_runner</code> (dev)</li>
<li><code>freezed</code> (dev)</li>
<li><code>freezed_annotation</code></li>
</ul>
<p>Their usage is explained in <a href="integrate/../generate/build_runner.html">Using <code>build_runner</code></a>.</p>
<pre><code class="language-bash">flutter pub add flutter_rust_bridge
# if using Dart codegen
flutter pub add -d build_runner
flutter pub add -d freezed
flutter pub add freezed_annotation
</code></pre>
<h2 id="rust-dependencies"><a class="header" href="#rust-dependencies">Rust dependencies</a></h2>
<p>Similar to Dart, Rust requires the <code>flutter_rust_bridge</code> runtime component for support.</p>
<p>Add these lines to <code>Cargo.toml</code>:</p>
<pre><code class="language-diff">+[dependencies]
+flutter_rust_bridge = &quot;1&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-android"><a class="header" href="#integrating-with-android">Integrating with Android</a></h1>
<p>The setup process is identical to <a href="integrate/../template/setup_android.html">Android setup</a>,
so go ahead and follow the steps described there. Once you're done, we will discuss
how to modify the existing toolchain to accommodate Rust.</p>
<p>There is more than one way to set up Cargo to run alongside Gradle, so this guide
will cover the two main ones: hooking onto tasks, and integrating with CMake.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooking-onto-tasks"><a class="header" href="#hooking-onto-tasks">Hooking onto tasks</a></h1>
<p>This is the same method used by the app template and also the easier one.
Go ahead and install <code>cargo-ndk</code> if you have not already done so:</p>
<pre><code>cargo install cargo-ndk
</code></pre>
<p>Next, add these lines<sup class="footnote-reference"><a href="#1">1</a></sup> near the bottom of <code>android/app/build.gradle</code>:</p>
<pre><code class="language-gradle">[
    new Tuple2('Debug', ''),
    new Tuple2('Profile', '--release'),
    new Tuple2('Release', '--release')
].each {
    def taskPostfix = it.first
    def profileMode = it.second
    tasks.whenTaskAdded { task -&gt;
        if (task.name == &quot;javaPreCompile$taskPostfix&quot;) {
            task.dependsOn &quot;cargoBuild$taskPostfix&quot;
        }
    }
    tasks.register(&quot;cargoBuild$taskPostfix&quot;, Exec) {
        // Until https://github.com/bbqsrc/cargo-ndk/pull/13 is merged,
        // this workaround is necessary.

        def ndk_command = &quot;&quot;&quot;cargo ndk \
            -t armeabi-v7a -t arm64-v8a -t x86_64 -t x86 \
            -o ../android/app/src/main/jniLibs build $profileMode&quot;&quot;&quot;

        workingDir &quot;../../$crate&quot;
        environment &quot;ANDROID_NDK_HOME&quot;, &quot;$ANDROID_NDK&quot;
        if (org.gradle.nativeplatform.platform.internal.DefaultNativePlatform.currentOperatingSystem.isWindows()) {
            commandLine 'cmd', '/C', ndk_command
        } else {
            commandLine 'sh', '-c', ndk_command
        }
    }
}
</code></pre>
<p>Note the ANDROID_NDK variable, this is a Gradle property that points to
your installation of the Android NDK. If you don't rely on portability,
you can hardcode this value, but note that it can be supplied by one
of the many <code>gradle.properties</code> scattered throughout your filesystem.
The most reliable way is to create a file at <code>~/.gradle/gradle.properties</code>
and fill it with this:</p>
<pre><code>ANDROID_NDK=(path to NDK)
</code></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<pre><code>This excerpt might be outdated, please check out
the source file at the template repository.
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmake-with-gradle"><a class="header" href="#cmake-with-gradle">CMake with Gradle</a></h1>
<p>If you have taken a look at either the <code>windows</code> or <code>linux</code> folder,
you will see a file named <code>CMakeLists.txt</code>. This is the definition file
for the CMake toolchain that Flutter uses to build Windows and Linux apps.
You can also use this strategy on Gradle, but this setup is beyond the scope
of this guide and reserved for advanced tinkers.</p>
<p>Refer to the <a href="https://developer.android.com/studio/projects/add-native-code">Add C and C++ code to your project</a>
page on the official Android docs, modify around C-specific parts and use a
tool like <a href="https://github.com/corrosion-rs/corrosion"><code>Corrosion</code></a> to integrate
with Cargo. The advantage of this setup is that you can reuse your C tools
<em>and</em> benefit from various techniques such as caching builds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-iosmacos"><a class="header" href="#integrating-with-iosmacos">Integrating with iOS/MacOS</a></h1>
<p><em>Credit to <a href="https://github.com/brotskydotcom/rust-on-ios">brotskydotcom/rust-on-ios</a>
for the inspiration of this method.</em></p>
<p>Setting up <code>flutter run</code> for iOS and MacOS is slightly more complicated than other platforms,
due to its reliance on the Xcode user interface. This guide assumes you are running
a relatively recent version of Xcode, which at the time of writing is Xcode 13.
Other versions might have minor variances but the overall process should be the same.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-rust-project"><a class="header" href="#creating-the-rust-project">Creating the Rust project</a></h1>
<p>First, follow the instructions on the <a href="https://gitlab.com/kornelski/cargo-xcode#usage">Usage</a>
section of <code>cargo-xcode</code>. The instructions that follow are quoted from there, but keep in mind
that it might have become outdated.</p>
<hr />
<p>Ensure that these lines are present in your <code>$crate/Cargo.toml</code>:</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;lib&quot;, &quot;staticlib&quot;, &quot;cdylib&quot;]
</code></pre>
<p>where</p>
<ul>
<li><code>lib</code> is required for non-library targets, such as tests and benchmarks</li>
<li><code>staticlib</code> is required for iOS</li>
<li><code>cdylib</code> for all other platforms</li>
</ul>
<p>Configure this to suit your needs. Then run this command in <code>$crate</code>:</p>
<pre><code class="language-bash">cargo xcode
</code></pre>
<p>This will generate a <code>$crate/$crate.xcodeproj</code> that can be imported into other Xcode projects.
You only have to do this once per crate.
Don't open the project yet; we need to configure it through the parent projects first.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linking-the-project"><a class="header" href="#linking-the-project">Linking the project</a></h1>
<p>Open <code>ios/Runner.xcodeproj</code> in Xcode, then add <code>$crate/$crate.xcodeproj</code> as a <em>subproject</em>
of the Runner project. It should look like this:</p>
<p><img src="integrate/ios_proj_tree.png" alt="proj-tree" /></p>
<p>Click on the <code>Runner</code> root project, then go to the <strong>Build Phases</strong> tab.
First, expand the <strong>Dependencies</strong> phase, and add <strong>$crate-staticlib</strong>
for iOS, or <strong>$crate-cdylib</strong> for MacOS.</p>
<p><img src="integrate/ios_dep_phase.png" alt="dep-phase" /></p>
<p>Then, expand the <strong>Link Binary With Libraries</strong> phase, and add <strong>lib$crate_static.a</strong>
for iOS, or <strong>$crate.dylib</strong> for MacOS.</p>
<p><img src="integrate/ios_link_phase.png" alt="link-phase" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-bindings"><a class="header" href="#generating-bindings">Generating bindings</a></h1>
<p>Now that we've got most of the plumbing out of the way, let's compile our Rust
application. If you just created your crate a few moments ago, go ahead and
add a new file at <code>$crate/src/api.rs</code> and replace its contents with this snippet or
whatever suits your fancy:</p>
<pre><code class="language-rust ignore">pub fn greet() -&gt; String {
    &quot;Hello from Rust! ü¶Ä&quot;.into()
}
</code></pre>
<p>then in <code>$crate/src/lib.rs</code>:</p>
<pre><code class="language-diff">+mod api;
</code></pre>
<h2 id="running-the-codegen"><a class="header" href="#running-the-codegen">Running the codegen</a></h2>
<p>Before we can compile the library, we need to generate the bindings first.
From the root of the app, run these commands:</p>
<pre><code class="language-bash">flutter_rust_bridge_codegen \
    -r $crate/src/api.rs \
    -d lib/bridge_generated.dart \
    -c ios/Runner/bridge_generated.h \
    -c macos/Runner/bridge_generated.h   # if building for MacOS
</code></pre>
<blockquote>
<p><strong>Note:</strong> These will be the same commands to use whenever you modify your Rust library code.</p>
</blockquote>
<p>Running this command yields the C header of the functions and types exported
by the Rust library, which we will need to keep the symbols from being stripped.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-dummy-headers"><a class="header" href="#using-dummy-headers">Using dummy headers</a></h1>
<p><code>flutter_rust_bridge_codegen</code> created a C header which lists all the
exported symbols from our library, then uses it so that Xcode won't strip
the symbols.</p>
<p>Add <code>ios/Runner/bridge_generated.h</code> (or <code>macos/Runner/bridge_generated.h</code>)
to the project, either by dragging it onto the project tree or
via the <strong>Add Files to &quot;Runner&quot;...</strong> menu option.</p>
<p>Switch to the <strong>Build Phases</strong> tab and drag the <strong>bridge_generated.h</strong> file over
to the <strong>Copy Bundle Resources</strong> phase, if it isn't already present.</p>
<h2 id="ios"><a class="header" href="#ios">iOS</a></h2>
<p>Next, add this line to <code>ios/Runner/Runner-Bridging-Header.h</code>:</p>
<pre><code class="language-diff">+#import &quot;bridge_generated.h&quot;
</code></pre>
<p>and in <code>ios/Runner/AppDelegate.swift</code>:</p>
<pre><code class="language-diff"> override func application(
     _ application: UIApplication,
     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
 ) -&gt; Bool {
+    let dummy = dummy_method_to_enforce_bundling()
+    print(dummy)
     ..
 }
</code></pre>
<p>It is important that you use the result of <code>dummy_method_to_enforce_bundling()</code> (like in the example above), otherwise the symbols might still get stripped.</p>
<h2 id="macos"><a class="header" href="#macos">MacOS</a></h2>
<p>Flutter on MacOS does not use headers by default, so let's go ahead
and add one ourselves. In the <strong>Build Settings</strong> tab, set the
<strong>Objective-C Bridging Header</strong> to be <strong>Runner/bridge_generated.h</strong>.</p>
<p>Finally, use <code>dummy_method_to_enforce_bundling</code> somewhere within
<code>macos/Runner/AppDelegate.swift</code>, as long as Xcode does not consider it dead code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-windows-and-linux"><a class="header" href="#integrating-with-windows-and-linux">Integrating with Windows and Linux</a></h1>
<p>This guide groups together instructions for Windows and Linux desktop apps,
as they use the same build system.</p>
<p>The idea is the same as other platforms: we hook onto the existing projects
using scripts, and we will also be borrowing from the template. Go ahead
and download <a href="https://raw.githubusercontent.com/Desdaemon/flutter_rust_bridge_template/main/windows/rust.cmake">rust.cmake</a>
into your <code>windows</code> and <code>linux</code> folders. Keep in mind that CMake will refuse
to use files that lie outside of its working directory, so there will be duplications
between the two build folders.</p>
<p>Next, add this line to your <code>CMakeLists.txt</code> files:</p>
<pre><code class="language-diff"> # Generated plugin build rules, which manage building the plugins and adding
 # them to the application.
 include(flutter/generated_plugins.cmake)

+include(./rust.cmake)

 # === Installation ===
 # Support files are copied into place next to the executable, so that it can
</code></pre>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<p>On Linux, you will need to bump the minimum CMake version to 3.12 to make use
of <a href="https://github.com/corrosion-rs/corrosion">Corrosion</a>, which is used by <code>rust.cmake</code>. Change this line in <code>linux/CMakeLists.txt</code>:</p>
<pre><code class="language-diff">-cmake_minimum_required(VERSION 3.10)
+cmake_minimum_required(VERSION 3.12)
</code></pre>
<p>Alternatively, you can install Corrosion permanently on your system.
Refer to the <a href="integrate/../template/setup_desktop.html">Linux troubleshooting notes</a> here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-web"><a class="header" href="#integrating-with-web">Integrating with Web</a></h1>
<p>Refer to the <a href="integrate/../template/setup_web.html">Web setup</a> page for required installables.</p>
<p>Once you have installed the required dependencies, you will need to create a wrapper
to consume the bridge files. In the case of <code>DynamicLibrary</code>
you only needed to supply the path to the binary,
but to import a WASM module you need to:</p>
<ul>
<li>Create a script tag to the JS file generated by <code>wasm_bindgen</code> and insert it into the document;</li>
<li>Invoke the <code>wasmModule</code> initializer defined in the
web bridge;</li>
<li>And finally, create the implementation class.</li>
</ul>
<p>Create a Dart file and copy these lines to it:</p>
<pre><code class="language-dart">import 'bridge_generated.web.dart';
export 'bridge_definitions.dart';

import 'dart:html';

// Path to the wasm_bindgen generated files
const root = 'pkg/native';
final api = NativeImpl.wasm(WasmModule.initialize(
    kind: const Modules.noModules(root: root),
));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-dynamic-library"><a class="header" href="#using-the-dynamic-library">Using the dynamic library</a></h1>
<p>If everything went well, running <code>flutter run</code> will now build your Rust library,
the Flutter binary and link the two together. Now the only thing left to do is
to actually use it!</p>
<p>Download <a href="https://raw.githubusercontent.com/Desdaemon/flutter_rust_bridge_template/main/lib/ffi.dart">this file</a>
to <code>lib/ffi.dart</code>, then modify its contents:</p>
<pre><code class="language-diff"> // Re-export the bridge so it is only necessary to import this file.
 export 'bridge_generated.dart';
 import 'dart:io' as io;

-const _base = 'native';
+const _base = '$crate';

 // On MacOS, the dynamic library is not bundled with the binary,
 // but rather directly **linked** against the binary.
 final _dylib = io.Platform.isWindows ? '$_base.dll' : 'lib$_base.so';
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-up-1"><a class="header" href="#wrapping-up-1">Wrapping up</a></h1>
<p>Congratulations! You have successfully added a Rust component to
your Flutter app using <code>flutter_rust_bridge</code> and configured
<code>flutter run</code> (more on web later) to build your Rust library and link it to the app.</p>
<p>As a reminder, you need to run these commands every time your Rust code changes <em>and</em>
before you run <code>flutter run</code>:</p>
<pre><code class="language-bash">flutter_rust_bridge_codegen \
    -r $crate/src/api.rs \
    -d lib/bridge_generated.dart \
    -c ios/Runner/bridge_generated.h \
    -c macos/Runner/bridge_generated.h   # if building for MacOS
</code></pre>
<h2 id="renaming-the-rust-bridge-module"><a class="header" href="#renaming-the-rust-bridge-module">Renaming the Rust bridge module</a></h2>
<p>If you would like to use the <code>--rust-output</code> flag of <code>flutter_rust_bridge_codegen</code>,
keep in mind that you will have to update <code>$crate/src/lib.rs</code> to point to the correct
file, for example if you use this command instead:</p>
<pre><code class="language-bash">flutter_rust_bridge_codegen \
    ..
    --rust-output $crate/src/my_bridge.rs
</code></pre>
<p>then you need to modify this in <code>lib.rs</code>:</p>
<pre><code class="language-diff">- mod bridge_generated;
+ mod my_bridge;
</code></pre>
<h2 id="flutter_rust_bridge_serve-less-workflows"><a class="header" href="#flutter_rust_bridge_serve-less-workflows"><code>flutter_rust_bridge_serve</code>-less workflows</a></h2>
<p>If you don't need to run Flutter Web in development
mode and would rather build in release mode once
in a while, <a href="integrate/../build_wasm.html">read here</a> for instructions on how to build your WASM
binary without <code>flutter_rust_bridge_serve</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<h2 id="prelude"><a class="header" href="#prelude">Prelude</a></h2>
<p>Firstly, welcome, and thanks for your contributions!</p>
<p>If you want to contribute, feel free to create a <a href="https://github.com/fzyzcjy/flutter_rust_bridge/pulls">Pull Request</a>. If you need some ideas of what to contribute, have a look at the <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues">Issues section</a> of this repository.</p>
<p>For a checklist, have a look at the <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/PULL_REQUEST_TEMPLATE.md">PR template</a>.</p>
<h2 id="overall-design"><a class="header" href="#overall-design">Overall design</a></h2>
<p>To get a high-level idea how this library is implemented, here is the overall design: <a href="contributing/design.html">link</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overall-design-1"><a class="header" href="#overall-design-1">Overall design</a></h1>
<blockquote>
<p>This doc is still WIP. Tracking issue: https://github.com/fzyzcjy/flutter_rust_bridge/issues/593</p>
</blockquote>
<h2 id="folder-structure"><a class="header" href="#folder-structure">Folder structure</a></h2>
<ul>
<li><code>frb_codegen</code>: Code generator. It inputs <code>api.rs</code> and outputs Rust and Dart code files.</li>
<li><code>frb_example</code>: Examples.
<ul>
<li><code>pure_dart</code>: Not only an example, but, more importantly, serves as end-to-end tests.</li>
<li><code>with_flutter</code>: Example with integration into Flutter.</li>
<li><code>pure_dart_multi</code>: Demonstrate multi-file usage.</li>
</ul>
</li>
<li><code>frb_dart</code>: Support library for Dart - to be imported by users.</li>
<li><code>frb_rust</code>: Support library for Rust - to be imported by users.</li>
<li><code>frb_macros</code>: Indeed part of <code>frb_rust</code>. <small>It is a separate package simply because limitation of proc macros.</small></li>
<li><code>book</code>: The documentation.</li>
<li><code>.github</code>: GitHub-related.
<ul>
<li><code>workflows/ci.yaml</code>: Definition of CI workflows.</li>
</ul>
</li>
</ul>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p><strong>Rust IO Wire</strong> types refers to the C types the Dart VM uses to communicate with the Rust library.</p>
<p><strong>Dart IO Wire</strong> types are the Dart counterpart of Rust IO wire types, but in
the <code>*.io.dart</code> files. Both Rust and Dart wire types communicate using the
vocabulary of C types, aka primitives, structs, unions and pointers.</p>
<p><strong>Rust JS Wire</strong> types are the WASM equivalent of Rust IO
wire types, many of which are distinct from their C siblings.
In addition, these types may also take the form of the catch-all <code>JsValue</code>.</p>
<p><strong>Dart JS Wire</strong> types are the WASM equivalent of Dart IO wire types, but
unlike Rust JS wire types, most of these types remain identical to their real API counterparts.
Similar to the the relationship between Rust IO and Dart IO wire types, Rust JS and Dart JS wire types
use the vocabulary of JavaScript types, aka primitives, arrays, typed arrays and objects.</p>
<h2 id="code-generator-structure"><a class="header" href="#code-generator-structure">Code-generator structure</a></h2>
<p>The pipeline is as follows:</p>
<pre class="mermaid">flowchart LR
api.rs -- src/parser --&gt; src/ir
src/ir -- src/generator --&gt; rd[Rust &amp; Dart]
</pre>
<ul>
<li>The input, <code>api.rs</code> in the figure, is the user-provided handwritten Rust code.</li>
<li>The parser (<code>src/parser</code>) converts the input code (indeed <a href="https://crates.io/crates/syn">syn</a> tree) into IR.</li>
<li>IR (<code>src/ir</code>), or internal representation, is a data structure that represents the information of the code that we are interested in.</li>
<li>The generator (<code>src/generator</code>) converts the IR into final outputs. More specifcially, as you can probably guess, <code>src/generator/dart</code> generates Dart code, <code>src/generator/rust</code> is for Rust code, and <code>src/generator/c</code> is for (a bit of) C code.</li>
<li>The outputs (<code>Rust &amp; Dart</code> in the figure) are written to corresponding files.</li>
</ul>
<h2 id="data-flow"><a class="header" href="#data-flow">Data flow</a></h2>
<p>Let us see what happens when a function is called.</p>
<p>Suppose a user calls a (generated) Dart function <code>func({required String str})</code>. Then, the following happens:</p>
<ol>
<li>The generated Dart function, <code>func({required String str})</code>, convert &quot;<em>Dart api data</em>&quot; (i.e. the data that user really provides) into &quot;<em>Dart wire data</em>&quot; (i.e. the data that will really pass between Dart and Rust). More specifically, it calls <code>_api2wire_String(str)</code> and get a <code>ffi.Pointer&lt;wire_uint_8_list&gt;</code> (because <code>String</code>s use <code>pub struct wire_uint_8_list { ptr: *mut u8, len: i32 }</code> under the hood).</li>
<li>Now we call the Dart version of <code>wire_func</code>, with low-level data like <code>wire_uint_8_list</code>. We have used our codegen to create a Rust <code>wire_func</code> function, and use <code>cbindgen</code> to generate the corresponding C function, and use <code>ffigen</code> to get the cooresponding Dart function. Here, we call the Dart version of <code>wire_func</code>. Since Dart FFI and Rust FFI is C-compatible, it seamlessly calls the Rust version of <code>wire_func</code>. Notice that, since we are utilizing C-compatible functions (and it is the only feasible way), we can only pass around low-level things like pointers, instead of high-level and safe things.</li>
<li>Surely, the Rust <code>wire_func</code> is called. The function uses <code>.wire2api()</code> to convert &quot;<em>Rust wire data</em>&quot; (<code>wire_uint_8_list</code> here) into &quot;<em>Rust api data</em>&quot; (<code>String</code> here, i.e. data that users really use).</li>
<li>The <code>FLUTTER_RUST_BRIDGE_HANDLER</code> is called with &quot;<em>Rust api data</em>&quot;. That handler is user-customizable, so users may provide their own implementation other than the default thread-pool, etc. By default, we use a thread pool, and we call the user-written <code>func</code> Rust function in <code>api.rs</code>.</li>
<li>The user-written <code>fn func(str: String) -&gt; String { ... }</code> is called, and we get a return value.</li>
<li>The return value, a <code>String</code>, is posted to the Dart side. It is done by the Dart-provided API, <a href="https://github.com/dart-lang/sdk/blob/fd0d3b254690007d0ebc84175f30fa7d7491ec3e/runtime/include/dart_native_api.h#L124"><code>Dart_PostCObject</code></a>, which let us provide C structs and it will automatically become Dart data on the other side. We use the Rust-safe wrapper <code>allo-isolate</code> for it. We deliberately choose this, because this enables Dart code to be <em>async</em> instead of sync.</li>
<li>On the Dart side, we now see some Dart objects (indeed &quot;<em>Dart wire data</em>&quot;). We use functions like <code>_wire2api_SomeType</code> to convert it to the final &quot;<em>Dart api data</em>&quot;. Notice this &quot;wire2api&quot; is on <em>Dart</em> side, so it means &quot;<em>Dart</em> wire data to <em>Dart</em> api data&quot;, and is different from the one above which is for Rust. For example, since <code>Dart_PostCObject</code> does not provide a way to construct arbitrary structs(classes), we have to pass Rust structs as lists, and use the <code>wire2api</code> to convert them to corresponding Dart classes.</li>
<li>The final result value is provided as return value of the Dart function, <code>func</code>, that the user called just now. A function call finishes!</li>
</ol>
<h2 id="type-mappings"><a class="header" href="#type-mappings">Type Mappings</a></h2>
<p>Unless otherwise noted, <code>T</code> refers to a type from the same column or the generic type.
Does not include delegated types.</p>
<div class="table-wrapper"><table><thead><tr><th>Rust</th><th>Rust IO Wire</th><th>Dart IO Wire</th><th>Rust JS Wire</th><th>Dart JS Wire</th><th>Dart</th></tr></thead><tbody>
<tr><td><code>i{8..32}</code></td><td><code>i{8..32}</code></td><td><code>int</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td><code>i{8..32}</code></td><td><code>int</code></td><td><code>int</code></td></tr>
<tr><td><code>u{8..32}</code></td><td><code>u{8..32}</code></td><td><code>int</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td><code>u{8..32}</code></td><td><code>int</code></td><td><code>int</code></td></tr>
<tr><td><code>i64</code></td><td><code>i64</code></td><td><code>int</code></td><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a></td><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a></td><td><code>int</code></td></tr>
<tr><td><code>u64</code></td><td><code>u64</code></td><td><code>int</code></td><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a></td><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a></td><td><code>int</code></td></tr>
<tr><td><code>usize</code></td><td><code>usize</code></td><td><code>int</code></td><td><code>usize</code></td><td><code>int</code></td><td><code>int</code></td></tr>
<tr><td><code>bool</code></td><td><code>bool</code></td><td><code>bool</code></td><td><code>bool</code></td><td><code>bool</code></td><td><code>bool</code></td></tr>
<tr><td><code>Vec&lt;i{8..32}&gt;</code></td><td><code>wire_int_{8..32}_list</code></td><td><code>wire_int_{8..32}_list</code></td><td><code>Box&lt;[i{8..32}]&gt;</code></td><td><code>Int{8..32}Array</code></td><td><code>Int{8..32}List</code></td></tr>
<tr><td><code>Vec&lt;u{8..32}&gt;</code></td><td><code>wire_uint_{8..32}_list</code></td><td><code>wire_uint_{8..32}_list</code></td><td><code>Box&lt;[u{8..32}]&gt;</code></td><td><code>Uint{8..32}Array</code></td><td><code>Uint{8..32}List</code></td></tr>
<tr><td><code>Vec&lt;i64&gt;</code></td><td><code>wire_int_64_list</code></td><td><code>wire_int_64_list</code></td><td><code>Box&lt;[i64]&gt;</code></td><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array"><code>BigInt64Array</code></a></td><td><code>Int64List</code><sup class="footnote-reference"><a href="#2">2</a></sup></td></tr>
<tr><td><code>Vec&lt;u64&gt;</code></td><td><code>wire_uint_64_list</code></td><td><code>wire_uint_64_list</code></td><td><code>Box&lt;[u64]&gt;</code></td><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array"><code>BigUint64Array</code></a></td><td><code>Uint64List</code><sup class="footnote-reference"><a href="#2">2</a></sup></td></tr>
<tr><td><code>String</code></td><td><code>wire_uint_8_list</code></td><td><code>wire_uint_8_list</code></td><td><code>String</code></td><td><code>String</code></td><td><code>String</code></td></tr>
<tr><td><code>Vec&lt;String&gt;</code></td><td><code>wire_StringList</code></td><td><code>wire_StringList</code></td><td><code>Box&lt;[String]&gt;</code></td><td><code>List</code></td><td><code>List&lt;String&gt;</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td><code>wire_list_t</code></td><td><code>wire_list_t</code></td><td><code>Box&lt;[JsValue]&gt;</code></td><td><code>List</code></td><td><code>List&lt;T&gt;</code></td></tr>
<tr><td><code>Box&lt;T&gt;</code></td><td><code>*mut T</code></td><td><code>ffi.Pointer&lt;T&gt;</code></td><td><code>*mut T</code></td><td><code>int</code></td><td><code>T</code></td></tr>
<tr><td><code>Option&lt;T&gt;</code></td><td><code>*mut T</code></td><td><code>ffi.Pointer&lt;T&gt;</code></td><td><code>Option&lt;T&gt;</code></td><td><code>T?</code></td><td><code>T?</code></td></tr>
<tr><td><code>Option&lt;Box&lt;T&gt;&gt;</code></td><td><code>*mut T</code></td><td><code>ffi.Pointer&lt;T&gt;</code></td><td><code>*mut T</code></td><td><code>T?</code></td><td><code>T?</code></td></tr>
<tr><td>enum/struct <code>T</code></td><td><code>*mut wire_t</code></td><td><code>ffi.Pointer&lt;T&gt;</code></td><td><code>Array</code></td><td><code>List</code></td><td>class <code>T</code></td></tr>
<tr><td>enum <code>T</code><sup class="footnote-reference"><a href="#3">3</a></sup></td><td><code>int</code></td><td><code>int</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td><code>i32</code></td><td><code>int</code></td><td>enum <code>T</code></td></tr>
</tbody></table>
</div>
<h2 id="memory-safety"><a class="header" href="#memory-safety">Memory safety</a></h2>
<p>How is memory safety implemented? This is a case-by-case problem. For example, suppose we want to see how a <code>String</code> is safely passed from Dart to Rust. Then, we need to examine the Dart <code>_api2wire_String</code> and the Rust <code>.wire2api()</code> for it.</p>
<p>Indeed <code>String</code> is implemented by delegating to <code>Vec&lt;u8&gt;</code>, so we need to see code related to String as well as <code>Vec&lt;u8&gt;</code>. By simply clicking a few times and jump around code, we will see that:</p>
<pre><code class="language-dart">ffi.Pointer&lt;wire_uint_8_list&gt; _api2wire_String(String raw) {
  return _api2wire_uint_8_list(utf8.encoder.convert(raw));
}

ffi.Pointer&lt;wire_uint_8_list&gt; _api2wire_uint_8_list(Uint8List raw) {
  final ans = inner.new_uint_8_list_0(raw.length);
  ans.ref.ptr.asTypedList(raw.length).setAll(0, raw);
  return ans;
}
</code></pre>
<p>and</p>
<pre><code class="language-rust noplayground">impl Wire2Api&lt;Vec&lt;u8&gt;&gt; for *mut wire_uint_8_list {
    fn wire2api(self) -&gt; Vec&lt;u8&gt; {
        unsafe {
            let wrap = support::box_from_leak_ptr(self);
            support::vec_from_leak_ptr(wrap.ptr, wrap.len)
        }
    }
}

impl Wire2Api&lt;String&gt; for *mut wire_uint_8_list {
    fn wire2api(self) -&gt; String {
        let vec: Vec&lt;u8&gt; = self.wire2api();
        String::from_utf8_lossy(&amp;vec).into_owned()
    }
}

pub struct wire_uint_8_list {
    ptr: *mut u8,
    len: i32,
}
</code></pre>
<p>In other words, String (or <code>Vec&lt;u8&gt;</code>) is converted to a raw struct with pointer and length field. The memory is manipulated carefully so there is no leak or double free.</p>
<p>We use Valgrind to check as well, and I use it in production environment without problems, so no worries about memory problems :)</p>
<h2 id="dart-bridge-hierarchy"><a class="header" href="#dart-bridge-hierarchy">Dart bridge hierarchy</a></h2>
<p>A bridge module consists of several classes:</p>
<ul>
<li>One <code>_Impl</code> class implementing the wire functions and common helpers; and</li>
<li>One or more <code>_Platform</code> classes implementing the platform-specific helpers.</li>
</ul>
<p>The implementor class takes a platform class as a private attribute, and the platform
class exposes all of its members decorated with <code>@protected</code>. The specific platform class
to be used is gated by conditional imports.</p>
<h2 id="cross-scope-communication-in-the-browser"><a class="header" href="#cross-scope-communication-in-the-browser">Cross-scope communication in the browser</a></h2>
<p>On Web platforms, for lack of a proper <code>SendPort</code> there exists replacements from <code>dart:html</code>.</p>
<p><strong>MessagePort</strong> replaces <code>dart:ffi</code>'s <code>SendPort</code> and is created from <code>MessageChannel</code>. The Dart
thread creates a channel, keeps the receive port and transfers the send port to the workers.</p>
<pre class="mermaid">sequenceDiagram
Dart -&gt;&gt; Rust: port2
Rust -&gt;&gt; Rust Worker: port2
Rust Worker -&gt;&gt; Dart: port2.postMessage
</pre>
<p><strong>BroadcastChannel</strong> replaces <code>dart:ffi</code>'s <code>SendPort</code> for <code>StreamSink</code>s, due to the fact that wasm_bindgen
keeps the ports in a JS-local scope that cannot be shared with other threads. A broadcast channel
is created by Dart, then passed to the main Rust thread. Rust then transfers its name to the workers.
When other workers refer to a <code>StreamSink</code> from another worker, e.g. if the sink was put in a static variable,
a new <code>BroadcastChannel</code> will be created from its name.</p>
<p><code>BroadcastChannel</code>s are guaranteed to be unique for each invocation.<sup class="footnote-reference"><a href="#4">4</a></sup></p>
<pre class="mermaid">sequenceDiagram
Dart -&gt;&gt; Rust: channel
Rust -&gt;&gt; Rust Worker 1: channel.name
Rust Worker 1 -&gt;&gt; Dart: channel.postMessage
Rust -&gt;&gt; Rust Worker 2: channel.name
Rust Worker 2 -&gt;&gt; Dart: channel.postMessage
</pre>
<p>It is theoretically possible to have a one-to-one implementation of Isolate using only web primitives,
<code>BroadcastChannel</code>s and <code>Worker</code>s, but it remains to be seen how practical such an approach would be.</p>
<h2 id="want-to-know-more-tell-me"><a class="header" href="#want-to-know-more-tell-me">Want to know more? Tell me</a></h2>
<p>What do you want to know? Feel free to create an issue in GitHub, and I will tell more :)</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>When behind a <code>ffi.Pointer</code>, they are their respective types from <code>dart:ffi</code>: <code>ffi.Int8</code>, <code>ffi.Int16</code>, etc.
<sup class="footnote-reference"><a href="#2">2</a></sup>:
These types are unsupported on Web by <code>dart:typed_list</code>, so this library provides a barebores shim over the JS native types.
If you wish to use these types, replace all <code>dart:typed_list</code> imports with this library.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Refers to C-style enums only (no fields).
<sup class="footnote-reference"><a href="#4">4</a></sup>: This is currently implemented as a monotonically-increasing index.</p>
</div>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
let mdbookTheme = localStorage.getItem("mdbook-theme") || default_theme;
mermaid.initialize({
    startOnLoad: true,
    theme: mdbookTheme == 'light' || mdbookTheme == 'rust' ? 'light' : 'dark',
});
</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<blockquote>
<p>Remark: Some docs here seem to be outdated. Refer to ci.yaml, main doc, justfile, etc to see an up-to-date version. This appendix will be overhauled.</p>
</blockquote>
<h2 id="releasing-a-new-version"><a class="header" href="#releasing-a-new-version">Releasing a new version</a></h2>
<p>Usually this is done by the owner (@fzyzcjy), so you do not need to do the following. If you need to release a new version, the following steps are needed. Bump several versions, change the version number in changelog, and use <code>cargo check</code> to automatically update the examples' dependency versions:</p>
<pre><code>just release
</code></pre>
<h2 id="sample-commands-to-run-code-generator"><a class="header" href="#sample-commands-to-run-code-generator">Sample commands to run code generator</a></h2>
<p>Just copied from <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/workflows/codegen.yml">CI codegen.yml</a>.</p>
<pre><code>(cd frb_codegen &amp;&amp; cargo run --package flutter_rust_bridge_codegen --bin flutter_rust_bridge_codegen -- --rust-input ../frb_example/pure_dart/rust/src/api.rs --dart-output ../frb_example/pure_dart/dart/lib/bridge_generated.dart --dart-format-line-length 120 &amp;&amp; cargo run --package flutter_rust_bridge_codegen --bin flutter_rust_bridge_codegen -- --rust-input ../frb_example/with_flutter/rust/src/api.rs --dart-output ../frb_example/with_flutter/lib/bridge_generated.dart --c-output ../frb_example/with_flutter/ios/Runner/bridge_generated.h --dart-format-line-length 120)
</code></pre>
<h2 id="format-and-lint-everything"><a class="header" href="#format-and-lint-everything">Format and lint everything</a></h2>
<pre><code>(cd frb_codegen &amp;&amp; cargo fmt --all); (cd frb_rust &amp;&amp; cargo fmt --all); (cd frb_macros &amp;&amp; cargo fmt --all); (cd frb_example/pure_dart/rust &amp;&amp; cargo fmt --all); (cd frb_example/with_flutter/rust &amp;&amp; cargo fmt --all);
(cd frb_codegen &amp;&amp; cargo clippy); (cd frb_rust &amp;&amp; cargo clippy); (cd frb_macros &amp;&amp; cargo clippy); (cd frb_example/pure_dart/rust &amp;&amp; cargo clippy); (cd frb_example/with_flutter/rust &amp;&amp; cargo clippy);                                                                                                                                          
(cd frb_dart &amp;&amp; dart format . --line-length 80); (cd frb_example/pure_dart/dart &amp;&amp; dart format . --line-length 120); (cd frb_example/with_flutter &amp;&amp; dart format . --line-length 120);
(cd frb_dart &amp;&amp; dart analyze --fatal-infos); (cd frb_example/pure_dart/dart &amp;&amp; dart analyze --fatal-infos); (cd frb_example/with_flutter &amp;&amp; dart analyze --fatal-infos);
</code></pre>
<h2 id="upgrade-dependency-in-your-dependent-project"><a class="header" href="#upgrade-dependency-in-your-dependent-project">Upgrade dependency in your dependent project</a></h2>
<pre><code>flutter pub upgrade flutter_rust_bridge
cargo update -p flutter_rust_bridge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-pure-dart"><a class="header" href="#tutorial-pure-dart">Tutorial: Pure Dart</a></h1>
<p><strong>Remark</strong>: The <code>valgrind_test</code> section of the <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/workflows/test.yaml">CI workflow</a> can also be useful, if you want details of each command and want to see Valgrind configuration.</p>
<p>Unlike the previous tutorial, this one integrates Rust with pure Dart instead of Flutter.</p>
<h2 id="get-example-code"><a class="header" href="#get-example-code">Get example code</a></h2>
<p>Please <a href="https://dart.dev/get-dart">install Dart</a>, <a href="https://www.rust-lang.org/learn/get-started">install Rust</a>, and have some familiarity with them. Then run <code>git clone https://github.com/fzyzcjy/flutter_rust_bridge</code>, and my example is in <code>frb_example/pure_dart</code>.</p>
<h2 id="optional-manually-run-code-generator"><a class="header" href="#optional-manually-run-code-generator">(Optional) Manually run code generator</a></h2>
<p>Remark: Bridge is automatically generated upon running <code>cargo build</code> using build-script in build.rs file, so this step is optional. Even if you do it, you should not see anything changed.</p>
<p>Install it: <code>cargo install flutter_rust_bridge_codegen</code>.</p>
<p>Run it: <code>flutter_rust_bridge_codegen --rust-input frb_example/pure_dart/rust/src/api.rs --dart-output frb_example/pure_dart/dart/lib/bridge_generated.dart</code> (See <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/workflows/codegen.yml">CI workflow</a> as a reference.) (For Windows, you may need <code>\\</code> instead of <code>/</code> for paths.)</p>
<h2 id="run-dartrust-app"><a class="header" href="#run-dartrust-app">Run &quot;Dart+Rust&quot; app</a></h2>
<p>You may run <code>frb_example/pure_dart/dart/lib/main.dart</code> as a normal Dart program, except that you should provide the dynamic linked library of the Rust code (for simplicity, here I only demonstrate the approach for dynamic linked library, but you can for sure use other methods). The detailed steps are as follows.</p>
<p>Run <code>cargo build</code> in <code>frb_example/pure_dart/rust</code> to build the Rust code into a <code>.so</code> file. Then run <code>dart frb_example/pure_dart/dart/lib/main.dart frb_example/pure_dart/rust/target/debug/libflutter_rust_bridge_example.so</code> to run the Dart program with Rust <code>.so</code> file. (If you have problems, see &quot;Troubleshooting&quot; section.)  (If on MacOS, Rust may indeed generate <code>.dylib</code>, so change the last command to use <code>...dylib</code> instead of <code>...so</code>,)</p>
<p>P.S. You will only see some tests passing - no fancy UI or functionality in this example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="safety-concerns"><a class="header" href="#safety-concerns">Safety concerns</a></h1>
<p>This library has CI that runs <a href="https://www.valgrind.org/">Valgrind</a> automatically on the setup that a Dart program calls a Rust program using this package, so memory problems should be found by Valgrind. <sub>(Notice that, even when running a simple hello-world Dart program, Valgrind will report hundreds of errors. See <a href="https://github.com/dart-lang/sdk/issues/47346">this Dart lang issue</a> for more details. Therefore, I both look at &quot;definitely lost&quot; in Valgrind, and manually search things related to this library - if all reported errors are unrelated to this library then we are safe.)</sub></p>
<p>In addition, Flutter integration tests are also done in CI. This ensures a real Flutter application using this library does not suffer from problems.</p>
<p>Most of the code are written in safe Rust. The <code>unsafe</code> code mainly comes from <code>support::box_from_leak_ptr</code> and <code>support::vec_from_leak_ptr</code>. They are used for pointers and arrays, and I follow the high-upvoted answers and official doc when writing down that few lines of code.</p>
<p>I use this library heavily in my own Flutter project (<code>yplusplus</code>, or <code>why++</code>). That app is in production and it works quite well. If I observe any problems, I will fix it in this library.</p>
<p>The CI also runs the <code>run_codegen</code> workflow, which ensure that the code generator can compile and generate desired results. Lastly, the CI also runs formatters and linters (<code>fmt</code>, <code>clippy</code>, <code>dart analyze</code>, <code>dart format</code>), and linters can also catch some common problems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<h2 id="the-generated-store_dart_post_cobject-has-the-wrong-signature--stdargh-file-not-found-in-linux--stdboolh--"><a class="header" href="#the-generated-store_dart_post_cobject-has-the-wrong-signature--stdargh-file-not-found-in-linux--stdboolh--">The generated store_dart_post_cobject() has the wrong signature / <code>'stdarg.h' file not found</code> in Linux / <code>stdbool.h</code> / ...</a></h2>
<p>Try to run code generator with working directory at <code>/</code>, or set the environment variable:</p>
<pre><code class="language-bash">export CPATH=&quot;$(clang -v 2&gt;&amp;1 | grep &quot;Selected GCC installation&quot; | rev | cut -d' ' -f1 | rev)/include&quot;
</code></pre>
<p>as described in <a href="https://github.com/dart-lang/ffigen/issues/257">ffigen #257</a>, or add include path as is described in <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/108">#108</a>. This is a problem with Rust's builtin <code>Command</code>. See also: <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/472">#472</a> &amp; <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/494">#494</a>.</p>
<h2 id="issue-with-store_dart_post_cobject"><a class="header" href="#issue-with-store_dart_post_cobject">Issue with <code>store_dart_post_cobject</code></a></h2>
<p>If calling rust function gives the error below, please consider running <strong>cargo build</strong> again. This can happen when the generated rs file is not included when building is being done.</p>
<pre><code class="language-sh">[ERROR:flutter/lib/ui/ui_dart_state.cc(209)] Unhandled Exception: Invalid argument(s): Failed to lookup symbol 'store_dart_post_cobject': target/debug/libadder.so: undefined symbol: store_dart_post_cobject
</code></pre>
<h2 id="error-running-cargo-ndk-ld-error-unable-to-find-library--lgcc"><a class="header" href="#error-running-cargo-ndk-ld-error-unable-to-find-library--lgcc">Error running <code>cargo ndk</code>: <code>ld: error: unable to find library -lgcc</code></a></h2>
<p>Downgrade Android NDK to version 22. This is an <a href="https://github.com/bbqsrc/cargo-ndk/issues/22">ongoing issue</a> with <code>cargo-ndk</code>, a library unrelated to flutter_rust_bridge but solely used to build the examples, when using Android NDK version 23. (See <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/149">#149</a>)</p>
<h2 id="fail-to-run-flutter_rust_bridge_codegen-on-macos-please-supply-one-or-more-pathtollvm"><a class="header" href="#fail-to-run-flutter_rust_bridge_codegen-on-macos-please-supply-one-or-more-pathtollvm">Fail to run <code>flutter_rust_bridge_codegen</code> on MacOS, &quot;Please supply one or more path/to/llvm...&quot;</a></h2>
<p>If you are running macOS, you will need to specify a path to your llvm:</p>
<pre><code class="language-shell">flutter_rust_bridge_codegen --rust-input path/to/your/api.rs --dart-output path/to/file/being/bridge_generated.dart --llvm-path /usr/local/homebrew/opt/llvm/
</code></pre>
<p>You can install llvm using <code>brew install llvm</code> and it will be installed at <code>/usr/local/homebrew/opt/llvm/</code> by default.</p>
<h2 id="freezed-file-is-sometimes-not-generated-when-it-should-be"><a class="header" href="#freezed-file-is-sometimes-not-generated-when-it-should-be">Freezed file is sometimes not generated when it should be</a></h2>
<p>If your <code>.freezed.dart</code> or <code>.g.dart</code> seems outdated, ensure you have run the <code>build_runner</code>.</p>
<p>Related: https://github.com/fzyzcjy/flutter_rust_bridge/issues/330</p>
<h2 id="cant-create-typedef-from-non-function-type"><a class="header" href="#cant-create-typedef-from-non-function-type"><code>Can't create typedef from non-function type.</code></a></h2>
<p>Ensure min sdk version of Flutter <code>pubspec.yaml</code> is at least 2.13.0 to let <code>ffigen</code> happy.</p>
<p>https://github.com/fzyzcjy/flutter_rust_bridge/issues/334</p>
<h2 id="generated-code-is-so-long"><a class="header" href="#generated-code-is-so-long">Generated code is so long</a></h2>
<p>Indeed all generated code are necessary (if you find something that can be simplified, file an issue). Moreover, other code generation tools also generate long code - for example, when using Google protobuf, a very popular serialization library, I see &gt;10k lines of Java code generated for a quite simple source proto file.</p>
<h2 id="why-need-dart-2140"><a class="header" href="#why-need-dart-2140">Why need Dart <code>2.14.0</code></a></h2>
<p>Dart SDK <code>&gt;=2.14.0</code> is needed not by this library, but by the latest version of the <code>ffigen</code> tool. Therefore, write <code>sdk: &quot;&gt;=2.14.0 &lt;3.0.0&quot;</code> in the <code>environment</code> section of <code>pubspec.yaml</code>. If you do not want that, consider installing a older version of the <code>ffigen</code> tool.</p>
<h2 id="issues-on-web"><a class="header" href="#issues-on-web">Issues on Web?</a></h2>
<p>Check out <a href="./wasm_limitations.html">Limitations on WASM</a> for some common problems and solutions
to adapt existing code to WASM.</p>
<h2 id="other-problems"><a class="header" href="#other-problems">Other problems?</a></h2>
<p>Don't hesitate to <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/new/choose">open an issue</a>! I usually reply within minutes or hours (except when sleeping, of course).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-arguments"><a class="header" href="#command-line-arguments">Command line arguments</a></h1>
<p>Simply add <code>--help</code> to see full documentation. The following is a snapshot when running the command with <code>--help</code>:</p>
<pre><code class="language-shell">$ flutter_rust_bridge_codegen --help
flutter_rust_bridge_codegen 1.44.0

USAGE:
    flutter_rust_bridge_codegen [OPTIONS] --rust-input &lt;RUST_INPUT&gt;... --dart-output &lt;DART_OUTPUT&gt;...

OPTIONS:
    -r, --rust-input &lt;RUST_INPUT&gt;...
            Path of input Rust code

    -d, --dart-output &lt;DART_OUTPUT&gt;...
            Path of output generated Dart code

        --dart-decl-output &lt;DART_DECL_OUTPUT&gt;
            If provided, generated Dart declaration code to this separate file

    -c, --c-output &lt;C_OUTPUT&gt;
            Output path of generated C header

        --rust-crate-dir &lt;RUST_CRATE_DIR&gt;...
            Crate directory for your Rust project

        --rust-output &lt;RUST_OUTPUT&gt;...
            Output path of generated Rust code

        --class-name &lt;CLASS_NAME&gt;...
            Generated class name

        --dart-format-line-length &lt;DART_FORMAT_LINE_LENGTH&gt;
            Line length for Dart formatting [default: 80]

        --skip-add-mod-to-lib
            Skip automatically adding `mod bridge_generated;` to `lib.rs`

        --llvm-path &lt;LLVM_PATH&gt;...
            Path to the installed LLVM

        --llvm-compiler-opts &lt;LLVM_COMPILER_OPTS&gt;
            LLVM compiler opts

        --dart-root &lt;DART_ROOT&gt;...
            Path to root of Dart project, otherwise inferred from --dart-output

        --no-build-runner
            Skip running build_runner even when codegen-required code is detected

    -v, --verbose
            Show debug messages

        --wasm
            Enable WASM module generation. Requires: --dart-decl-output

        --inline-rust
            Inline declaration of Rust bridge modules

        --skip-deps-check
            Skip dependencies check

    -h, --help
            Print help information

    -V, --version
            Print version information
</code></pre>
<h2 id="flutter_rust_bridge_serve"><a class="header" href="#flutter_rust_bridge_serve"><code>flutter_rust_bridge_serve</code></a></h2>
<pre><code class="language-shell">$ dart run flutter_rust_bridge_serve --help
flutter_rust_bridge_serve 1.44.0
Develop Rust WASM modules with cross-origin isolation.

USAGE:
	flutter_rust_bridge_serve [OPTIONS] [..REST]
	flutter_rust_bridge_serve --dart-input &lt;ENTRY&gt; --root &lt;ROOT&gt; [OPTIONS] [..REST]

OPTIONS:
-p, --port=&lt;PORT&gt;             HTTP port to listen to
                              (defaults to &quot;8080&quot;)
-r, --root=&lt;ROOT&gt;             Root of the Flutter/Dart output
-c, --crate=&lt;CRATE&gt;           Directory of the crate
                              (defaults to &quot;native&quot;)
-d, --dart-input=&lt;ENTRY&gt;      Run &quot;dart compile&quot; with the specified input instead of &quot;flutter build&quot;
-w, --wasm-output=&lt;PKG&gt;       WASM output path
-v, --[no-]verbose            Display more verbose information
    --[no-]relax-coep         Set COEP to credentialless
                              Defaults to true for Flutter
    --[no-]open               Open the webpage in a browser
                              (defaults to on)
    --run-tests               Run tests in headless Chromium
    --release                 Compile in release mode
    --[no-]weak-refs          Enable the weak references proposal
                              Requires wasm-bindgen in path
    --[no-]reference-types    Enable the reference types proposal
                              Requires wasm-bindgen in path
-h, --help                    Print this help message
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set-up-flutterdartrust-support-from-scratch"><a class="header" href="#set-up-flutterdartrust-support-from-scratch">Set up Flutter/Dart+Rust support from scratch</a></h1>
<blockquote>
<p>This documentation is archived, though technically still correct. Have a look at <a href="integrate.html">integrating with existing projects</a> chapters for a more detailed demonstration.</p>
</blockquote>
<p>I suggest that you can start with the <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/with_flutter">Flutter example</a> first, and modify it to satisfy your needs. It can serve as a template for new projects. It is run against CI so we are sure it works.</p>
<p>Indeed, this library is nothing but a code generator that helps your Flutter/Dart functions call Rust functions. Therefore, &quot;how to create a Flutter app that can run Rust code&quot; is actually out of the scope of this library, and there are already several tutorials on the Internet.</p>
<p>However, I can sketch the outline of what to do if you want to set up a new Flutter+Rust project as follows.</p>
<h2 id="step-1"><a class="header" href="#step-1">Step 1</a></h2>
<p>Create a new Flutter project (or use an existing one). The Dart SDK should be <code>&gt;=2.14.0</code> if you want to use the latest <code>ffigen</code> tool.</p>
<h2 id="step-2"><a class="header" href="#step-2">Step 2</a></h2>
<p>Create a new Rust project, say, at directory <code>rust</code> under the Flutter project.</p>
<h2 id="step-3"><a class="header" href="#step-3">Step 3</a></h2>
<p>Edit <code>Cargo.toml</code> and add:</p>
<pre><code class="language-diff">[lib]
name = &quot;flutter_rust_bridge_example&quot; # whatever you like
# notice this type. `cdylib` for android, and `staticlib` for iOS. I write down a script to change it before build.
+ crate-type = [&quot;cdylib&quot;]
</code></pre>
<h2 id="step-4"><a class="header" href="#step-4">Step 4</a></h2>
<p>Follow the standard steps of &quot;how iOS uses static libraries&quot;.</p>
<ol>
<li>In XCode, edit <code>Strip Style</code> in <code>Build Settings</code> to <code>Debugging Symbols</code>.</li>
<li>Add your <code>lib{crate}.a</code> to <code>Link Binary With Libraries</code> in <code>Build Phases</code>.</li>
<li>Add <code>binding.h</code> to <code>Copy Bundle Resources</code>.</li>
<li>Add <code>#import &quot;binding.h&quot;</code> to <code>Runner-Bridging-Header</code>.</li>
<li>Last but not least, add a never-to-be-executed dummy function in Swift that calls any of the generated C bindings. This lib has already generated a dummy method for you, so you simply need to add <code>print(&quot;dummy_value=\(dummy_method_to_enforce_bundling())&quot;);</code> to swift file's <code>override func application(...) {}</code>, and this will prevent symbol stripping - especially in the release build for iOS (i.e. when building ipa file or releasing to App Store). Notice that, we have to use that <code>dummy_method_to_enforce_bundling()</code>, otherwise the symbols will not maintain in the release build, and Flutter will complain it cannot find the symbols.</li>
</ol>
<h2 id="step-5"><a class="header" href="#step-5">Step 5</a></h2>
<p>Lastly, in order to build the Rust library automatically when you are building Flutter, follow <a href="https://stackoverflow.com/q/69515032/4619958">this tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-wasm-binary-manually"><a class="header" href="#building-a-wasm-binary-manually">Building a WASM binary manually</a></h1>
<p>Here are the complete commands for building a WASM binary with this library:</p>
<pre><code class="language-bash">export RUSTUP_TOOLCHAIN=nightly
export RUSTFLAGS=&quot;-C target-feature=+atomics,+bulk-memory,+mutable-globals&quot;
wasm-pack build \
    -t no-modules \
    -d &lt;WASM_OUTPUT_PATH&gt; \
    --no-typescript -- \
    -Z build-std=std,panic_abort
</code></pre>
<p>Continue reading for more details.</p>
<hr />
<p><code>flutter_rust_bridge_codegen</code> expects a certain setup that is modeled after the
<a href="https://github.com/rustwasm/wasm-bindgen/tree/main/examples/raytrace-parallel">wasm_bindgen raytracing example</a>
and by extension consumes the <a href="https://rustwasm.github.io/docs/wasm-bindgen"><code>wasm_bindgen</code></a> library and its ecosystem.
The requirements are:</p>
<ul>
<li>The standard library being built with the <code>panic_abort</code> feature</li>
<li>The library and standard library being built with the target
features <code>atomics</code>, <code>bulk_memory</code> and <code>mutable_globals</code></li>
<li><code>wasm-pack</code> called with <code>-t no-modules</code> (to be relaxed in the future)</li>
</ul>
<p>Note that these features also represent a hard requirement on your
users' browser versions.</p>
<p>Furthermore, this library does not support JavaScript
runtimes as of writing.</p>
<p><strong>WASM_OUTPUT_PATH</strong> refers to the output directory of the WASM module.
If running Flutter, this is usually <code>web/pkg</code>.</p>
<h2 id="setting-up-the-web-server"><a class="header" href="#setting-up-the-web-server">Setting up the web server</a></h2>
<p>Once you have built your binary and are ready to deploy, you will also need
to configure your web server to respond with these two headers:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cross-Origin_Resource_Policy_(CORP)"><code>Cross-Origin-Resource-Policy</code></a> set to <code>same-origin</code></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy"><code>Cross-Origin-Embedder-Policy</code></a> set to <code>require-corp</code><sup class="footnote-reference"><a href="#1">1</a></sup></li>
</ul>
<p>Here is a sample web server that accomplishes this task (excerpt from <code>flutter_rust_bridge_serve</code>):</p>
<pre><code class="language-dart">import 'package:shelf/shelf.dart';
import 'package:shelf/shelf_io.dart';
import 'package:shelf_static/shelf_static.dart';

void main() async {
    final root = &quot;/* directory containing index.html */&quot;;
    final staticFilesHandler = createStaticHandler(root, defaultDocument: 'index.html');
    final handler = const Pipeline().addMiddleware((handler) {
        return (req) async {
            final res = await handler(req);
            return res.change(headers: const {
                'Cross-Origin-Opener-Policy': 'same-origin',
                'Cross-Origin-Embedder-Policy': 'require-corp',
            });
        };
    }).addHandler(staticFilesHandler);
    await serve(handler, 'localhost', 8080);
}
</code></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>When running Flutter Web, you may encounter issues with downloading Flutter
support scripts which have not been marked as <code>crossorigin=&quot;anonymous&quot;</code> and
therefore cannot be loaded. For local testing, you can specify <code>credentialless</code>
instead.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limitations-of-wasm-1"><a class="header" href="#limitations-of-wasm-1">Limitations of WASM</a></h1>
<ul>
<li>Safari cannot spawn nested <code>Worker</code>s. A workaround is to build two variants of the library,
one with multithreading and one without, and serve Safari users the single-threaded variant.
For a more general solution, check out <a href="https://github.com/GoogleChromeLabs/wasm-feature-detect">wasm-feature-detect</a>
or <a href="https://github.com/johanholmerin/nested-worker">nested-worker</a>.</li>
<li><code>std::thread::spawn</code> is unimplemented and replacements (e.g. <code>wasm_thread</code>) are not fully supported. 
If you must use them, consider wrapping your return type in a <code>SyncReturn&lt;_&gt;</code> to
avoid the internal thread pool interfering with your threads.
This library includes a <code>spawn!</code> macro which spawns a new thread using the internal thread pool.</li>
<li>When a Rust thread panics, it aborts and throws a JavaScript <code>RuntimeError</code> that cannot be caught by name in
Dart. This is expected to change as the exception handling story for WASM improves, but a rule of thumb
is to replace <code>.unwrap</code> with <code>.expect</code> or <code>Err</code>s.</li>
<li>As a consequence, <code>panic::catch_unwind</code> does not work on the Web. As of writing, the implementation to
catch these errors resides within the bodies of the workers, i.e. it is not straightforward enough to
generalize for other use-cases.</li>
<li><code>Int64List</code> and <code>Uint64List</code> throws when used on Web platforms. They are left intentionally
unimplemented by the Dart language developers, perhaps due to the differences between <code>int</code> and <code>BigInt</code>.
This library provides a barebones pure Dart shim whose behavior may differ from the specifications,
so please create an issue/PR if you encounter any significant digression.</li>
<li><code>Int64List</code> and <code>Uint64List</code> arithmetics clamp on native platforms, but wrap on the Web. If your use-case
requires precision around large integer values, please be mindful of these platform-specific differences.</li>
<li>Support for the various components of WASM is not universal among browsers. Here is a (non-exhaustive) list
of trackers for how widely available some of the features are across browsers:
<ul>
<li><a href="https://caniuse.com/mdn-api_messageport_messageerror_event"><code>MessagePort</code> error events</a></li>
<li><a href="https://caniuse.com/mdn-api_crossoriginisolated"><code>crossOriginIsolated</code></a></li>
<li><a href="https://caniuse.com/sharedarraybuffer">Shared Array Buffers</a></li>
<li><a href="https://caniuse.com/sharedarraybuffer"><code>BroadcastChannel</code></a></li>
<li><a href="https://caniuse.com/mdn-javascript_builtins_atomics">Atomics</a></li>
<li><a href="https://caniuse.com/mdn-javascript_builtins_bigint64array"><code>BigInt64Array</code></a></li>
<li><a href="https://caniuse.com/wasm">WebAssembly</a></li>
<li><a href="https://webassembly.org/roadmap/">WebAssembly roadmap</a></li>
</ul>
</li>
<li>JavaScript runtimes (Node.js, Deno, etc.) support is not yet implemented.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="articles"><a class="header" href="#articles">Articles</a></h1>
<p>This chapter contains some articles related to <code>flutter_rust_bridge</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-in-rust-1"><a class="header" href="#async-in-rust-1">Async in Rust</a></h1>
<blockquote>
<p>Author: @AlienKevin</p>
</blockquote>
<p>This library does not yet support returning a Future type from Rust and this has to do with the difficulty of uniting the various approaches to async in Rust. The <a href="https://rust-lang.github.io/async-book/01_getting_started/03_state_of_async_rust.html#language-and-library-support">Rust Book</a> summarized the current state of async support succinctly:</p>
<blockquote>
<p>The most fundamental traits, types and functions, such as the Future trait are provided by the standard library. The async/await syntax is supported directly by the Rust compiler.</p>
</blockquote>
<blockquote>
<p>Many utility types, macros and functions are provided by the futures crate. They can be used in any async Rust application.</p>
</blockquote>
<blockquote>
<p>Execution of async code, IO and task spawning are provided by &quot;async runtimes&quot;, such as Tokio and async-std. Most async applications, and some async crates, depend on a specific runtime.</p>
</blockquote>
<p>While the futures crate provides an executor called <code>futures::executor::block_on</code>, libraries that use Tokio runtime cannot use this executor. According to <a href="https://runrust.miraheze.org/wiki/Async_crate_comparison">Rust-lang community wiki</a>, crates like Tokio that provide both a runtime and IO abstractions often have their IO depend on the runtime. This can make it difficult to write runtime-agnostic code. First, we demonstrate a common use case of async programming in Rust by attempting to fetch the content of a file from the internet using the popular HTTP Client <a href="https://docs.rs/reqwest/0.11.6/reqwest/">Reqwest</a>:</p>
<pre><code class="language-rust ignore">use anyhow;

async fn get() -&gt; anyhow::Result&lt;String&gt; {
    let url = &quot;https://link/to/file/download&quot;;
    let data = reqwest::get(url).await?.text().await?;
    Ok(data)
}
</code></pre>
<p>When you try to generate bindings for the <code>get</code> function, the generated code will contain errors because this library does not support returning Future from Rust.</p>
<h2 id="mismatched-runtime"><a class="header" href="#mismatched-runtime">Mismatched runtime</a></h2>
<p>The next logic thing to try would be to convert the asynchronous code to synchronous by directly blocking the current thread and execute the code. For our first attempt, we wrap <code>futures::executor::block_on</code> around an async block containing reqwest calls.</p>
<pre><code class="language-rust ignore">use anyhow;
use futures::executor::block_on;

fn get() -&gt; anyhow::Result&lt;String&gt; {
    block_on(async {
        let url = &quot;https://link/to/file/download&quot;;
        let data = reqwest::get(url).await?.text().await?;
        Ok(data)
    })
}
</code></pre>
<p>Since Reqwest uses the Tokio runtime instead of the futures runtime, our code panicked with the error &quot;there is no reactor running, must be called from the context of a Tokio 1.x runtime&quot;. To fix this error, we have two ways to execute async codes using the Tokio runtime. Approach 1 is the simplest and uses the convenient <a href="https://docs.rs/tokio/1.14.0/tokio/attr.main.html"><code>tokio::main</code></a> macro to turn an async function to a synchronous one. Approach 2 requires you to explicitly create a new Tokio runtime and use its block_on function to run the future to completion.</p>
<h2 id="approach-1-macro"><a class="header" href="#approach-1-macro">Approach 1 (macro)</a></h2>
<pre><code class="language-rust ignore">use anyhow;

#[tokio::main(flavor = &quot;current_thread&quot;)]
async fn get() -&gt; anyhow::Result&lt;String&gt; {
    let url = &quot;https://link/to/file/download&quot;;
    let data = reqwest::get(url).await?.text().await?;
    Ok(data)
}
</code></pre>
<p>It has the following dependencies:</p>
<pre><code class="language-toml">[dependencies]
futures = &quot;0.3&quot;
reqwest = &quot;0.11.6&quot;
tokio = { version = &quot;1.14.0&quot;, features = [&quot;rt&quot;, &quot;macros&quot;] }
anyhow = { version = &quot;1.0.49&quot; }
</code></pre>
<h2 id="approach-2-runtime"><a class="header" href="#approach-2-runtime">Approach 2 (runtime)</a></h2>
<pre><code class="language-rust ignore">use anyhow;
use tokio::runtime::Runtime;

fn get() -&gt; anyhow::Result&lt;String&gt; {
    let rt = Runtime::new().unwrap();
    rt.block_on(async {
        let url = &quot;https://link/to/file/download&quot;;
        let data = reqwest::get(url).await?.text().await?;
        Ok(data)
    })
}
</code></pre>
<p>It has the following dependencies:</p>
<pre><code class="language-toml">[dependencies]
futures = &quot;0.3&quot;
reqwest = &quot;0.11.6&quot;
tokio = { version = &quot;1.14.0&quot;, features = [&quot;rt-multi-thread&quot;] }
anyhow = { version = &quot;1.0.49&quot; }
</code></pre>
<h2 id="plain-futures"><a class="header" href="#plain-futures">Plain futures</a></h2>
<p>If you are using the plain futures crate without runtimes like Tokio, you should be safe to wrap the asynchronous code in an async block and use the <a href="https://docs.rs/futures/0.3.18/futures/executor/fn.block_on.html"><code>futures::executor::block_on</code></a> to run the future to completion:</p>
<pre><code class="language-rust ignore">use futures::executor::block_on;

async fn hello_world() -&gt; String {
    &quot;hello, world!&quot;.to_string()
}

fn get() -&gt; String {
    block_on(async {
        hello_world().await
    })
}

fn main() {
    println!(&quot;{}&quot;, get()); // prints &quot;hello, world!&quot;
}
</code></pre>
<h2 id="avoid-async"><a class="header" href="#avoid-async">Avoid async</a></h2>
<p>Lastly, you can avoid async code all together by using synchronously/blocking version of the functions if they are available. In Reqwest, there's a module called <code>reqwest::blocking</code> designed specifically for this purpose. So you can achieve the same thing above without using async.</p>
<pre><code class="language-rust ignore">use anyhow;
use reqwest;

fn get() -&gt; anyhow::Result&lt;String&gt; {
    let url = &quot;https://link/to/file/download&quot;;
    let data = reqwest::blocking::get(url)?.text()?;
    Ok(data)
}
</code></pre>
<p>It has the following dependencies:</p>
<pre><code class="language-toml">[dependencies]
futures = &quot;0.3&quot;
reqwest = { version = &quot;0.11.6&quot;, features = [&quot;blocking&quot;] }
anyhow = { version = &quot;1.0.49&quot; }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-multiple-files"><a class="header" href="#generating-multiple-files">Generating multiple files</a></h1>
<blockquote>
<p>Author: @dbsxdbsx</p>
</blockquote>
<p>This article describes some thoughts and implementations about the feature of generating multiple files.</p>
<p>Before, like the <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/pure_dart/rust/src/api.rs">pure_dart's api.rs</a>, all APIs are exposed together in a single file(block). This is not bad when the whole project is simple. But it would become quite hard to maintain or develop, when the project becomes more and more complex, especially when it is a team project. Therefore, it is time to reconstruct code --- classify the exposed Api into proper blocks(files).</p>
<p>(Before going on reading, make sure that you are quite familiar with how to use <a href="https://github.com/Desdaemon/flutter_rust_bridge_template">template</a> to generate code with flutter_rust_bridge. If not, take a look at the former chapters or <a href="https://github.com/fzyzcjy/flutter_rust_bridge/tree/master/frb_example/pure_dart">the basic example</a> again, please.)</p>
<h2 id="try-to-classify-api-into-different-blocksfiles"><a class="header" href="#try-to-classify-api-into-different-blocksfiles">Try to classify Api into different blocks(files)</a></h2>
<p>Suppose, you only have two Api in <code>api.rs</code> originally, like this:</p>
<pre><code class="language-rust noplayground">#![allow(unused_variables)]

pub fn simple_add(a: i32, b: i32) -&gt; i32 {
    a + b
}

pub fn simple_minus(a: i32, b: i32) -&gt; i32 {
    a - b
}
</code></pre>
<p>Now you want to classify these 2 Api into 2 blocks for some reason-- say, you put the <code>simple_add</code> Api into file <code>api_1.rs</code> and the other into <code>api_2.rs</code>. And then make a little modification in <code>lib.rs</code>:</p>
<pre><code class="language-rust noplayground">mod api_1;
mod api_2;
</code></pre>
<p>Ok, now the question is how to deal with them with flutter_rust_bridge? From the <a href="https://github.com/Desdaemon/flutter_rust_bridge_template/blob/main/justfile#L11">template justfile</a>, we know code from a single API file called <code>api_rs</code> can be generated with a command like this:</p>
<pre><code>gen:
    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated.dart&quot; \
...
</code></pre>
<p>(For simplicity, only two necessary flags <code>rust-input</code> and <code>dart-output</code> here.)</p>
<p>Then, to generate code within 2 blocks(files), you may come out with an approach like this:</p>
<pre><code>gen:
    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_1.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_1.dart&quot; \

    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_2.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_2.dart&quot; \
...
</code></pre>
<p>But here comes a problem, how to use them in dart? Like <code>await API.simpleAdd(1,2)</code> or
<code>await API.simpleMinus(1,2)</code> as before? The point here is, to thoroughly decouple Api from different blocks (which is the main reason for using multiple blocks of API), <strong>flag <code>class-name</code> is needed</strong>. So the command should be modified like this:</p>
<pre><code>gen:
    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_1.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_1.dart&quot; \
        --class-name ApiClass1

    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_2.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_2.dart&quot; \
        --class-name ApiClass2
...
</code></pre>
<p>(The class name <code>ApiClass1</code> and <code>ApiClass2</code> are chosen arbitrarily here.)</p>
<p>So now it seems to be perfect to generate code and using Api in Dart like <code>ApiClass1.simpleAdd(1,2)</code> or <code>ApiClass2.simpleMinus(1,2)</code>.</p>
<p>But actually, the above command is still not enough to generate code correctly. Because multiple blocks need to be translated respectively through FFI. So on the rust side, instead of generating code to a single file <a href="https://github.com/Desdaemon/flutter_rust_bridge_template/blob/main/native/src/bridge_generated.rs"><code>bridge_generated.rs</code></a>, now there are 2 files needed. But, what are the names of these 2 auto-generated rust files?
Here, for less misunderstanding, flutter_rust_bridge decides to ask for another compulsory flag <code>rust-output</code>. So the command should be modified like this:</p>
<pre><code>gen:
    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_1.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_1.dart&quot; \
        --class-name ApiClass1 \
        --rust-output generated_api_1

    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_2.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_2.dart&quot; \
        --class-name ApiClass2 \
        --rust-output generated_api_2
...
</code></pre>
<p>(Still, the rust output name <code>generated_api_1</code> and <code>generated_api_2</code> are chosen arbitrarily here.)</p>
<p>That is, flutter_rust_bridge asks you to manually define the generated rust file names, feel free to choose any name you like.</p>
<h2 id="some-issues-with-separate-commands"><a class="header" href="#some-issues-with-separate-commands">Some issues with separate commands</a></h2>
<p>Based on the last commands we come up with, everything seems to be fine --- the code generated, you can use them in Dart, and the whole project is compilable. And you would also notice some changes in <code>lib.rs</code>:</p>
<pre><code class="language-rust noplayground">mod api_1;
mod api_2;
mod generated_api_1; /* AUTO INJECTED BY flutter_rust_bridge. This line may not be accurate, and you can change it according to your needs. */
mod generated_api_2; /* AUTO INJECTED BY flutter_rust_bridge. This line may not be accurate, and you can change it according to your needs. */
</code></pre>
<p>But actually, it is not good enough.</p>
<h3 id="issue-from-explicit-api-conflict"><a class="header" href="#issue-from-explicit-api-conflict">issue from explicit Api conflict</a></h3>
<p>Let's say one day, you decide to add another API, say <code>simpleDivide</code>. But when you compile the whole project, the Dart compiler just complains &quot;The symbol <code>simpleDivide</code> has already been defined ...&quot;. Then you check whether this <code>simpleDivide</code> is defined duplicated. Finally, you find that it's already defined in another block. This situation occurs quite a lot, when the other block is in the charge of someone else, especially in a big project. It is easy to see that the whole routine is a little inefficient since you don't realize the Api conflict until doing compiling when you've probably coded a lot with this &quot;new defined&quot; Api --- and the more time compiling takes, the more inefficient.</p>
<h3 id="issue-from-implicit-api-conflict"><a class="header" href="#issue-from-implicit-api-conflict">issue from implicit Api conflict</a></h3>
<p>And what makes the Api conflict issue more catastrophic? Say you define another Api with parameter <code>String</code> in <code>api_1.rs</code>:</p>
<pre><code class="language-rust noplayground">pub fn test_string_1(s1: String) {
    println!(&quot;test implicit parameter conflicts {}&quot;, s1);
}
</code></pre>
<p>And then you put another Api with parameter <code>String</code> in <code>api_2.rs</code>:</p>
<pre><code class="language-rust noplayground">pub fn test_string_2(s2: String) {
    println!(&quot;test implicit parameter conflicts {}&quot;, s2);
}
</code></pre>
<p>These 2 Apis don't violate the uniqueness required by FFI. They should be compilable with no error. But the truth is no! Why? Because for the <code>String</code> parameter, flutter_rust_bridge would automatically generate API like this:</p>
<pre><code class="language-rust noplayground">#[no_mangle]
pub extern &quot;C&quot; fn new_uint_8_list(len: i32) -&gt; *mut wire_uint_8_list
</code></pre>
<p>which is used to let rust code easily cooperate with Dart through FFI. So if there are 2 APIs both taking <code>String</code> as parameters over blocks, you should notice a similar panic like &quot;the symbol <code>new_uint_8_list</code> is already defined ...&quot; during compiling(<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/511">issue #511</a>).</p>
<p>(Actually, since version <a href="https://github.com/fzyzcjy/flutter_rust_bridge/releases/tag/v1.37.0">1.37</a>, even with the separated commands with no Api defined, the whole project is still not compilable with error &quot;symbol <code>free_WireSyncReturnStruct</code> is already defined... &quot;, the symbol <code>free_WireSyncReturnStruct</code> is another implicitly Api generated by flutter_rust_bridge.)</p>
<p>So these kinds of explicit/implicit Api conflicts are annoying and frustrating. How to resolve it?</p>
<p>Theoretically, the conflict can be detected earlier during generating code, when flutter_rust_bridge knows every detail about API. But the key is that <strong>flutter_rust_bridge has to know all Api over all blocks before generating code</strong>. That is, with the separated command stated above, flutter_rust_bridge can't do the check for you in practice. Therefore, it is necessary to unite the separated commands into ONE command.</p>
<h2 id="correct-command-for-generating-code-with-multiple-blocks"><a class="header" href="#correct-command-for-generating-code-with-multiple-blocks">correct command for generating code with multiple blocks</a></h2>
<p>Now comes the joined command to resolve the above issue:</p>
<pre><code>gen:
    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_1.rs&quot; &quot;$REPO_DIR/native/src/api_2.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/bridge_generated_api_1.dart&quot; &quot;$REPO_DIR/lib/bridge_generated_api_2.dart&quot; \
        --class-name ApiClass1 ApiClass2 \
        --rust-output generated_api_1 generated_api_2
...
</code></pre>
<p>Here, with just 1 command, flutter_rust_bridge would smartly check if there are conflicts over all Api over all blocks, be it defined explicitly or implicitly.</p>
<p>That is, for the explicitly defined APIs like <code>simple_add</code> and <code>simple_minus</code>, if there are duplicated ones, flutter_rust_bridge would throw a panic like &quot;thread 'main' panicked at 'symbol [simple_add] has already been defined'...&quot;, and you are responsible to fix it. And for the implicitly defined API like <code>new_uint_8_list</code>, since it is essential, flutter_rust_bridge would try to work around it by adding suffix starting from 0, like <code>new_uint_8_list_0</code> and <code>new_uint_8_list_1</code>.</p>
<p>To sum up, <strong>there are 4 compulsory flags when you deal with multiple blocks.</strong> They are <code>rust-input</code>, <code>dart-output</code>, <code>class-name</code> and <code>rust-output</code>. Also, the number of fields following each flag should be consistent. You can try to <code>cargo build</code> with fewer flags or inconsistent fields to see what kind of panic would be popped up with the <a href="https://github.com/fzyzcjy/flutter_rust_bridge/tree/master/frb_example/pure_dart_multi/rust/build.rs">pure_dart_multi</a> example when doing generation.</p>
<h2 id="bizarre-weird-but-compilable-command-with-the-disorder"><a class="header" href="#bizarre-weird-but-compilable-command-with-the-disorder">bizarre, weird but compilable command with the disorder</a></h2>
<p><strong>Flutter_rust_bridge doesn't do semantic correction over all flags.</strong> So, it is syntactically correct with the following generation command:</p>
<pre><code>gen:
    export REPO_DIR=&quot;$PWD&quot;; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input &quot;$REPO_DIR/native/src/api_orange.rs&quot; &quot;$REPO_DIR/native/src/api_apple.rs&quot; \
        --dart-output &quot;$REPO_DIR/lib/gen_api_apple.dart&quot; &quot;$REPO_DIR/lib/gen_api_orange.dart&quot; \
        --class-name ApiClassOrange ApiClassApple \
        --rust-output generated_api_apple generated_api_orange
</code></pre>
<p>NOTE: the suffix <code>apple</code> and <code>orange</code> are quite disordered for each flag here on purpose. It is compilable and usable. But as you should know, it is not a good practice, semantically. It is all up to you to decide the field names for each flag, so be beware of it!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
