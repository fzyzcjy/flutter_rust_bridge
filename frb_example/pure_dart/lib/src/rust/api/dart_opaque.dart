
        // This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.35.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'dart_opaque.freezed.dart';

        

        Future<String> asyncAcceptDartOpaqueTwinNormal({required Object opaque , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueAsyncAcceptDartOpaqueTwinNormal(opaque: opaque, hint: hint);

Future<Object> loopBackTwinNormal({required Object opaque , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueLoopBackTwinNormal(opaque: opaque, hint: hint);

Future<Object?> loopBackOptionTwinNormal({required Object opaque , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueLoopBackOptionTwinNormal(opaque: opaque, hint: hint);

Future<ObjectArray1> loopBackArrayTwinNormal({required Object opaque , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueLoopBackArrayTwinNormal(opaque: opaque, hint: hint);

Future<List<Object>> loopBackVecTwinNormal({required Object opaque , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueLoopBackVecTwinNormal(opaque: opaque, hint: hint);

Future<void> loopBackOptionGetTwinNormal({Object? opaque , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueLoopBackOptionGetTwinNormal(opaque: opaque, hint: hint);

Future<void> loopBackArrayGetTwinNormal({required ObjectArray1 opaque , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueLoopBackArrayGetTwinNormal(opaque: opaque, hint: hint);

Future<void> loopBackVecGetTwinNormal({required List<Object> opaque , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueLoopBackVecGetTwinNormal(opaque: opaque, hint: hint);

/// [DartWrapObject] cannot be obtained
/// on a thread other than the thread it was created on.
Future<void> panicUnwrapDartOpaqueTwinNormal({required Object opaque , dynamic hint}) => RustLib.instance.api.crateApiDartOpaquePanicUnwrapDartOpaqueTwinNormal(opaque: opaque, hint: hint);

Future<DartOpaqueNestedTwinNormal> createNestedDartOpaqueTwinNormal({required Object opaque1 , required Object opaque2 , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueCreateNestedDartOpaqueTwinNormal(opaque1: opaque1, opaque2: opaque2, hint: hint);

Future<void> getNestedDartOpaqueTwinNormal({required DartOpaqueNestedTwinNormal opaque , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueGetNestedDartOpaqueTwinNormal(opaque: opaque, hint: hint);

Future<EnumDartOpaqueTwinNormal> createEnumDartOpaqueTwinNormal({required Object opaque , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueCreateEnumDartOpaqueTwinNormal(opaque: opaque, hint: hint);

Future<void> getEnumDartOpaqueTwinNormal({required EnumDartOpaqueTwinNormal opaque , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueGetEnumDartOpaqueTwinNormal(opaque: opaque, hint: hint);

Future<void> setStaticDartOpaqueTwinNormal({required int id , required Object opaque , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueSetStaticDartOpaqueTwinNormal(id: id, opaque: opaque, hint: hint);

Future<void> dropStaticDartOpaqueTwinNormal({required int id , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueDropStaticDartOpaqueTwinNormal(id: id, hint: hint);

Future<List<Object>> cloneDartOpaqueTwinNormal({required Object opaque , dynamic hint}) => RustLib.instance.api.crateApiDartOpaqueCloneDartOpaqueTwinNormal(opaque: opaque, hint: hint);

        
            class ObjectArray1 extends NonGrowableListView<Object> {
                static const arraySize = 1;

                @internal
                List<Object> get inner => _inner;
                final List<Object> _inner;

                ObjectArray1(this._inner)
                    : assert(_inner.length == arraySize),
                      super(_inner);
  
                ObjectArray1.init(Object fill): this(List<Object>.filled(arraySize,fill));
              }
            

class DartOpaqueNestedTwinNormal  {
                final Object first;
final Object second;

                const DartOpaqueNestedTwinNormal({required this.first ,required this.second ,});

                
                

                
        @override
        int get hashCode => first.hashCode^second.hashCode;
        

                
        @override
        bool operator ==(Object other) =>
            identical(this, other) ||
            other is DartOpaqueNestedTwinNormal &&
                runtimeType == other.runtimeType
                && first == other.first&& second == other.second;
        
            }

@freezed
                sealed class EnumDartOpaqueTwinNormal with _$EnumDartOpaqueTwinNormal  {
                    const EnumDartOpaqueTwinNormal._();

                     const factory EnumDartOpaqueTwinNormal.primitive(  int field0,) = EnumDartOpaqueTwinNormal_Primitive;
 const factory EnumDartOpaqueTwinNormal.opaque(  Object field0,) = EnumDartOpaqueTwinNormal_Opaque;

                    
                }
        