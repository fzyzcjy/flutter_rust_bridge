// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'enumeration_twin_sync.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$DistanceTwinSync {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function(double field0) map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function(double field0)? map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function(double field0)? map,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DistanceTwinSync_Unknown value) unknown,
    required TResult Function(DistanceTwinSync_Map value) map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DistanceTwinSync_Unknown value)? unknown,
    TResult? Function(DistanceTwinSync_Map value)? map,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DistanceTwinSync_Unknown value)? unknown,
    TResult Function(DistanceTwinSync_Map value)? map,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DistanceTwinSyncCopyWith<$Res> {
  factory $DistanceTwinSyncCopyWith(
          DistanceTwinSync value, $Res Function(DistanceTwinSync) then) =
      _$DistanceTwinSyncCopyWithImpl<$Res, DistanceTwinSync>;
}

/// @nodoc
class _$DistanceTwinSyncCopyWithImpl<$Res, $Val extends DistanceTwinSync>
    implements $DistanceTwinSyncCopyWith<$Res> {
  _$DistanceTwinSyncCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DistanceTwinSync_UnknownImplCopyWith<$Res> {
  factory _$$DistanceTwinSync_UnknownImplCopyWith(
          _$DistanceTwinSync_UnknownImpl value,
          $Res Function(_$DistanceTwinSync_UnknownImpl) then) =
      __$$DistanceTwinSync_UnknownImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DistanceTwinSync_UnknownImplCopyWithImpl<$Res>
    extends _$DistanceTwinSyncCopyWithImpl<$Res, _$DistanceTwinSync_UnknownImpl>
    implements _$$DistanceTwinSync_UnknownImplCopyWith<$Res> {
  __$$DistanceTwinSync_UnknownImplCopyWithImpl(
      _$DistanceTwinSync_UnknownImpl _value,
      $Res Function(_$DistanceTwinSync_UnknownImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DistanceTwinSync_UnknownImpl extends DistanceTwinSync_Unknown {
  const _$DistanceTwinSync_UnknownImpl() : super._();

  @override
  String toString() {
    return 'DistanceTwinSync.unknown()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DistanceTwinSync_UnknownImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function(double field0) map,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function(double field0)? map,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function(double field0)? map,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DistanceTwinSync_Unknown value) unknown,
    required TResult Function(DistanceTwinSync_Map value) map,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DistanceTwinSync_Unknown value)? unknown,
    TResult? Function(DistanceTwinSync_Map value)? map,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DistanceTwinSync_Unknown value)? unknown,
    TResult Function(DistanceTwinSync_Map value)? map,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class DistanceTwinSync_Unknown extends DistanceTwinSync {
  const factory DistanceTwinSync_Unknown() = _$DistanceTwinSync_UnknownImpl;
  const DistanceTwinSync_Unknown._() : super._();
}

/// @nodoc
abstract class _$$DistanceTwinSync_MapImplCopyWith<$Res> {
  factory _$$DistanceTwinSync_MapImplCopyWith(_$DistanceTwinSync_MapImpl value,
          $Res Function(_$DistanceTwinSync_MapImpl) then) =
      __$$DistanceTwinSync_MapImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$DistanceTwinSync_MapImplCopyWithImpl<$Res>
    extends _$DistanceTwinSyncCopyWithImpl<$Res, _$DistanceTwinSync_MapImpl>
    implements _$$DistanceTwinSync_MapImplCopyWith<$Res> {
  __$$DistanceTwinSync_MapImplCopyWithImpl(_$DistanceTwinSync_MapImpl _value,
      $Res Function(_$DistanceTwinSync_MapImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$DistanceTwinSync_MapImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$DistanceTwinSync_MapImpl extends DistanceTwinSync_Map {
  const _$DistanceTwinSync_MapImpl(this.field0) : super._();

  @override
  final double field0;

  @override
  String toString() {
    return 'DistanceTwinSync.map(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DistanceTwinSync_MapImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DistanceTwinSync_MapImplCopyWith<_$DistanceTwinSync_MapImpl>
      get copyWith =>
          __$$DistanceTwinSync_MapImplCopyWithImpl<_$DistanceTwinSync_MapImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function(double field0) map,
  }) {
    return map(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function(double field0)? map,
  }) {
    return map?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function(double field0)? map,
    required TResult orElse(),
  }) {
    if (map != null) {
      return map(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DistanceTwinSync_Unknown value) unknown,
    required TResult Function(DistanceTwinSync_Map value) map,
  }) {
    return map(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DistanceTwinSync_Unknown value)? unknown,
    TResult? Function(DistanceTwinSync_Map value)? map,
  }) {
    return map?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DistanceTwinSync_Unknown value)? unknown,
    TResult Function(DistanceTwinSync_Map value)? map,
    required TResult orElse(),
  }) {
    if (map != null) {
      return map(this);
    }
    return orElse();
  }
}

abstract class DistanceTwinSync_Map extends DistanceTwinSync {
  const factory DistanceTwinSync_Map(final double field0) =
      _$DistanceTwinSync_MapImpl;
  const DistanceTwinSync_Map._() : super._();

  double get field0;
  @JsonKey(ignore: true)
  _$$DistanceTwinSync_MapImplCopyWith<_$DistanceTwinSync_MapImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$EnumWithItemMixedTwinSync {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function(Uint8List field0) b,
    required TResult Function(String cField) c,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function(Uint8List field0)? b,
    TResult? Function(String cField)? c,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function(Uint8List field0)? b,
    TResult Function(String cField)? c,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemMixedTwinSync_A value) a,
    required TResult Function(EnumWithItemMixedTwinSync_B value) b,
    required TResult Function(EnumWithItemMixedTwinSync_C value) c,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemMixedTwinSync_A value)? a,
    TResult? Function(EnumWithItemMixedTwinSync_B value)? b,
    TResult? Function(EnumWithItemMixedTwinSync_C value)? c,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemMixedTwinSync_A value)? a,
    TResult Function(EnumWithItemMixedTwinSync_B value)? b,
    TResult Function(EnumWithItemMixedTwinSync_C value)? c,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EnumWithItemMixedTwinSyncCopyWith<$Res> {
  factory $EnumWithItemMixedTwinSyncCopyWith(EnumWithItemMixedTwinSync value,
          $Res Function(EnumWithItemMixedTwinSync) then) =
      _$EnumWithItemMixedTwinSyncCopyWithImpl<$Res, EnumWithItemMixedTwinSync>;
}

/// @nodoc
class _$EnumWithItemMixedTwinSyncCopyWithImpl<$Res,
        $Val extends EnumWithItemMixedTwinSync>
    implements $EnumWithItemMixedTwinSyncCopyWith<$Res> {
  _$EnumWithItemMixedTwinSyncCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EnumWithItemMixedTwinSync_AImplCopyWith<$Res> {
  factory _$$EnumWithItemMixedTwinSync_AImplCopyWith(
          _$EnumWithItemMixedTwinSync_AImpl value,
          $Res Function(_$EnumWithItemMixedTwinSync_AImpl) then) =
      __$$EnumWithItemMixedTwinSync_AImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EnumWithItemMixedTwinSync_AImplCopyWithImpl<$Res>
    extends _$EnumWithItemMixedTwinSyncCopyWithImpl<$Res,
        _$EnumWithItemMixedTwinSync_AImpl>
    implements _$$EnumWithItemMixedTwinSync_AImplCopyWith<$Res> {
  __$$EnumWithItemMixedTwinSync_AImplCopyWithImpl(
      _$EnumWithItemMixedTwinSync_AImpl _value,
      $Res Function(_$EnumWithItemMixedTwinSync_AImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EnumWithItemMixedTwinSync_AImpl extends EnumWithItemMixedTwinSync_A {
  const _$EnumWithItemMixedTwinSync_AImpl() : super._();

  @override
  String toString() {
    return 'EnumWithItemMixedTwinSync.a()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnumWithItemMixedTwinSync_AImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function(Uint8List field0) b,
    required TResult Function(String cField) c,
  }) {
    return a();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function(Uint8List field0)? b,
    TResult? Function(String cField)? c,
  }) {
    return a?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function(Uint8List field0)? b,
    TResult Function(String cField)? c,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemMixedTwinSync_A value) a,
    required TResult Function(EnumWithItemMixedTwinSync_B value) b,
    required TResult Function(EnumWithItemMixedTwinSync_C value) c,
  }) {
    return a(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemMixedTwinSync_A value)? a,
    TResult? Function(EnumWithItemMixedTwinSync_B value)? b,
    TResult? Function(EnumWithItemMixedTwinSync_C value)? c,
  }) {
    return a?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemMixedTwinSync_A value)? a,
    TResult Function(EnumWithItemMixedTwinSync_B value)? b,
    TResult Function(EnumWithItemMixedTwinSync_C value)? c,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a(this);
    }
    return orElse();
  }
}

abstract class EnumWithItemMixedTwinSync_A extends EnumWithItemMixedTwinSync {
  const factory EnumWithItemMixedTwinSync_A() =
      _$EnumWithItemMixedTwinSync_AImpl;
  const EnumWithItemMixedTwinSync_A._() : super._();
}

/// @nodoc
abstract class _$$EnumWithItemMixedTwinSync_BImplCopyWith<$Res> {
  factory _$$EnumWithItemMixedTwinSync_BImplCopyWith(
          _$EnumWithItemMixedTwinSync_BImpl value,
          $Res Function(_$EnumWithItemMixedTwinSync_BImpl) then) =
      __$$EnumWithItemMixedTwinSync_BImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class __$$EnumWithItemMixedTwinSync_BImplCopyWithImpl<$Res>
    extends _$EnumWithItemMixedTwinSyncCopyWithImpl<$Res,
        _$EnumWithItemMixedTwinSync_BImpl>
    implements _$$EnumWithItemMixedTwinSync_BImplCopyWith<$Res> {
  __$$EnumWithItemMixedTwinSync_BImplCopyWithImpl(
      _$EnumWithItemMixedTwinSync_BImpl _value,
      $Res Function(_$EnumWithItemMixedTwinSync_BImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$EnumWithItemMixedTwinSync_BImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$EnumWithItemMixedTwinSync_BImpl extends EnumWithItemMixedTwinSync_B {
  const _$EnumWithItemMixedTwinSync_BImpl(this.field0) : super._();

  @override
  final Uint8List field0;

  @override
  String toString() {
    return 'EnumWithItemMixedTwinSync.b(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnumWithItemMixedTwinSync_BImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EnumWithItemMixedTwinSync_BImplCopyWith<_$EnumWithItemMixedTwinSync_BImpl>
      get copyWith => __$$EnumWithItemMixedTwinSync_BImplCopyWithImpl<
          _$EnumWithItemMixedTwinSync_BImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function(Uint8List field0) b,
    required TResult Function(String cField) c,
  }) {
    return b(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function(Uint8List field0)? b,
    TResult? Function(String cField)? c,
  }) {
    return b?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function(Uint8List field0)? b,
    TResult Function(String cField)? c,
    required TResult orElse(),
  }) {
    if (b != null) {
      return b(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemMixedTwinSync_A value) a,
    required TResult Function(EnumWithItemMixedTwinSync_B value) b,
    required TResult Function(EnumWithItemMixedTwinSync_C value) c,
  }) {
    return b(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemMixedTwinSync_A value)? a,
    TResult? Function(EnumWithItemMixedTwinSync_B value)? b,
    TResult? Function(EnumWithItemMixedTwinSync_C value)? c,
  }) {
    return b?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemMixedTwinSync_A value)? a,
    TResult Function(EnumWithItemMixedTwinSync_B value)? b,
    TResult Function(EnumWithItemMixedTwinSync_C value)? c,
    required TResult orElse(),
  }) {
    if (b != null) {
      return b(this);
    }
    return orElse();
  }
}

abstract class EnumWithItemMixedTwinSync_B extends EnumWithItemMixedTwinSync {
  const factory EnumWithItemMixedTwinSync_B(final Uint8List field0) =
      _$EnumWithItemMixedTwinSync_BImpl;
  const EnumWithItemMixedTwinSync_B._() : super._();

  Uint8List get field0;
  @JsonKey(ignore: true)
  _$$EnumWithItemMixedTwinSync_BImplCopyWith<_$EnumWithItemMixedTwinSync_BImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EnumWithItemMixedTwinSync_CImplCopyWith<$Res> {
  factory _$$EnumWithItemMixedTwinSync_CImplCopyWith(
          _$EnumWithItemMixedTwinSync_CImpl value,
          $Res Function(_$EnumWithItemMixedTwinSync_CImpl) then) =
      __$$EnumWithItemMixedTwinSync_CImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String cField});
}

/// @nodoc
class __$$EnumWithItemMixedTwinSync_CImplCopyWithImpl<$Res>
    extends _$EnumWithItemMixedTwinSyncCopyWithImpl<$Res,
        _$EnumWithItemMixedTwinSync_CImpl>
    implements _$$EnumWithItemMixedTwinSync_CImplCopyWith<$Res> {
  __$$EnumWithItemMixedTwinSync_CImplCopyWithImpl(
      _$EnumWithItemMixedTwinSync_CImpl _value,
      $Res Function(_$EnumWithItemMixedTwinSync_CImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cField = null,
  }) {
    return _then(_$EnumWithItemMixedTwinSync_CImpl(
      cField: null == cField
          ? _value.cField
          : cField // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EnumWithItemMixedTwinSync_CImpl extends EnumWithItemMixedTwinSync_C {
  const _$EnumWithItemMixedTwinSync_CImpl({required this.cField}) : super._();

  @override
  final String cField;

  @override
  String toString() {
    return 'EnumWithItemMixedTwinSync.c(cField: $cField)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnumWithItemMixedTwinSync_CImpl &&
            (identical(other.cField, cField) || other.cField == cField));
  }

  @override
  int get hashCode => Object.hash(runtimeType, cField);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EnumWithItemMixedTwinSync_CImplCopyWith<_$EnumWithItemMixedTwinSync_CImpl>
      get copyWith => __$$EnumWithItemMixedTwinSync_CImplCopyWithImpl<
          _$EnumWithItemMixedTwinSync_CImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() a,
    required TResult Function(Uint8List field0) b,
    required TResult Function(String cField) c,
  }) {
    return c(cField);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? a,
    TResult? Function(Uint8List field0)? b,
    TResult? Function(String cField)? c,
  }) {
    return c?.call(cField);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? a,
    TResult Function(Uint8List field0)? b,
    TResult Function(String cField)? c,
    required TResult orElse(),
  }) {
    if (c != null) {
      return c(cField);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemMixedTwinSync_A value) a,
    required TResult Function(EnumWithItemMixedTwinSync_B value) b,
    required TResult Function(EnumWithItemMixedTwinSync_C value) c,
  }) {
    return c(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemMixedTwinSync_A value)? a,
    TResult? Function(EnumWithItemMixedTwinSync_B value)? b,
    TResult? Function(EnumWithItemMixedTwinSync_C value)? c,
  }) {
    return c?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemMixedTwinSync_A value)? a,
    TResult Function(EnumWithItemMixedTwinSync_B value)? b,
    TResult Function(EnumWithItemMixedTwinSync_C value)? c,
    required TResult orElse(),
  }) {
    if (c != null) {
      return c(this);
    }
    return orElse();
  }
}

abstract class EnumWithItemMixedTwinSync_C extends EnumWithItemMixedTwinSync {
  const factory EnumWithItemMixedTwinSync_C({required final String cField}) =
      _$EnumWithItemMixedTwinSync_CImpl;
  const EnumWithItemMixedTwinSync_C._() : super._();

  String get cField;
  @JsonKey(ignore: true)
  _$$EnumWithItemMixedTwinSync_CImplCopyWith<_$EnumWithItemMixedTwinSync_CImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$EnumWithItemStructTwinSync {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List aField) a,
    required TResult Function(Int32List bField) b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List aField)? a,
    TResult? Function(Int32List bField)? b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List aField)? a,
    TResult Function(Int32List bField)? b,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemStructTwinSync_A value) a,
    required TResult Function(EnumWithItemStructTwinSync_B value) b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemStructTwinSync_A value)? a,
    TResult? Function(EnumWithItemStructTwinSync_B value)? b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemStructTwinSync_A value)? a,
    TResult Function(EnumWithItemStructTwinSync_B value)? b,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EnumWithItemStructTwinSyncCopyWith<$Res> {
  factory $EnumWithItemStructTwinSyncCopyWith(EnumWithItemStructTwinSync value,
          $Res Function(EnumWithItemStructTwinSync) then) =
      _$EnumWithItemStructTwinSyncCopyWithImpl<$Res,
          EnumWithItemStructTwinSync>;
}

/// @nodoc
class _$EnumWithItemStructTwinSyncCopyWithImpl<$Res,
        $Val extends EnumWithItemStructTwinSync>
    implements $EnumWithItemStructTwinSyncCopyWith<$Res> {
  _$EnumWithItemStructTwinSyncCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EnumWithItemStructTwinSync_AImplCopyWith<$Res> {
  factory _$$EnumWithItemStructTwinSync_AImplCopyWith(
          _$EnumWithItemStructTwinSync_AImpl value,
          $Res Function(_$EnumWithItemStructTwinSync_AImpl) then) =
      __$$EnumWithItemStructTwinSync_AImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List aField});
}

/// @nodoc
class __$$EnumWithItemStructTwinSync_AImplCopyWithImpl<$Res>
    extends _$EnumWithItemStructTwinSyncCopyWithImpl<$Res,
        _$EnumWithItemStructTwinSync_AImpl>
    implements _$$EnumWithItemStructTwinSync_AImplCopyWith<$Res> {
  __$$EnumWithItemStructTwinSync_AImplCopyWithImpl(
      _$EnumWithItemStructTwinSync_AImpl _value,
      $Res Function(_$EnumWithItemStructTwinSync_AImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? aField = null,
  }) {
    return _then(_$EnumWithItemStructTwinSync_AImpl(
      aField: null == aField
          ? _value.aField
          : aField // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$EnumWithItemStructTwinSync_AImpl extends EnumWithItemStructTwinSync_A {
  const _$EnumWithItemStructTwinSync_AImpl({required this.aField}) : super._();

  @override
  final Uint8List aField;

  @override
  String toString() {
    return 'EnumWithItemStructTwinSync.a(aField: $aField)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnumWithItemStructTwinSync_AImpl &&
            const DeepCollectionEquality().equals(other.aField, aField));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(aField));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EnumWithItemStructTwinSync_AImplCopyWith<
          _$EnumWithItemStructTwinSync_AImpl>
      get copyWith => __$$EnumWithItemStructTwinSync_AImplCopyWithImpl<
          _$EnumWithItemStructTwinSync_AImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List aField) a,
    required TResult Function(Int32List bField) b,
  }) {
    return a(aField);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List aField)? a,
    TResult? Function(Int32List bField)? b,
  }) {
    return a?.call(aField);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List aField)? a,
    TResult Function(Int32List bField)? b,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a(aField);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemStructTwinSync_A value) a,
    required TResult Function(EnumWithItemStructTwinSync_B value) b,
  }) {
    return a(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemStructTwinSync_A value)? a,
    TResult? Function(EnumWithItemStructTwinSync_B value)? b,
  }) {
    return a?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemStructTwinSync_A value)? a,
    TResult Function(EnumWithItemStructTwinSync_B value)? b,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a(this);
    }
    return orElse();
  }
}

abstract class EnumWithItemStructTwinSync_A extends EnumWithItemStructTwinSync {
  const factory EnumWithItemStructTwinSync_A(
      {required final Uint8List aField}) = _$EnumWithItemStructTwinSync_AImpl;
  const EnumWithItemStructTwinSync_A._() : super._();

  Uint8List get aField;
  @JsonKey(ignore: true)
  _$$EnumWithItemStructTwinSync_AImplCopyWith<
          _$EnumWithItemStructTwinSync_AImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EnumWithItemStructTwinSync_BImplCopyWith<$Res> {
  factory _$$EnumWithItemStructTwinSync_BImplCopyWith(
          _$EnumWithItemStructTwinSync_BImpl value,
          $Res Function(_$EnumWithItemStructTwinSync_BImpl) then) =
      __$$EnumWithItemStructTwinSync_BImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Int32List bField});
}

/// @nodoc
class __$$EnumWithItemStructTwinSync_BImplCopyWithImpl<$Res>
    extends _$EnumWithItemStructTwinSyncCopyWithImpl<$Res,
        _$EnumWithItemStructTwinSync_BImpl>
    implements _$$EnumWithItemStructTwinSync_BImplCopyWith<$Res> {
  __$$EnumWithItemStructTwinSync_BImplCopyWithImpl(
      _$EnumWithItemStructTwinSync_BImpl _value,
      $Res Function(_$EnumWithItemStructTwinSync_BImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bField = null,
  }) {
    return _then(_$EnumWithItemStructTwinSync_BImpl(
      bField: null == bField
          ? _value.bField
          : bField // ignore: cast_nullable_to_non_nullable
              as Int32List,
    ));
  }
}

/// @nodoc

class _$EnumWithItemStructTwinSync_BImpl extends EnumWithItemStructTwinSync_B {
  const _$EnumWithItemStructTwinSync_BImpl({required this.bField}) : super._();

  @override
  final Int32List bField;

  @override
  String toString() {
    return 'EnumWithItemStructTwinSync.b(bField: $bField)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnumWithItemStructTwinSync_BImpl &&
            const DeepCollectionEquality().equals(other.bField, bField));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(bField));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EnumWithItemStructTwinSync_BImplCopyWith<
          _$EnumWithItemStructTwinSync_BImpl>
      get copyWith => __$$EnumWithItemStructTwinSync_BImplCopyWithImpl<
          _$EnumWithItemStructTwinSync_BImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List aField) a,
    required TResult Function(Int32List bField) b,
  }) {
    return b(bField);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List aField)? a,
    TResult? Function(Int32List bField)? b,
  }) {
    return b?.call(bField);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List aField)? a,
    TResult Function(Int32List bField)? b,
    required TResult orElse(),
  }) {
    if (b != null) {
      return b(bField);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemStructTwinSync_A value) a,
    required TResult Function(EnumWithItemStructTwinSync_B value) b,
  }) {
    return b(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemStructTwinSync_A value)? a,
    TResult? Function(EnumWithItemStructTwinSync_B value)? b,
  }) {
    return b?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemStructTwinSync_A value)? a,
    TResult Function(EnumWithItemStructTwinSync_B value)? b,
    required TResult orElse(),
  }) {
    if (b != null) {
      return b(this);
    }
    return orElse();
  }
}

abstract class EnumWithItemStructTwinSync_B extends EnumWithItemStructTwinSync {
  const factory EnumWithItemStructTwinSync_B(
      {required final Int32List bField}) = _$EnumWithItemStructTwinSync_BImpl;
  const EnumWithItemStructTwinSync_B._() : super._();

  Int32List get bField;
  @JsonKey(ignore: true)
  _$$EnumWithItemStructTwinSync_BImplCopyWith<
          _$EnumWithItemStructTwinSync_BImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$EnumWithItemTupleTwinSync {
  List<int> get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List field0) a,
    required TResult Function(Int32List field0) b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List field0)? a,
    TResult? Function(Int32List field0)? b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List field0)? a,
    TResult Function(Int32List field0)? b,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemTupleTwinSync_A value) a,
    required TResult Function(EnumWithItemTupleTwinSync_B value) b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemTupleTwinSync_A value)? a,
    TResult? Function(EnumWithItemTupleTwinSync_B value)? b,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemTupleTwinSync_A value)? a,
    TResult Function(EnumWithItemTupleTwinSync_B value)? b,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EnumWithItemTupleTwinSyncCopyWith<$Res> {
  factory $EnumWithItemTupleTwinSyncCopyWith(EnumWithItemTupleTwinSync value,
          $Res Function(EnumWithItemTupleTwinSync) then) =
      _$EnumWithItemTupleTwinSyncCopyWithImpl<$Res, EnumWithItemTupleTwinSync>;
}

/// @nodoc
class _$EnumWithItemTupleTwinSyncCopyWithImpl<$Res,
        $Val extends EnumWithItemTupleTwinSync>
    implements $EnumWithItemTupleTwinSyncCopyWith<$Res> {
  _$EnumWithItemTupleTwinSyncCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EnumWithItemTupleTwinSync_AImplCopyWith<$Res> {
  factory _$$EnumWithItemTupleTwinSync_AImplCopyWith(
          _$EnumWithItemTupleTwinSync_AImpl value,
          $Res Function(_$EnumWithItemTupleTwinSync_AImpl) then) =
      __$$EnumWithItemTupleTwinSync_AImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class __$$EnumWithItemTupleTwinSync_AImplCopyWithImpl<$Res>
    extends _$EnumWithItemTupleTwinSyncCopyWithImpl<$Res,
        _$EnumWithItemTupleTwinSync_AImpl>
    implements _$$EnumWithItemTupleTwinSync_AImplCopyWith<$Res> {
  __$$EnumWithItemTupleTwinSync_AImplCopyWithImpl(
      _$EnumWithItemTupleTwinSync_AImpl _value,
      $Res Function(_$EnumWithItemTupleTwinSync_AImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$EnumWithItemTupleTwinSync_AImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$EnumWithItemTupleTwinSync_AImpl extends EnumWithItemTupleTwinSync_A {
  const _$EnumWithItemTupleTwinSync_AImpl(this.field0) : super._();

  @override
  final Uint8List field0;

  @override
  String toString() {
    return 'EnumWithItemTupleTwinSync.a(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnumWithItemTupleTwinSync_AImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EnumWithItemTupleTwinSync_AImplCopyWith<_$EnumWithItemTupleTwinSync_AImpl>
      get copyWith => __$$EnumWithItemTupleTwinSync_AImplCopyWithImpl<
          _$EnumWithItemTupleTwinSync_AImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List field0) a,
    required TResult Function(Int32List field0) b,
  }) {
    return a(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List field0)? a,
    TResult? Function(Int32List field0)? b,
  }) {
    return a?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List field0)? a,
    TResult Function(Int32List field0)? b,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemTupleTwinSync_A value) a,
    required TResult Function(EnumWithItemTupleTwinSync_B value) b,
  }) {
    return a(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemTupleTwinSync_A value)? a,
    TResult? Function(EnumWithItemTupleTwinSync_B value)? b,
  }) {
    return a?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemTupleTwinSync_A value)? a,
    TResult Function(EnumWithItemTupleTwinSync_B value)? b,
    required TResult orElse(),
  }) {
    if (a != null) {
      return a(this);
    }
    return orElse();
  }
}

abstract class EnumWithItemTupleTwinSync_A extends EnumWithItemTupleTwinSync {
  const factory EnumWithItemTupleTwinSync_A(final Uint8List field0) =
      _$EnumWithItemTupleTwinSync_AImpl;
  const EnumWithItemTupleTwinSync_A._() : super._();

  @override
  Uint8List get field0;
  @JsonKey(ignore: true)
  _$$EnumWithItemTupleTwinSync_AImplCopyWith<_$EnumWithItemTupleTwinSync_AImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EnumWithItemTupleTwinSync_BImplCopyWith<$Res> {
  factory _$$EnumWithItemTupleTwinSync_BImplCopyWith(
          _$EnumWithItemTupleTwinSync_BImpl value,
          $Res Function(_$EnumWithItemTupleTwinSync_BImpl) then) =
      __$$EnumWithItemTupleTwinSync_BImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Int32List field0});
}

/// @nodoc
class __$$EnumWithItemTupleTwinSync_BImplCopyWithImpl<$Res>
    extends _$EnumWithItemTupleTwinSyncCopyWithImpl<$Res,
        _$EnumWithItemTupleTwinSync_BImpl>
    implements _$$EnumWithItemTupleTwinSync_BImplCopyWith<$Res> {
  __$$EnumWithItemTupleTwinSync_BImplCopyWithImpl(
      _$EnumWithItemTupleTwinSync_BImpl _value,
      $Res Function(_$EnumWithItemTupleTwinSync_BImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$EnumWithItemTupleTwinSync_BImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Int32List,
    ));
  }
}

/// @nodoc

class _$EnumWithItemTupleTwinSync_BImpl extends EnumWithItemTupleTwinSync_B {
  const _$EnumWithItemTupleTwinSync_BImpl(this.field0) : super._();

  @override
  final Int32List field0;

  @override
  String toString() {
    return 'EnumWithItemTupleTwinSync.b(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnumWithItemTupleTwinSync_BImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EnumWithItemTupleTwinSync_BImplCopyWith<_$EnumWithItemTupleTwinSync_BImpl>
      get copyWith => __$$EnumWithItemTupleTwinSync_BImplCopyWithImpl<
          _$EnumWithItemTupleTwinSync_BImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Uint8List field0) a,
    required TResult Function(Int32List field0) b,
  }) {
    return b(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Uint8List field0)? a,
    TResult? Function(Int32List field0)? b,
  }) {
    return b?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Uint8List field0)? a,
    TResult Function(Int32List field0)? b,
    required TResult orElse(),
  }) {
    if (b != null) {
      return b(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(EnumWithItemTupleTwinSync_A value) a,
    required TResult Function(EnumWithItemTupleTwinSync_B value) b,
  }) {
    return b(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(EnumWithItemTupleTwinSync_A value)? a,
    TResult? Function(EnumWithItemTupleTwinSync_B value)? b,
  }) {
    return b?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(EnumWithItemTupleTwinSync_A value)? a,
    TResult Function(EnumWithItemTupleTwinSync_B value)? b,
    required TResult orElse(),
  }) {
    if (b != null) {
      return b(this);
    }
    return orElse();
  }
}

abstract class EnumWithItemTupleTwinSync_B extends EnumWithItemTupleTwinSync {
  const factory EnumWithItemTupleTwinSync_B(final Int32List field0) =
      _$EnumWithItemTupleTwinSync_BImpl;
  const EnumWithItemTupleTwinSync_B._() : super._();

  @override
  Int32List get field0;
  @JsonKey(ignore: true)
  _$$EnumWithItemTupleTwinSync_BImplCopyWith<_$EnumWithItemTupleTwinSync_BImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$KitchenSinkTwinSync {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(int int32, double float64, bool boolean)
        primitives,
    required TResult Function(int field0, KitchenSinkTwinSync field1) nested,
    required TResult Function(int? field0, int? field1) optional,
    required TResult Function(Uint8List field0) buffer,
    required TResult Function(WeekdaysTwinSync field0) enums,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(int int32, double float64, bool boolean)? primitives,
    TResult? Function(int field0, KitchenSinkTwinSync field1)? nested,
    TResult? Function(int? field0, int? field1)? optional,
    TResult? Function(Uint8List field0)? buffer,
    TResult? Function(WeekdaysTwinSync field0)? enums,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(int int32, double float64, bool boolean)? primitives,
    TResult Function(int field0, KitchenSinkTwinSync field1)? nested,
    TResult Function(int? field0, int? field1)? optional,
    TResult Function(Uint8List field0)? buffer,
    TResult Function(WeekdaysTwinSync field0)? enums,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(KitchenSinkTwinSync_Empty value) empty,
    required TResult Function(KitchenSinkTwinSync_Primitives value) primitives,
    required TResult Function(KitchenSinkTwinSync_Nested value) nested,
    required TResult Function(KitchenSinkTwinSync_Optional value) optional,
    required TResult Function(KitchenSinkTwinSync_Buffer value) buffer,
    required TResult Function(KitchenSinkTwinSync_Enums value) enums,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(KitchenSinkTwinSync_Empty value)? empty,
    TResult? Function(KitchenSinkTwinSync_Primitives value)? primitives,
    TResult? Function(KitchenSinkTwinSync_Nested value)? nested,
    TResult? Function(KitchenSinkTwinSync_Optional value)? optional,
    TResult? Function(KitchenSinkTwinSync_Buffer value)? buffer,
    TResult? Function(KitchenSinkTwinSync_Enums value)? enums,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(KitchenSinkTwinSync_Empty value)? empty,
    TResult Function(KitchenSinkTwinSync_Primitives value)? primitives,
    TResult Function(KitchenSinkTwinSync_Nested value)? nested,
    TResult Function(KitchenSinkTwinSync_Optional value)? optional,
    TResult Function(KitchenSinkTwinSync_Buffer value)? buffer,
    TResult Function(KitchenSinkTwinSync_Enums value)? enums,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $KitchenSinkTwinSyncCopyWith<$Res> {
  factory $KitchenSinkTwinSyncCopyWith(
          KitchenSinkTwinSync value, $Res Function(KitchenSinkTwinSync) then) =
      _$KitchenSinkTwinSyncCopyWithImpl<$Res, KitchenSinkTwinSync>;
}

/// @nodoc
class _$KitchenSinkTwinSyncCopyWithImpl<$Res, $Val extends KitchenSinkTwinSync>
    implements $KitchenSinkTwinSyncCopyWith<$Res> {
  _$KitchenSinkTwinSyncCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$KitchenSinkTwinSync_EmptyImplCopyWith<$Res> {
  factory _$$KitchenSinkTwinSync_EmptyImplCopyWith(
          _$KitchenSinkTwinSync_EmptyImpl value,
          $Res Function(_$KitchenSinkTwinSync_EmptyImpl) then) =
      __$$KitchenSinkTwinSync_EmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$KitchenSinkTwinSync_EmptyImplCopyWithImpl<$Res>
    extends _$KitchenSinkTwinSyncCopyWithImpl<$Res,
        _$KitchenSinkTwinSync_EmptyImpl>
    implements _$$KitchenSinkTwinSync_EmptyImplCopyWith<$Res> {
  __$$KitchenSinkTwinSync_EmptyImplCopyWithImpl(
      _$KitchenSinkTwinSync_EmptyImpl _value,
      $Res Function(_$KitchenSinkTwinSync_EmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$KitchenSinkTwinSync_EmptyImpl extends KitchenSinkTwinSync_Empty {
  const _$KitchenSinkTwinSync_EmptyImpl() : super._();

  @override
  String toString() {
    return 'KitchenSinkTwinSync.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KitchenSinkTwinSync_EmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(int int32, double float64, bool boolean)
        primitives,
    required TResult Function(int field0, KitchenSinkTwinSync field1) nested,
    required TResult Function(int? field0, int? field1) optional,
    required TResult Function(Uint8List field0) buffer,
    required TResult Function(WeekdaysTwinSync field0) enums,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(int int32, double float64, bool boolean)? primitives,
    TResult? Function(int field0, KitchenSinkTwinSync field1)? nested,
    TResult? Function(int? field0, int? field1)? optional,
    TResult? Function(Uint8List field0)? buffer,
    TResult? Function(WeekdaysTwinSync field0)? enums,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(int int32, double float64, bool boolean)? primitives,
    TResult Function(int field0, KitchenSinkTwinSync field1)? nested,
    TResult Function(int? field0, int? field1)? optional,
    TResult Function(Uint8List field0)? buffer,
    TResult Function(WeekdaysTwinSync field0)? enums,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(KitchenSinkTwinSync_Empty value) empty,
    required TResult Function(KitchenSinkTwinSync_Primitives value) primitives,
    required TResult Function(KitchenSinkTwinSync_Nested value) nested,
    required TResult Function(KitchenSinkTwinSync_Optional value) optional,
    required TResult Function(KitchenSinkTwinSync_Buffer value) buffer,
    required TResult Function(KitchenSinkTwinSync_Enums value) enums,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(KitchenSinkTwinSync_Empty value)? empty,
    TResult? Function(KitchenSinkTwinSync_Primitives value)? primitives,
    TResult? Function(KitchenSinkTwinSync_Nested value)? nested,
    TResult? Function(KitchenSinkTwinSync_Optional value)? optional,
    TResult? Function(KitchenSinkTwinSync_Buffer value)? buffer,
    TResult? Function(KitchenSinkTwinSync_Enums value)? enums,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(KitchenSinkTwinSync_Empty value)? empty,
    TResult Function(KitchenSinkTwinSync_Primitives value)? primitives,
    TResult Function(KitchenSinkTwinSync_Nested value)? nested,
    TResult Function(KitchenSinkTwinSync_Optional value)? optional,
    TResult Function(KitchenSinkTwinSync_Buffer value)? buffer,
    TResult Function(KitchenSinkTwinSync_Enums value)? enums,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class KitchenSinkTwinSync_Empty extends KitchenSinkTwinSync {
  const factory KitchenSinkTwinSync_Empty() = _$KitchenSinkTwinSync_EmptyImpl;
  const KitchenSinkTwinSync_Empty._() : super._();
}

/// @nodoc
abstract class _$$KitchenSinkTwinSync_PrimitivesImplCopyWith<$Res> {
  factory _$$KitchenSinkTwinSync_PrimitivesImplCopyWith(
          _$KitchenSinkTwinSync_PrimitivesImpl value,
          $Res Function(_$KitchenSinkTwinSync_PrimitivesImpl) then) =
      __$$KitchenSinkTwinSync_PrimitivesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int int32, double float64, bool boolean});
}

/// @nodoc
class __$$KitchenSinkTwinSync_PrimitivesImplCopyWithImpl<$Res>
    extends _$KitchenSinkTwinSyncCopyWithImpl<$Res,
        _$KitchenSinkTwinSync_PrimitivesImpl>
    implements _$$KitchenSinkTwinSync_PrimitivesImplCopyWith<$Res> {
  __$$KitchenSinkTwinSync_PrimitivesImplCopyWithImpl(
      _$KitchenSinkTwinSync_PrimitivesImpl _value,
      $Res Function(_$KitchenSinkTwinSync_PrimitivesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? int32 = null,
    Object? float64 = null,
    Object? boolean = null,
  }) {
    return _then(_$KitchenSinkTwinSync_PrimitivesImpl(
      int32: null == int32
          ? _value.int32
          : int32 // ignore: cast_nullable_to_non_nullable
              as int,
      float64: null == float64
          ? _value.float64
          : float64 // ignore: cast_nullable_to_non_nullable
              as double,
      boolean: null == boolean
          ? _value.boolean
          : boolean // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$KitchenSinkTwinSync_PrimitivesImpl
    extends KitchenSinkTwinSync_Primitives {
  const _$KitchenSinkTwinSync_PrimitivesImpl(
      {this.int32 = -1, required this.float64, required this.boolean})
      : super._();

  /// Dart field comment
  @override
  @JsonKey()
  final int int32;
  @override
  final double float64;
  @override
  final bool boolean;

  @override
  String toString() {
    return 'KitchenSinkTwinSync.primitives(int32: $int32, float64: $float64, boolean: $boolean)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KitchenSinkTwinSync_PrimitivesImpl &&
            (identical(other.int32, int32) || other.int32 == int32) &&
            (identical(other.float64, float64) || other.float64 == float64) &&
            (identical(other.boolean, boolean) || other.boolean == boolean));
  }

  @override
  int get hashCode => Object.hash(runtimeType, int32, float64, boolean);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$KitchenSinkTwinSync_PrimitivesImplCopyWith<
          _$KitchenSinkTwinSync_PrimitivesImpl>
      get copyWith => __$$KitchenSinkTwinSync_PrimitivesImplCopyWithImpl<
          _$KitchenSinkTwinSync_PrimitivesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(int int32, double float64, bool boolean)
        primitives,
    required TResult Function(int field0, KitchenSinkTwinSync field1) nested,
    required TResult Function(int? field0, int? field1) optional,
    required TResult Function(Uint8List field0) buffer,
    required TResult Function(WeekdaysTwinSync field0) enums,
  }) {
    return primitives(int32, float64, boolean);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(int int32, double float64, bool boolean)? primitives,
    TResult? Function(int field0, KitchenSinkTwinSync field1)? nested,
    TResult? Function(int? field0, int? field1)? optional,
    TResult? Function(Uint8List field0)? buffer,
    TResult? Function(WeekdaysTwinSync field0)? enums,
  }) {
    return primitives?.call(int32, float64, boolean);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(int int32, double float64, bool boolean)? primitives,
    TResult Function(int field0, KitchenSinkTwinSync field1)? nested,
    TResult Function(int? field0, int? field1)? optional,
    TResult Function(Uint8List field0)? buffer,
    TResult Function(WeekdaysTwinSync field0)? enums,
    required TResult orElse(),
  }) {
    if (primitives != null) {
      return primitives(int32, float64, boolean);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(KitchenSinkTwinSync_Empty value) empty,
    required TResult Function(KitchenSinkTwinSync_Primitives value) primitives,
    required TResult Function(KitchenSinkTwinSync_Nested value) nested,
    required TResult Function(KitchenSinkTwinSync_Optional value) optional,
    required TResult Function(KitchenSinkTwinSync_Buffer value) buffer,
    required TResult Function(KitchenSinkTwinSync_Enums value) enums,
  }) {
    return primitives(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(KitchenSinkTwinSync_Empty value)? empty,
    TResult? Function(KitchenSinkTwinSync_Primitives value)? primitives,
    TResult? Function(KitchenSinkTwinSync_Nested value)? nested,
    TResult? Function(KitchenSinkTwinSync_Optional value)? optional,
    TResult? Function(KitchenSinkTwinSync_Buffer value)? buffer,
    TResult? Function(KitchenSinkTwinSync_Enums value)? enums,
  }) {
    return primitives?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(KitchenSinkTwinSync_Empty value)? empty,
    TResult Function(KitchenSinkTwinSync_Primitives value)? primitives,
    TResult Function(KitchenSinkTwinSync_Nested value)? nested,
    TResult Function(KitchenSinkTwinSync_Optional value)? optional,
    TResult Function(KitchenSinkTwinSync_Buffer value)? buffer,
    TResult Function(KitchenSinkTwinSync_Enums value)? enums,
    required TResult orElse(),
  }) {
    if (primitives != null) {
      return primitives(this);
    }
    return orElse();
  }
}

abstract class KitchenSinkTwinSync_Primitives extends KitchenSinkTwinSync {
  const factory KitchenSinkTwinSync_Primitives(
      {final int int32,
      required final double float64,
      required final bool boolean}) = _$KitchenSinkTwinSync_PrimitivesImpl;
  const KitchenSinkTwinSync_Primitives._() : super._();

  /// Dart field comment
  int get int32;
  double get float64;
  bool get boolean;
  @JsonKey(ignore: true)
  _$$KitchenSinkTwinSync_PrimitivesImplCopyWith<
          _$KitchenSinkTwinSync_PrimitivesImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$KitchenSinkTwinSync_NestedImplCopyWith<$Res> {
  factory _$$KitchenSinkTwinSync_NestedImplCopyWith(
          _$KitchenSinkTwinSync_NestedImpl value,
          $Res Function(_$KitchenSinkTwinSync_NestedImpl) then) =
      __$$KitchenSinkTwinSync_NestedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0, KitchenSinkTwinSync field1});

  $KitchenSinkTwinSyncCopyWith<$Res> get field1;
}

/// @nodoc
class __$$KitchenSinkTwinSync_NestedImplCopyWithImpl<$Res>
    extends _$KitchenSinkTwinSyncCopyWithImpl<$Res,
        _$KitchenSinkTwinSync_NestedImpl>
    implements _$$KitchenSinkTwinSync_NestedImplCopyWith<$Res> {
  __$$KitchenSinkTwinSync_NestedImplCopyWithImpl(
      _$KitchenSinkTwinSync_NestedImpl _value,
      $Res Function(_$KitchenSinkTwinSync_NestedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$KitchenSinkTwinSync_NestedImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as KitchenSinkTwinSync,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $KitchenSinkTwinSyncCopyWith<$Res> get field1 {
    return $KitchenSinkTwinSyncCopyWith<$Res>(_value.field1, (value) {
      return _then(_value.copyWith(field1: value));
    });
  }
}

/// @nodoc

class _$KitchenSinkTwinSync_NestedImpl extends KitchenSinkTwinSync_Nested {
  const _$KitchenSinkTwinSync_NestedImpl(this.field0,
      [this.field1 = const KitchenSinkTwinSync.empty()])
      : super._();

  @override
  final int field0;
  @override
  @JsonKey()
  final KitchenSinkTwinSync field1;

  @override
  String toString() {
    return 'KitchenSinkTwinSync.nested(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KitchenSinkTwinSync_NestedImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$KitchenSinkTwinSync_NestedImplCopyWith<_$KitchenSinkTwinSync_NestedImpl>
      get copyWith => __$$KitchenSinkTwinSync_NestedImplCopyWithImpl<
          _$KitchenSinkTwinSync_NestedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(int int32, double float64, bool boolean)
        primitives,
    required TResult Function(int field0, KitchenSinkTwinSync field1) nested,
    required TResult Function(int? field0, int? field1) optional,
    required TResult Function(Uint8List field0) buffer,
    required TResult Function(WeekdaysTwinSync field0) enums,
  }) {
    return nested(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(int int32, double float64, bool boolean)? primitives,
    TResult? Function(int field0, KitchenSinkTwinSync field1)? nested,
    TResult? Function(int? field0, int? field1)? optional,
    TResult? Function(Uint8List field0)? buffer,
    TResult? Function(WeekdaysTwinSync field0)? enums,
  }) {
    return nested?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(int int32, double float64, bool boolean)? primitives,
    TResult Function(int field0, KitchenSinkTwinSync field1)? nested,
    TResult Function(int? field0, int? field1)? optional,
    TResult Function(Uint8List field0)? buffer,
    TResult Function(WeekdaysTwinSync field0)? enums,
    required TResult orElse(),
  }) {
    if (nested != null) {
      return nested(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(KitchenSinkTwinSync_Empty value) empty,
    required TResult Function(KitchenSinkTwinSync_Primitives value) primitives,
    required TResult Function(KitchenSinkTwinSync_Nested value) nested,
    required TResult Function(KitchenSinkTwinSync_Optional value) optional,
    required TResult Function(KitchenSinkTwinSync_Buffer value) buffer,
    required TResult Function(KitchenSinkTwinSync_Enums value) enums,
  }) {
    return nested(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(KitchenSinkTwinSync_Empty value)? empty,
    TResult? Function(KitchenSinkTwinSync_Primitives value)? primitives,
    TResult? Function(KitchenSinkTwinSync_Nested value)? nested,
    TResult? Function(KitchenSinkTwinSync_Optional value)? optional,
    TResult? Function(KitchenSinkTwinSync_Buffer value)? buffer,
    TResult? Function(KitchenSinkTwinSync_Enums value)? enums,
  }) {
    return nested?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(KitchenSinkTwinSync_Empty value)? empty,
    TResult Function(KitchenSinkTwinSync_Primitives value)? primitives,
    TResult Function(KitchenSinkTwinSync_Nested value)? nested,
    TResult Function(KitchenSinkTwinSync_Optional value)? optional,
    TResult Function(KitchenSinkTwinSync_Buffer value)? buffer,
    TResult Function(KitchenSinkTwinSync_Enums value)? enums,
    required TResult orElse(),
  }) {
    if (nested != null) {
      return nested(this);
    }
    return orElse();
  }
}

abstract class KitchenSinkTwinSync_Nested extends KitchenSinkTwinSync {
  const factory KitchenSinkTwinSync_Nested(final int field0,
      [final KitchenSinkTwinSync field1]) = _$KitchenSinkTwinSync_NestedImpl;
  const KitchenSinkTwinSync_Nested._() : super._();

  int get field0;
  KitchenSinkTwinSync get field1;
  @JsonKey(ignore: true)
  _$$KitchenSinkTwinSync_NestedImplCopyWith<_$KitchenSinkTwinSync_NestedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$KitchenSinkTwinSync_OptionalImplCopyWith<$Res> {
  factory _$$KitchenSinkTwinSync_OptionalImplCopyWith(
          _$KitchenSinkTwinSync_OptionalImpl value,
          $Res Function(_$KitchenSinkTwinSync_OptionalImpl) then) =
      __$$KitchenSinkTwinSync_OptionalImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int? field0, int? field1});
}

/// @nodoc
class __$$KitchenSinkTwinSync_OptionalImplCopyWithImpl<$Res>
    extends _$KitchenSinkTwinSyncCopyWithImpl<$Res,
        _$KitchenSinkTwinSync_OptionalImpl>
    implements _$$KitchenSinkTwinSync_OptionalImplCopyWith<$Res> {
  __$$KitchenSinkTwinSync_OptionalImplCopyWithImpl(
      _$KitchenSinkTwinSync_OptionalImpl _value,
      $Res Function(_$KitchenSinkTwinSync_OptionalImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = freezed,
    Object? field1 = freezed,
  }) {
    return _then(_$KitchenSinkTwinSync_OptionalImpl(
      freezed == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int?,
      freezed == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$KitchenSinkTwinSync_OptionalImpl extends KitchenSinkTwinSync_Optional {
  const _$KitchenSinkTwinSync_OptionalImpl([this.field0 = -1, this.field1])
      : super._();

  /// Comment on anonymous field
  @override
  @JsonKey()
  final int? field0;
  @override
  final int? field1;

  @override
  String toString() {
    return 'KitchenSinkTwinSync.optional(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KitchenSinkTwinSync_OptionalImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$KitchenSinkTwinSync_OptionalImplCopyWith<
          _$KitchenSinkTwinSync_OptionalImpl>
      get copyWith => __$$KitchenSinkTwinSync_OptionalImplCopyWithImpl<
          _$KitchenSinkTwinSync_OptionalImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(int int32, double float64, bool boolean)
        primitives,
    required TResult Function(int field0, KitchenSinkTwinSync field1) nested,
    required TResult Function(int? field0, int? field1) optional,
    required TResult Function(Uint8List field0) buffer,
    required TResult Function(WeekdaysTwinSync field0) enums,
  }) {
    return optional(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(int int32, double float64, bool boolean)? primitives,
    TResult? Function(int field0, KitchenSinkTwinSync field1)? nested,
    TResult? Function(int? field0, int? field1)? optional,
    TResult? Function(Uint8List field0)? buffer,
    TResult? Function(WeekdaysTwinSync field0)? enums,
  }) {
    return optional?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(int int32, double float64, bool boolean)? primitives,
    TResult Function(int field0, KitchenSinkTwinSync field1)? nested,
    TResult Function(int? field0, int? field1)? optional,
    TResult Function(Uint8List field0)? buffer,
    TResult Function(WeekdaysTwinSync field0)? enums,
    required TResult orElse(),
  }) {
    if (optional != null) {
      return optional(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(KitchenSinkTwinSync_Empty value) empty,
    required TResult Function(KitchenSinkTwinSync_Primitives value) primitives,
    required TResult Function(KitchenSinkTwinSync_Nested value) nested,
    required TResult Function(KitchenSinkTwinSync_Optional value) optional,
    required TResult Function(KitchenSinkTwinSync_Buffer value) buffer,
    required TResult Function(KitchenSinkTwinSync_Enums value) enums,
  }) {
    return optional(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(KitchenSinkTwinSync_Empty value)? empty,
    TResult? Function(KitchenSinkTwinSync_Primitives value)? primitives,
    TResult? Function(KitchenSinkTwinSync_Nested value)? nested,
    TResult? Function(KitchenSinkTwinSync_Optional value)? optional,
    TResult? Function(KitchenSinkTwinSync_Buffer value)? buffer,
    TResult? Function(KitchenSinkTwinSync_Enums value)? enums,
  }) {
    return optional?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(KitchenSinkTwinSync_Empty value)? empty,
    TResult Function(KitchenSinkTwinSync_Primitives value)? primitives,
    TResult Function(KitchenSinkTwinSync_Nested value)? nested,
    TResult Function(KitchenSinkTwinSync_Optional value)? optional,
    TResult Function(KitchenSinkTwinSync_Buffer value)? buffer,
    TResult Function(KitchenSinkTwinSync_Enums value)? enums,
    required TResult orElse(),
  }) {
    if (optional != null) {
      return optional(this);
    }
    return orElse();
  }
}

abstract class KitchenSinkTwinSync_Optional extends KitchenSinkTwinSync {
  const factory KitchenSinkTwinSync_Optional(
      [final int? field0,
      final int? field1]) = _$KitchenSinkTwinSync_OptionalImpl;
  const KitchenSinkTwinSync_Optional._() : super._();

  /// Comment on anonymous field
  int? get field0;
  int? get field1;
  @JsonKey(ignore: true)
  _$$KitchenSinkTwinSync_OptionalImplCopyWith<
          _$KitchenSinkTwinSync_OptionalImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$KitchenSinkTwinSync_BufferImplCopyWith<$Res> {
  factory _$$KitchenSinkTwinSync_BufferImplCopyWith(
          _$KitchenSinkTwinSync_BufferImpl value,
          $Res Function(_$KitchenSinkTwinSync_BufferImpl) then) =
      __$$KitchenSinkTwinSync_BufferImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class __$$KitchenSinkTwinSync_BufferImplCopyWithImpl<$Res>
    extends _$KitchenSinkTwinSyncCopyWithImpl<$Res,
        _$KitchenSinkTwinSync_BufferImpl>
    implements _$$KitchenSinkTwinSync_BufferImplCopyWith<$Res> {
  __$$KitchenSinkTwinSync_BufferImplCopyWithImpl(
      _$KitchenSinkTwinSync_BufferImpl _value,
      $Res Function(_$KitchenSinkTwinSync_BufferImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$KitchenSinkTwinSync_BufferImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$KitchenSinkTwinSync_BufferImpl extends KitchenSinkTwinSync_Buffer {
  const _$KitchenSinkTwinSync_BufferImpl(this.field0) : super._();

  @override
  final Uint8List field0;

  @override
  String toString() {
    return 'KitchenSinkTwinSync.buffer(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KitchenSinkTwinSync_BufferImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$KitchenSinkTwinSync_BufferImplCopyWith<_$KitchenSinkTwinSync_BufferImpl>
      get copyWith => __$$KitchenSinkTwinSync_BufferImplCopyWithImpl<
          _$KitchenSinkTwinSync_BufferImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(int int32, double float64, bool boolean)
        primitives,
    required TResult Function(int field0, KitchenSinkTwinSync field1) nested,
    required TResult Function(int? field0, int? field1) optional,
    required TResult Function(Uint8List field0) buffer,
    required TResult Function(WeekdaysTwinSync field0) enums,
  }) {
    return buffer(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(int int32, double float64, bool boolean)? primitives,
    TResult? Function(int field0, KitchenSinkTwinSync field1)? nested,
    TResult? Function(int? field0, int? field1)? optional,
    TResult? Function(Uint8List field0)? buffer,
    TResult? Function(WeekdaysTwinSync field0)? enums,
  }) {
    return buffer?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(int int32, double float64, bool boolean)? primitives,
    TResult Function(int field0, KitchenSinkTwinSync field1)? nested,
    TResult Function(int? field0, int? field1)? optional,
    TResult Function(Uint8List field0)? buffer,
    TResult Function(WeekdaysTwinSync field0)? enums,
    required TResult orElse(),
  }) {
    if (buffer != null) {
      return buffer(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(KitchenSinkTwinSync_Empty value) empty,
    required TResult Function(KitchenSinkTwinSync_Primitives value) primitives,
    required TResult Function(KitchenSinkTwinSync_Nested value) nested,
    required TResult Function(KitchenSinkTwinSync_Optional value) optional,
    required TResult Function(KitchenSinkTwinSync_Buffer value) buffer,
    required TResult Function(KitchenSinkTwinSync_Enums value) enums,
  }) {
    return buffer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(KitchenSinkTwinSync_Empty value)? empty,
    TResult? Function(KitchenSinkTwinSync_Primitives value)? primitives,
    TResult? Function(KitchenSinkTwinSync_Nested value)? nested,
    TResult? Function(KitchenSinkTwinSync_Optional value)? optional,
    TResult? Function(KitchenSinkTwinSync_Buffer value)? buffer,
    TResult? Function(KitchenSinkTwinSync_Enums value)? enums,
  }) {
    return buffer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(KitchenSinkTwinSync_Empty value)? empty,
    TResult Function(KitchenSinkTwinSync_Primitives value)? primitives,
    TResult Function(KitchenSinkTwinSync_Nested value)? nested,
    TResult Function(KitchenSinkTwinSync_Optional value)? optional,
    TResult Function(KitchenSinkTwinSync_Buffer value)? buffer,
    TResult Function(KitchenSinkTwinSync_Enums value)? enums,
    required TResult orElse(),
  }) {
    if (buffer != null) {
      return buffer(this);
    }
    return orElse();
  }
}

abstract class KitchenSinkTwinSync_Buffer extends KitchenSinkTwinSync {
  const factory KitchenSinkTwinSync_Buffer(final Uint8List field0) =
      _$KitchenSinkTwinSync_BufferImpl;
  const KitchenSinkTwinSync_Buffer._() : super._();

  Uint8List get field0;
  @JsonKey(ignore: true)
  _$$KitchenSinkTwinSync_BufferImplCopyWith<_$KitchenSinkTwinSync_BufferImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$KitchenSinkTwinSync_EnumsImplCopyWith<$Res> {
  factory _$$KitchenSinkTwinSync_EnumsImplCopyWith(
          _$KitchenSinkTwinSync_EnumsImpl value,
          $Res Function(_$KitchenSinkTwinSync_EnumsImpl) then) =
      __$$KitchenSinkTwinSync_EnumsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({WeekdaysTwinSync field0});
}

/// @nodoc
class __$$KitchenSinkTwinSync_EnumsImplCopyWithImpl<$Res>
    extends _$KitchenSinkTwinSyncCopyWithImpl<$Res,
        _$KitchenSinkTwinSync_EnumsImpl>
    implements _$$KitchenSinkTwinSync_EnumsImplCopyWith<$Res> {
  __$$KitchenSinkTwinSync_EnumsImplCopyWithImpl(
      _$KitchenSinkTwinSync_EnumsImpl _value,
      $Res Function(_$KitchenSinkTwinSync_EnumsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$KitchenSinkTwinSync_EnumsImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as WeekdaysTwinSync,
    ));
  }
}

/// @nodoc

class _$KitchenSinkTwinSync_EnumsImpl extends KitchenSinkTwinSync_Enums {
  const _$KitchenSinkTwinSync_EnumsImpl([this.field0 = WeekdaysTwinSync.sunday])
      : super._();

  @override
  @JsonKey()
  final WeekdaysTwinSync field0;

  @override
  String toString() {
    return 'KitchenSinkTwinSync.enums(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KitchenSinkTwinSync_EnumsImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$KitchenSinkTwinSync_EnumsImplCopyWith<_$KitchenSinkTwinSync_EnumsImpl>
      get copyWith => __$$KitchenSinkTwinSync_EnumsImplCopyWithImpl<
          _$KitchenSinkTwinSync_EnumsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(int int32, double float64, bool boolean)
        primitives,
    required TResult Function(int field0, KitchenSinkTwinSync field1) nested,
    required TResult Function(int? field0, int? field1) optional,
    required TResult Function(Uint8List field0) buffer,
    required TResult Function(WeekdaysTwinSync field0) enums,
  }) {
    return enums(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(int int32, double float64, bool boolean)? primitives,
    TResult? Function(int field0, KitchenSinkTwinSync field1)? nested,
    TResult? Function(int? field0, int? field1)? optional,
    TResult? Function(Uint8List field0)? buffer,
    TResult? Function(WeekdaysTwinSync field0)? enums,
  }) {
    return enums?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(int int32, double float64, bool boolean)? primitives,
    TResult Function(int field0, KitchenSinkTwinSync field1)? nested,
    TResult Function(int? field0, int? field1)? optional,
    TResult Function(Uint8List field0)? buffer,
    TResult Function(WeekdaysTwinSync field0)? enums,
    required TResult orElse(),
  }) {
    if (enums != null) {
      return enums(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(KitchenSinkTwinSync_Empty value) empty,
    required TResult Function(KitchenSinkTwinSync_Primitives value) primitives,
    required TResult Function(KitchenSinkTwinSync_Nested value) nested,
    required TResult Function(KitchenSinkTwinSync_Optional value) optional,
    required TResult Function(KitchenSinkTwinSync_Buffer value) buffer,
    required TResult Function(KitchenSinkTwinSync_Enums value) enums,
  }) {
    return enums(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(KitchenSinkTwinSync_Empty value)? empty,
    TResult? Function(KitchenSinkTwinSync_Primitives value)? primitives,
    TResult? Function(KitchenSinkTwinSync_Nested value)? nested,
    TResult? Function(KitchenSinkTwinSync_Optional value)? optional,
    TResult? Function(KitchenSinkTwinSync_Buffer value)? buffer,
    TResult? Function(KitchenSinkTwinSync_Enums value)? enums,
  }) {
    return enums?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(KitchenSinkTwinSync_Empty value)? empty,
    TResult Function(KitchenSinkTwinSync_Primitives value)? primitives,
    TResult Function(KitchenSinkTwinSync_Nested value)? nested,
    TResult Function(KitchenSinkTwinSync_Optional value)? optional,
    TResult Function(KitchenSinkTwinSync_Buffer value)? buffer,
    TResult Function(KitchenSinkTwinSync_Enums value)? enums,
    required TResult orElse(),
  }) {
    if (enums != null) {
      return enums(this);
    }
    return orElse();
  }
}

abstract class KitchenSinkTwinSync_Enums extends KitchenSinkTwinSync {
  const factory KitchenSinkTwinSync_Enums([final WeekdaysTwinSync field0]) =
      _$KitchenSinkTwinSync_EnumsImpl;
  const KitchenSinkTwinSync_Enums._() : super._();

  WeekdaysTwinSync get field0;
  @JsonKey(ignore: true)
  _$$KitchenSinkTwinSync_EnumsImplCopyWith<_$KitchenSinkTwinSync_EnumsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MeasureTwinSync {
  Object get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(SpeedTwinSync field0) speed,
    required TResult Function(DistanceTwinSync field0) distance,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(SpeedTwinSync field0)? speed,
    TResult? Function(DistanceTwinSync field0)? distance,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(SpeedTwinSync field0)? speed,
    TResult Function(DistanceTwinSync field0)? distance,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasureTwinSync_Speed value) speed,
    required TResult Function(MeasureTwinSync_Distance value) distance,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasureTwinSync_Speed value)? speed,
    TResult? Function(MeasureTwinSync_Distance value)? distance,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasureTwinSync_Speed value)? speed,
    TResult Function(MeasureTwinSync_Distance value)? distance,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MeasureTwinSyncCopyWith<$Res> {
  factory $MeasureTwinSyncCopyWith(
          MeasureTwinSync value, $Res Function(MeasureTwinSync) then) =
      _$MeasureTwinSyncCopyWithImpl<$Res, MeasureTwinSync>;
}

/// @nodoc
class _$MeasureTwinSyncCopyWithImpl<$Res, $Val extends MeasureTwinSync>
    implements $MeasureTwinSyncCopyWith<$Res> {
  _$MeasureTwinSyncCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$MeasureTwinSync_SpeedImplCopyWith<$Res> {
  factory _$$MeasureTwinSync_SpeedImplCopyWith(
          _$MeasureTwinSync_SpeedImpl value,
          $Res Function(_$MeasureTwinSync_SpeedImpl) then) =
      __$$MeasureTwinSync_SpeedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SpeedTwinSync field0});

  $SpeedTwinSyncCopyWith<$Res> get field0;
}

/// @nodoc
class __$$MeasureTwinSync_SpeedImplCopyWithImpl<$Res>
    extends _$MeasureTwinSyncCopyWithImpl<$Res, _$MeasureTwinSync_SpeedImpl>
    implements _$$MeasureTwinSync_SpeedImplCopyWith<$Res> {
  __$$MeasureTwinSync_SpeedImplCopyWithImpl(_$MeasureTwinSync_SpeedImpl _value,
      $Res Function(_$MeasureTwinSync_SpeedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$MeasureTwinSync_SpeedImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as SpeedTwinSync,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $SpeedTwinSyncCopyWith<$Res> get field0 {
    return $SpeedTwinSyncCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$MeasureTwinSync_SpeedImpl extends MeasureTwinSync_Speed {
  const _$MeasureTwinSync_SpeedImpl(this.field0) : super._();

  @override
  final SpeedTwinSync field0;

  @override
  String toString() {
    return 'MeasureTwinSync.speed(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasureTwinSync_SpeedImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MeasureTwinSync_SpeedImplCopyWith<_$MeasureTwinSync_SpeedImpl>
      get copyWith => __$$MeasureTwinSync_SpeedImplCopyWithImpl<
          _$MeasureTwinSync_SpeedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(SpeedTwinSync field0) speed,
    required TResult Function(DistanceTwinSync field0) distance,
  }) {
    return speed(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(SpeedTwinSync field0)? speed,
    TResult? Function(DistanceTwinSync field0)? distance,
  }) {
    return speed?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(SpeedTwinSync field0)? speed,
    TResult Function(DistanceTwinSync field0)? distance,
    required TResult orElse(),
  }) {
    if (speed != null) {
      return speed(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasureTwinSync_Speed value) speed,
    required TResult Function(MeasureTwinSync_Distance value) distance,
  }) {
    return speed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasureTwinSync_Speed value)? speed,
    TResult? Function(MeasureTwinSync_Distance value)? distance,
  }) {
    return speed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasureTwinSync_Speed value)? speed,
    TResult Function(MeasureTwinSync_Distance value)? distance,
    required TResult orElse(),
  }) {
    if (speed != null) {
      return speed(this);
    }
    return orElse();
  }
}

abstract class MeasureTwinSync_Speed extends MeasureTwinSync {
  const factory MeasureTwinSync_Speed(final SpeedTwinSync field0) =
      _$MeasureTwinSync_SpeedImpl;
  const MeasureTwinSync_Speed._() : super._();

  @override
  SpeedTwinSync get field0;
  @JsonKey(ignore: true)
  _$$MeasureTwinSync_SpeedImplCopyWith<_$MeasureTwinSync_SpeedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MeasureTwinSync_DistanceImplCopyWith<$Res> {
  factory _$$MeasureTwinSync_DistanceImplCopyWith(
          _$MeasureTwinSync_DistanceImpl value,
          $Res Function(_$MeasureTwinSync_DistanceImpl) then) =
      __$$MeasureTwinSync_DistanceImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DistanceTwinSync field0});

  $DistanceTwinSyncCopyWith<$Res> get field0;
}

/// @nodoc
class __$$MeasureTwinSync_DistanceImplCopyWithImpl<$Res>
    extends _$MeasureTwinSyncCopyWithImpl<$Res, _$MeasureTwinSync_DistanceImpl>
    implements _$$MeasureTwinSync_DistanceImplCopyWith<$Res> {
  __$$MeasureTwinSync_DistanceImplCopyWithImpl(
      _$MeasureTwinSync_DistanceImpl _value,
      $Res Function(_$MeasureTwinSync_DistanceImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$MeasureTwinSync_DistanceImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as DistanceTwinSync,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $DistanceTwinSyncCopyWith<$Res> get field0 {
    return $DistanceTwinSyncCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$MeasureTwinSync_DistanceImpl extends MeasureTwinSync_Distance {
  const _$MeasureTwinSync_DistanceImpl(this.field0) : super._();

  @override
  final DistanceTwinSync field0;

  @override
  String toString() {
    return 'MeasureTwinSync.distance(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MeasureTwinSync_DistanceImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MeasureTwinSync_DistanceImplCopyWith<_$MeasureTwinSync_DistanceImpl>
      get copyWith => __$$MeasureTwinSync_DistanceImplCopyWithImpl<
          _$MeasureTwinSync_DistanceImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(SpeedTwinSync field0) speed,
    required TResult Function(DistanceTwinSync field0) distance,
  }) {
    return distance(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(SpeedTwinSync field0)? speed,
    TResult? Function(DistanceTwinSync field0)? distance,
  }) {
    return distance?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(SpeedTwinSync field0)? speed,
    TResult Function(DistanceTwinSync field0)? distance,
    required TResult orElse(),
  }) {
    if (distance != null) {
      return distance(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MeasureTwinSync_Speed value) speed,
    required TResult Function(MeasureTwinSync_Distance value) distance,
  }) {
    return distance(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MeasureTwinSync_Speed value)? speed,
    TResult? Function(MeasureTwinSync_Distance value)? distance,
  }) {
    return distance?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MeasureTwinSync_Speed value)? speed,
    TResult Function(MeasureTwinSync_Distance value)? distance,
    required TResult orElse(),
  }) {
    if (distance != null) {
      return distance(this);
    }
    return orElse();
  }
}

abstract class MeasureTwinSync_Distance extends MeasureTwinSync {
  const factory MeasureTwinSync_Distance(final DistanceTwinSync field0) =
      _$MeasureTwinSync_DistanceImpl;
  const MeasureTwinSync_Distance._() : super._();

  @override
  DistanceTwinSync get field0;
  @JsonKey(ignore: true)
  _$$MeasureTwinSync_DistanceImplCopyWith<_$MeasureTwinSync_DistanceImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SpeedTwinSync {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function(double field0) gps,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function(double field0)? gps,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function(double field0)? gps,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SpeedTwinSync_Unknown value) unknown,
    required TResult Function(SpeedTwinSync_GPS value) gps,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SpeedTwinSync_Unknown value)? unknown,
    TResult? Function(SpeedTwinSync_GPS value)? gps,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SpeedTwinSync_Unknown value)? unknown,
    TResult Function(SpeedTwinSync_GPS value)? gps,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpeedTwinSyncCopyWith<$Res> {
  factory $SpeedTwinSyncCopyWith(
          SpeedTwinSync value, $Res Function(SpeedTwinSync) then) =
      _$SpeedTwinSyncCopyWithImpl<$Res, SpeedTwinSync>;
}

/// @nodoc
class _$SpeedTwinSyncCopyWithImpl<$Res, $Val extends SpeedTwinSync>
    implements $SpeedTwinSyncCopyWith<$Res> {
  _$SpeedTwinSyncCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SpeedTwinSync_UnknownImplCopyWith<$Res> {
  factory _$$SpeedTwinSync_UnknownImplCopyWith(
          _$SpeedTwinSync_UnknownImpl value,
          $Res Function(_$SpeedTwinSync_UnknownImpl) then) =
      __$$SpeedTwinSync_UnknownImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SpeedTwinSync_UnknownImplCopyWithImpl<$Res>
    extends _$SpeedTwinSyncCopyWithImpl<$Res, _$SpeedTwinSync_UnknownImpl>
    implements _$$SpeedTwinSync_UnknownImplCopyWith<$Res> {
  __$$SpeedTwinSync_UnknownImplCopyWithImpl(_$SpeedTwinSync_UnknownImpl _value,
      $Res Function(_$SpeedTwinSync_UnknownImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SpeedTwinSync_UnknownImpl extends SpeedTwinSync_Unknown {
  const _$SpeedTwinSync_UnknownImpl() : super._();

  @override
  String toString() {
    return 'SpeedTwinSync.unknown()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SpeedTwinSync_UnknownImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function(double field0) gps,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function(double field0)? gps,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function(double field0)? gps,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SpeedTwinSync_Unknown value) unknown,
    required TResult Function(SpeedTwinSync_GPS value) gps,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SpeedTwinSync_Unknown value)? unknown,
    TResult? Function(SpeedTwinSync_GPS value)? gps,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SpeedTwinSync_Unknown value)? unknown,
    TResult Function(SpeedTwinSync_GPS value)? gps,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class SpeedTwinSync_Unknown extends SpeedTwinSync {
  const factory SpeedTwinSync_Unknown() = _$SpeedTwinSync_UnknownImpl;
  const SpeedTwinSync_Unknown._() : super._();
}

/// @nodoc
abstract class _$$SpeedTwinSync_GPSImplCopyWith<$Res> {
  factory _$$SpeedTwinSync_GPSImplCopyWith(_$SpeedTwinSync_GPSImpl value,
          $Res Function(_$SpeedTwinSync_GPSImpl) then) =
      __$$SpeedTwinSync_GPSImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$SpeedTwinSync_GPSImplCopyWithImpl<$Res>
    extends _$SpeedTwinSyncCopyWithImpl<$Res, _$SpeedTwinSync_GPSImpl>
    implements _$$SpeedTwinSync_GPSImplCopyWith<$Res> {
  __$$SpeedTwinSync_GPSImplCopyWithImpl(_$SpeedTwinSync_GPSImpl _value,
      $Res Function(_$SpeedTwinSync_GPSImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$SpeedTwinSync_GPSImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$SpeedTwinSync_GPSImpl extends SpeedTwinSync_GPS {
  const _$SpeedTwinSync_GPSImpl(this.field0) : super._();

  @override
  final double field0;

  @override
  String toString() {
    return 'SpeedTwinSync.gps(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SpeedTwinSync_GPSImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SpeedTwinSync_GPSImplCopyWith<_$SpeedTwinSync_GPSImpl> get copyWith =>
      __$$SpeedTwinSync_GPSImplCopyWithImpl<_$SpeedTwinSync_GPSImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() unknown,
    required TResult Function(double field0) gps,
  }) {
    return gps(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? unknown,
    TResult? Function(double field0)? gps,
  }) {
    return gps?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? unknown,
    TResult Function(double field0)? gps,
    required TResult orElse(),
  }) {
    if (gps != null) {
      return gps(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SpeedTwinSync_Unknown value) unknown,
    required TResult Function(SpeedTwinSync_GPS value) gps,
  }) {
    return gps(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SpeedTwinSync_Unknown value)? unknown,
    TResult? Function(SpeedTwinSync_GPS value)? gps,
  }) {
    return gps?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SpeedTwinSync_Unknown value)? unknown,
    TResult Function(SpeedTwinSync_GPS value)? gps,
    required TResult orElse(),
  }) {
    if (gps != null) {
      return gps(this);
    }
    return orElse();
  }
}

abstract class SpeedTwinSync_GPS extends SpeedTwinSync {
  const factory SpeedTwinSync_GPS(final double field0) =
      _$SpeedTwinSync_GPSImpl;
  const SpeedTwinSync_GPS._() : super._();

  double get field0;
  @JsonKey(ignore: true)
  _$$SpeedTwinSync_GPSImplCopyWith<_$SpeedTwinSync_GPSImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
