// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:logging/logging.dart';

// These functions are ignored because they are not marked as `pub`: `_construct_default_message`, `_default_log_fn`, `_default_logger_name`, `_default_max_log_level`, `from_u16`, `to_u16`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `enabled`, `flush`, `from`, `log`

String rootLoggerName() => RustLib.instance.api.crateApiMinimalRootLoggerName();

String maxLogLevel() => RustLib.instance.api.crateApiMinimalMaxLogLevel();

/// this is the call for logging (from Rust and Dart (as logFn))
void logFn({required MirLogRecord record}) =>
    RustLib.instance.api.crateApiMinimalLogFn(record: record);

/// uses custom type translation to translate between log::LogLevel and Dart:logging::Level
/// loglevel is represented by a number, so that we don't need to put \import `import 'package:logging/logging.dart';`
/// into the dart preamble in flutter_rust_bridge.yaml
Stream<MirLogRecord> initializeLog2Dart({required int maxLogLevel}) =>
    RustLib.instance.api
        .crateApiMinimalInitializeLog2Dart(maxLogLevel: maxLogLevel);

Future<int> minimalAdder({required int a, required int b}) =>
    RustLib.instance.api.crateApiMinimalMinimalAdder(a: a, b: b);

class FRBLogger {
  final RustStreamSink<MirLogRecord> streamSink;

  const FRBLogger({
    required this.streamSink,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<FRBLogger> newInstance() =>
      RustLib.instance.api.crateApiMinimalFrbLoggerNew();

  static FRBDartLogger initLogger(
      {String name = 'FRBLogger',
      LogLevel maxLogLevel = LogLevel.info,
      Function({required MirLogRecord record}) customLogFunction = logFn}) {
    //initialize the rust side
    int maxLogLevelNumber = maxLogLevel.levelNumberThreshold;
    Stream<MirLogRecord> stream =
        initializeLog2Dart(maxLogLevel: maxLogLevelNumber);

    // Functions for type conversion for interaction with frb_dart/utils/frb_logging.dart
    // Wrap logFn to match `void Function({required dynamic record})`
    void Function({required dynamic record}) wrappedLogFn =
        ({required dynamic record}) {
      // Safely cast `dynamic` record back to `MirLogRecord` for the original `logFn`
      logFn(record: record as MirLogRecord);
    };
    // Wrap fromDartLogRecord to match `dynamic Function(LogRecord record)`
    MirLogRecord Function(LogRecord record) wrappedFromDartLogRecord =
        (LogRecord record) {
      return MirLogRecord.fromDartLogRecord(record);
    };
    // Wrap customLogFunction if provided, to match `void Function({required dynamic record})?`
    void Function({required dynamic record})? wrappedCustomLogFunction;
    wrappedCustomLogFunction = ({required dynamic record}) {
      customLogFunction(record: record as MirLogRecord);
    };

    return FRBDartLogger.initAndGetSingleton<MirLogRecord>(
      streamSink: stream,
      name: name,
      logFn: wrappedLogFn,
      fromDartLogRecord: wrappedFromDartLogRecord,
      maxLogLevel: maxLogLevel,
      customLogFunction: wrappedCustomLogFunction,
    );
  }

  static FRBDartLogger getLogger(String? name) {
    return FRBDartLogger.getLogger(name);
  }

  @override
  int get hashCode => streamSink.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FRBLogger &&
          runtimeType == other.runtimeType &&
          streamSink == other.streamSink;
}

/// mapping log crate's [Record](https://docs.rs/log/latest/log/struct.Record.html) to dart's Logger [LogRecord](https://pub.dev/documentation/logging/latest/logging/LogRecord-class.html).
/// intermediary struct to avoid Record's lifetimes
class MirLogRecord {
  final int levelNumber;
  final String message;
  final String loggerName;
  final bool rustLog;
  final String? modulePath;
  final String? fileName;
  final int? lineNumber;

  const MirLogRecord({
    required this.levelNumber,
    required this.message,
    required this.loggerName,
    required this.rustLog,
    this.modulePath,
    this.fileName,
    this.lineNumber,
  });

  static MirLogRecord fromDartLogRecord(LogRecord record) {
    return MirLogRecord(
      message: record.message,
      levelNumber: record.level.value,
      loggerName: record.loggerName,
      rustLog: false,
    );
  }

  static LogRecord toDartLogRecordFromMir(MirLogRecord record) {
    return LogRecord(
      LogLevel.fromNumber(record.levelNumber).toLoggingLevel(),
      record.message,
      record.loggerName,
    );
  }

  LogRecord toDartLogRecord() {
    return toDartLogRecordFromMir(this);
  }

  @override
  int get hashCode =>
      levelNumber.hashCode ^
      message.hashCode ^
      loggerName.hashCode ^
      rustLog.hashCode ^
      modulePath.hashCode ^
      fileName.hashCode ^
      lineNumber.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MirLogRecord &&
          runtimeType == other.runtimeType &&
          levelNumber == other.levelNumber &&
          message == other.message &&
          loggerName == other.loggerName &&
          rustLog == other.rustLog &&
          modulePath == other.modulePath &&
          fileName == other.fileName &&
          lineNumber == other.lineNumber;
}
