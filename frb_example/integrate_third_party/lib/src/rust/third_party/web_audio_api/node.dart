// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.1.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../api/override_web_audio_api.dart';
import '../../frb_generated.dart';
import '../web_audio_api.dart';
import 'media_streams.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'worklet.dart';

// These functions are ignored because they have generic arguments: `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect`, `connect`, `connect`, `set_onended`, `set_onended`, `set_onended`, `set_onended`
// These types are ignored because they are not used by any `pub` functions: `IIRFilterOptions`, `MediaElementAudioSourceOptions`, `MediaStreamAudioSourceOptions`, `MediaStreamRenderer`, `MediaStreamTrackAudioSourceOptions`, `ScriptProcessorOptions`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `process`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count_mode`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_count`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_channel_interpretation`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`
// These functions are ignored (category: IgnoreBecauseNotAllowedOwner): `channel_count_mode`, `channel_count`, `channel_interpretation`, `clear_onprocessorerror`, `context`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output`, `disconnect_dest`, `disconnect_output`, `disconnect`, `set_onprocessorerror`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>
abstract class AnalyserNode
    implements
        RustOpaqueInterface,
        AnalyserNodeExt,
        AnalyserNodeMiscExt,
        AudioNode {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  /// The size of the FFT used for frequency-domain analysis (in sample-frames)
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<int> fftSize();

  Future<void> connect({required AudioNode dest});

  Future<Uint8List> getByteTimeDomainData({required int len});

  Future<Float32List> getFloatTimeDomainData({required int len});

  /// Number of bins in the FFT results, is half the FFT size
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<int> frequencyBinCount();

  /// Maximum power value in the scaling range for the FFT analysis data for
  /// conversion to unsigned byte values. The default value is -30.
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<double> maxDecibels();

  /// Minimum power value in the scaling range for the FFT analysis data for
  /// conversion to unsigned byte values. The default value is -100.
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<double> minDecibels();

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  Future<void> registration();

  /// Set FFT size
  ///
  /// # Panics
  ///
  /// This function panics if fft_size is not a power of two or not in the range [32, 32768]
  Future<void> setFftSize({required int fftSize});

  /// Set max decibels
  ///
  /// # Panics
  ///
  /// This function panics if the value is set to a value less than or equal
  /// to min decibels.
  Future<void> setMaxDecibels({required double value});

  /// Set min decibels
  ///
  /// # Panics
  ///
  /// This function panics if the value is set to a value more than or equal
  /// to max decibels.
  Future<void> setMinDecibels({required double value});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  /// Set smoothing time constant
  ///
  /// # Panics
  ///
  /// This function panics if the value is set to a value less than 0 or more than 1.
  Future<void> setSmoothingTimeConstant({required double value});

  /// Time averaging parameter with the last analysis frame.
  /// A value from 0 -> 1 where 0 represents no time averaging with the last
  /// analysis frame. The default value is 0.8.
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<double> smoothingTimeConstant();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>
abstract class AudioBufferSourceNode
    implements
        RustOpaqueInterface,
        AudioBufferSourceNodeExt,
        AudioBufferSourceNodeMiscExt,
        AudioBufferSourceNodeScheduledSourceNodeMiscExt,
        AudioNode,
        AudioScheduledSourceNode {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when the source node has stopped playing
  Future<void> clearOnended();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// K-rate [`AudioParam`] that defines a pitch transposition of the file,
  /// expressed in cents
  ///
  /// see <https://en.wikipedia.org/wiki/Cent_(music)>
  AudioParam get detune;

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  Future<void> setBuffer({required AudioBuffer audioBuffer});

  /// Defines if the playback the [`AudioBuffer`] should be looped
  Future<bool> loop();

  /// Defines the loop end point, in the time reference of the [`AudioBuffer`]
  Future<double> loopEnd();

  /// Defines the loop start point, in the time reference of the [`AudioBuffer`]
  Future<double> loopStart();

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  /// K-rate [`AudioParam`] that defines the speed at which the [`AudioBuffer`]
  /// will be played, e.g.:
  /// - `0.5` will play the file at half speed
  /// - `-1` will play the file in reverse
  ///
  /// Note that playback rate will also alter the pitch of the [`AudioBuffer`]
  AudioParam get playbackRate;

  /// Current playhead position in seconds within the [`AudioBuffer`].
  ///
  /// This value is updated at the end of each render quantum.
  ///
  /// Unofficial v2 API extension, not part of the spec yet.
  /// See also: <https://github.com/WebAudio/web-audio-api/issues/2397#issuecomment-709478405>
  Future<double> position();

  Future<void> registration();

  Future<void> setLoop({required bool value});

  Future<void> setLoopEnd({required double value});

  Future<void> setLoopStart({required double value});

  Future<void> setOnEnded({required FutureOr<void> Function(Event) callback});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  Future<void> start();

  Future<void> startAt({required double when});

  /// Start the playback at the given time and with a given offset
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> startAtWithOffset(
      {required double start, required double offset});

  /// Start the playback at the given time, with a given offset, for a given duration
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> startAtWithOffsetAndDuration(
      {required double start,
      required double offset,
      required double duration});

  Future<void> stop();

  Future<void> stopAt({required double when});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioDestinationNode>>
abstract class AudioDestinationNode
    implements RustOpaqueInterface, AudioDestinationNodeExt, AudioNode {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// The maximum number of channels that the channelCount attribute can be set to (the max
  /// number of channels that the hardware is capable of supporting).
  /// <https://www.w3.org/TR/webaudio/#dom-audiodestinationnode-maxchannelcount>
  Future<int> maxChannelCount();

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  Future<void> registration();

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>>
abstract class BiquadFilterNode
    implements RustOpaqueInterface, AudioNode, BiquadFilterNodeExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Returns the detune audio parameter
  AudioParam get detune;

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// Returns the frequency audio parameter
  AudioParam get frequency;

  /// Returns the gain audio parameter
  AudioParam get gain;

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  /// Returns the Q audio parameter
  AudioParam get q;

  Future<void> registration();

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  /// biquad filter type setter
  ///
  /// # Arguments
  ///
  /// * `type_` - the biquad filter type (lowpass, highpass,...)
  Future<void> setType({required BiquadFilterType type});

  /// Returns the biquad filter type
  Future<BiquadFilterType> type();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelConfig>>
abstract class ChannelConfig implements RustOpaqueInterface {
  static Future<ChannelConfig> default_() =>
      RustLib.instance.api.webAudioApiNodeChannelConfigDefault();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelMergerNode>>
abstract class ChannelMergerNode
    implements RustOpaqueInterface, AudioNode, ChannelMergerNodeExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  Future<void> registration();

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelSplitterNode>>
abstract class ChannelSplitterNode
    implements RustOpaqueInterface, AudioNode, ChannelSplitterNodeExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  Future<void> registration();

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConstantSourceNode>>
abstract class ConstantSourceNode
    implements
        RustOpaqueInterface,
        AudioNode,
        AudioScheduledSourceNode,
        ConstantSourceNodeExt,
        ConstantSourceNodeScheduledSourceNodeMiscExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when the source node has stopped playing
  Future<void> clearOnended();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  AudioParam get offset;

  Future<void> registration();

  Future<void> setOnEnded({required FutureOr<void> Function(Event) callback});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  Future<void> start();

  Future<void> startAt({required double when});

  Future<void> stop();

  Future<void> stopAt({required double when});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvolverNode>>
abstract class ConvolverNode
    implements RustOpaqueInterface, AudioNode, ConvolverNodeExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// Denotes if the response buffer will be scaled with an equal-power normalization
  Future<bool> normalize();

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  Future<void> registration();

  /// Set or update the impulse response buffer
  ///
  /// # Panics
  ///
  /// Panics when the sample rate of the provided AudioBuffer differs from the audio context
  /// sample rate.
  Future<void> setBuffer({required AudioBuffer buffer});

  /// Update the `normalize` setting. This will only have an effect when `set_buffer` is called.
  Future<void> setNormalize({required bool value});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DelayNode>>
abstract class DelayNode
    implements RustOpaqueInterface, AudioNode, DelayNodeExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// A-rate [`AudioParam`] representing the amount of delay (in seconds) to apply.
  AudioParam get delayTime;

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  Future<void> registration();

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicsCompressorNode>>
abstract class DynamicsCompressorNode
    implements RustOpaqueInterface, AudioNode, DynamicsCompressorNodeExt {
  AudioParam get attack;

  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  AudioParam get knee;

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  AudioParam get ratio;

  Future<double> reduction();

  Future<void> registration();

  AudioParam get release;

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  AudioParam get threshold;
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GainNode>>
abstract class GainNode implements RustOpaqueInterface, AudioNode, GainNodeExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  AudioParam get gain;

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  Future<void> registration();

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IIRFilterNode>>
abstract class IirFilterNode
    implements RustOpaqueInterface, AudioNode, IIRFilterNodeExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  Future<void> registration();

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElementAudioSourceNode>>
abstract class MediaElementAudioSourceNode
    implements RustOpaqueInterface, AudioNode, MediaElementAudioSourceNodeExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  Future<void> registration();

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioDestinationNode>>
abstract class MediaStreamAudioDestinationNode
    implements
        RustOpaqueInterface,
        AudioNode,
        MediaStreamAudioDestinationNodeExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  Future<void> registration();

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  /// A [`MediaStream`] producing audio buffers with the same number of channels as the node
  /// itself
  Future<MediaStream> stream();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioSourceNode>>
abstract class MediaStreamAudioSourceNode
    implements RustOpaqueInterface, AudioNode, MediaStreamAudioSourceNodeExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  Future<void> registration();

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrackAudioSourceNode>>
abstract class MediaStreamTrackAudioSourceNode
    implements
        RustOpaqueInterface,
        AudioNode,
        MediaStreamTrackAudioSourceNodeExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  Future<void> registration();

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>>
abstract class OscillatorNode
    implements
        RustOpaqueInterface,
        AudioNode,
        AudioScheduledSourceNode,
        OscillatorNodeExt,
        OscillatorNodeScheduledSourceNodeMiscExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when the source node has stopped playing
  Future<void> clearOnended();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// A-rate [`AudioParam`] that defines a transposition according to the
  /// frequency, expressed in cents.
  ///
  /// see <https://en.wikipedia.org/wiki/Cent_(music)>
  ///
  /// The final frequency is calculated as follow: frequency * 2^(detune/1200)
  AudioParam get detune;

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// A-rate [`AudioParam`] that defines the fundamental frequency of the
  /// oscillator, expressed in Hz
  ///
  /// The final frequency is calculated as follow: frequency * 2^(detune/1200)
  AudioParam get frequency;

  /// `OscillatorNode` is a source node. A source node is by definition with no input
  Future<int> numberOfInputs();

  /// `OscillatorNode` is a mono source node.
  Future<int> numberOfOutputs();

  Future<void> registration();

  Future<void> setOnEnded({required FutureOr<void> Function(Event) callback});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  /// Sets a `PeriodicWave` which describes a waveform to be used by the oscillator.
  ///
  /// Calling this sets the oscillator type to `custom`, once set to `custom`
  /// the oscillator cannot be reverted back to a standard waveform.
  Future<void> setPeriodicWave({required PeriodicWave periodicWave});

  /// Set the oscillator type
  ///
  /// # Arguments
  ///
  /// * `type_` - oscillator type (sine, square, triangle, sawtooth)
  ///
  /// # Panics
  ///
  /// if `type_` is `OscillatorType::Custom`
  Future<void> setType({required OscillatorType type});

  Future<void> start();

  Future<void> startAt({required double when});

  Future<void> stop();

  Future<void> stopAt({required double when});

  /// Returns the oscillator type
  Future<OscillatorType> type();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>
abstract class PannerNode
    implements RustOpaqueInterface, AudioNode, PannerNodeExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  Future<double> coneInnerAngle();

  Future<double> coneOuterAngle();

  Future<double> coneOuterGain();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<DistanceModelType> distanceModel();

  Future<void> connect({required AudioNode dest});

  Future<double> maxDistance();

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  AudioParam get orientationX;

  AudioParam get orientationY;

  AudioParam get orientationZ;

  Future<PanningModelType> panningModel();

  AudioParam get positionX;

  AudioParam get positionY;

  AudioParam get positionZ;

  Future<double> refDistance();

  Future<void> registration();

  Future<double> rolloffFactor();

  Future<void> setConeInnerAngle({required double value});

  Future<void> setConeOuterAngle({required double value});

  /// Set the coneOuterGain attribute
  ///
  /// # Panics
  ///
  /// Panics if the provided value is not in the range [0, 1]
  Future<void> setConeOuterGain({required double value});

  Future<void> setDistanceModel({required DistanceModelType value});

  /// Set the maxDistance attribute
  ///
  /// # Panics
  ///
  /// Panics if the provided value is negative.
  Future<void> setMaxDistance({required double value});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  Future<void> setOrientation(
      {required double x, required double y, required double z});

  Future<void> setPanningModel({required PanningModelType value});

  Future<void> setPosition(
      {required double x, required double y, required double z});

  /// Set the refDistance attribute
  ///
  /// # Panics
  ///
  /// Panics if the provided value is negative.
  Future<void> setRefDistance({required double value});

  /// Set the rolloffFactor attribute
  ///
  /// # Panics
  ///
  /// Panics if the provided value is negative.
  Future<void> setRolloffFactor({required double value});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScriptProcessorNode>>
abstract class ScriptProcessorNode
    implements
        RustOpaqueInterface,
        AudioNode,
        ScriptProcessorNodeExt,
        ScriptProcessorNodeMiscExt {
  Future<int> bufferSize();

  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when the AudioProcessingEvent is dispatched
  Future<void> clearOnaudioprocess();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  Future<void> setOnaudioprocess(
      {required FutureOr<void> Function(AudioProcessingEvent) callback});

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  Future<void> registration();

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StereoPannerNode>>
abstract class StereoPannerNode
    implements RustOpaqueInterface, AudioNode, StereoPannerNodeExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  /// Returns the pan audio parameter
  AudioParam get pan;

  Future<void> registration();

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaveShaperNode>>
abstract class WaveShaperNode
    implements
        RustOpaqueInterface,
        AudioNode,
        WaveShaperNodeExt,
        WaveShaperNodeMiscExt {
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  Future<Float32List?> curve();

  Future<int> numberOfInputs();

  Future<int> numberOfOutputs();

  /// Returns the `oversample` faactor of this node
  Future<OverSampleType> oversample();

  Future<void> registration();

  /// Set the distortion `curve` of this node
  ///
  /// # Arguments
  ///
  /// * `curve` - the desired distortion `curve`
  ///
  /// # Panics
  ///
  /// Panics if a curve has already been given to the source (though `new` or through
  /// `set_curve`)
  Future<void> setCurve({required List<double> curve});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  /// set the `oversample` factor of this node
  ///
  /// # Arguments
  ///
  /// * `oversample` - the desired `OversampleType` variant
  Future<void> setOversample({required OverSampleType oversample});
}

abstract class AudioNode {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();
}

abstract class AudioScheduledSourceNode {
  /// Unset the callback to run when the source node has stopped playing
  Future<void> clearOnended();

  /// Play immediately
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> start();

  /// Schedule playback start at given timestamp
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> startAt({required double when});

  /// Stop immediately
  ///
  /// # Panics
  ///
  /// Panics if the source was already stopped
  Future<void> stop();

  /// Schedule playback stop at given timestamp
  ///
  /// # Panics
  ///
  /// Panics if the source was already stopped
  Future<void> stopAt({required double when});
}

/// Options for constructing an [`AnalyserNode`]
class AnalyserOptions {
  final int fftSize;
  final double maxDecibels;
  final double minDecibels;
  final double smoothingTimeConstant;
  final AudioNodeOptions audioNodeOptions;

  const AnalyserOptions({
    required this.fftSize,
    required this.maxDecibels,
    required this.minDecibels,
    required this.smoothingTimeConstant,
    required this.audioNodeOptions,
  });

  static Future<AnalyserOptions> default_() =>
      RustLib.instance.api.webAudioApiNodeAnalyserOptionsDefault();

  @override
  int get hashCode =>
      fftSize.hashCode ^
      maxDecibels.hashCode ^
      minDecibels.hashCode ^
      smoothingTimeConstant.hashCode ^
      audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AnalyserOptions &&
          runtimeType == other.runtimeType &&
          fftSize == other.fftSize &&
          maxDecibels == other.maxDecibels &&
          minDecibels == other.minDecibels &&
          smoothingTimeConstant == other.smoothingTimeConstant &&
          audioNodeOptions == other.audioNodeOptions;
}

/// Options for constructing an [`AudioBufferSourceNode`]
class AudioBufferSourceOptions {
  final AudioBuffer? buffer;
  final double detune;
  final bool loop;
  final double loopStart;
  final double loopEnd;
  final double playbackRate;

  const AudioBufferSourceOptions({
    this.buffer,
    required this.detune,
    required this.loop,
    required this.loopStart,
    required this.loopEnd,
    required this.playbackRate,
  });

  static Future<AudioBufferSourceOptions> default_() =>
      RustLib.instance.api.webAudioApiNodeAudioBufferSourceOptionsDefault();

  @override
  int get hashCode =>
      buffer.hashCode ^
      detune.hashCode ^
      loop.hashCode ^
      loopStart.hashCode ^
      loopEnd.hashCode ^
      playbackRate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioBufferSourceOptions &&
          runtimeType == other.runtimeType &&
          buffer == other.buffer &&
          detune == other.detune &&
          loop == other.loop &&
          loopStart == other.loopStart &&
          loopEnd == other.loopEnd &&
          playbackRate == other.playbackRate;
}

/// Options that can be used in constructing all AudioNodes.
class AudioNodeOptions {
  /// Desired number of channels for the [`AudioNode::channel_count`] attribute.
  final int channelCount;

  /// Desired mode for the [`AudioNode::channel_count_mode`] attribute.
  final ChannelCountMode channelCountMode;

  /// Desired mode for the [`AudioNode::channel_interpretation`] attribute.
  final ChannelInterpretation channelInterpretation;

  const AudioNodeOptions({
    required this.channelCount,
    required this.channelCountMode,
    required this.channelInterpretation,
  });

  static Future<AudioNodeOptions> default_() =>
      RustLib.instance.api.webAudioApiNodeAudioNodeOptionsDefault();

  @override
  int get hashCode =>
      channelCount.hashCode ^
      channelCountMode.hashCode ^
      channelInterpretation.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioNodeOptions &&
          runtimeType == other.runtimeType &&
          channelCount == other.channelCount &&
          channelCountMode == other.channelCountMode &&
          channelInterpretation == other.channelInterpretation;
}

/// Options for constructing a [`BiquadFilterNode`]
class BiquadFilterOptions {
  final double q;
  final double detune;
  final double frequency;
  final double gain;
  final BiquadFilterType type;
  final AudioNodeOptions audioNodeOptions;

  const BiquadFilterOptions({
    required this.q,
    required this.detune,
    required this.frequency,
    required this.gain,
    required this.type,
    required this.audioNodeOptions,
  });

  static Future<BiquadFilterOptions> default_() =>
      RustLib.instance.api.webAudioApiNodeBiquadFilterOptionsDefault();

  @override
  int get hashCode =>
      q.hashCode ^
      detune.hashCode ^
      frequency.hashCode ^
      gain.hashCode ^
      type.hashCode ^
      audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BiquadFilterOptions &&
          runtimeType == other.runtimeType &&
          q == other.q &&
          detune == other.detune &&
          frequency == other.frequency &&
          gain == other.gain &&
          type == other.type &&
          audioNodeOptions == other.audioNodeOptions;
}

/// Biquad filter types
enum BiquadFilterType {
  /// Allows frequencies below the cutoff frequency to pass through and
  /// attenuates frequencies above the cutoff. (12dB/oct rolloff)
  lowpass,

  /// Frequencies above the cutoff frequency are passed through, but
  /// frequencies below the cutoff are attenuated. (12dB/oct rolloff)
  highpass,

  /// Allows a range of frequencies to pass through and attenuates the
  /// frequencies below and above this frequency range.
  bandpass,

  /// Allows all frequencies through, except for a set of frequencies.
  notch,

  /// Allows all frequencies through, but changes the phase relationship
  /// between the various frequencies.
  allpass,

  /// Allows all frequencies through, but adds a boost (or attenuation) to
  /// a range of frequencies.
  peaking,

  /// Allows all frequencies through, but adds a boost (or attenuation) to
  /// the lower frequencies.
  lowshelf,

  /// Allows all frequencies through, but adds a boost (or attenuation) to
  /// the higher frequencies.
  highshelf,
  ;

  static Future<BiquadFilterType> default_() =>
      RustLib.instance.api.webAudioApiNodeBiquadFilterTypeDefault();
}

/// How channels must be matched between the node's inputs and outputs.
enum ChannelCountMode {
  /// `computedNumberOfChannels` is the maximum of the number of channels of all connections to an
  /// input. In this mode channelCount is ignored.
  max,

  /// `computedNumberOfChannels` is determined as for "max" and then clamped to a maximum value of
  /// the given channelCount.
  clampedMax,

  /// `computedNumberOfChannels` is the exact value as specified by the channelCount.
  explicit,
  ;
}

/// The meaning of the channels, defining how audio up-mixing and down-mixing will happen.
enum ChannelInterpretation {
  speakers,
  discrete,
  ;
}

/// Options for constructing a [`ChannelMergerNode`]
class ChannelMergerOptions {
  final int numberOfInputs;
  final AudioNodeOptions audioNodeOptions;

  const ChannelMergerOptions({
    required this.numberOfInputs,
    required this.audioNodeOptions,
  });

  static Future<ChannelMergerOptions> default_() =>
      RustLib.instance.api.webAudioApiNodeChannelMergerOptionsDefault();

  @override
  int get hashCode => numberOfInputs.hashCode ^ audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChannelMergerOptions &&
          runtimeType == other.runtimeType &&
          numberOfInputs == other.numberOfInputs &&
          audioNodeOptions == other.audioNodeOptions;
}

/// Options for constructing a [`ChannelSplitterNode`]
class ChannelSplitterOptions {
  final int numberOfOutputs;
  final AudioNodeOptions audioNodeOptions;

  const ChannelSplitterOptions({
    required this.numberOfOutputs,
    required this.audioNodeOptions,
  });

  static Future<ChannelSplitterOptions> default_() =>
      RustLib.instance.api.webAudioApiNodeChannelSplitterOptionsDefault();

  @override
  int get hashCode => numberOfOutputs.hashCode ^ audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChannelSplitterOptions &&
          runtimeType == other.runtimeType &&
          numberOfOutputs == other.numberOfOutputs &&
          audioNodeOptions == other.audioNodeOptions;
}

/// Options for constructing an [`ConstantSourceNode`]
class ConstantSourceOptions {
  /// Initial parameter value of the constant signal
  final double offset;

  const ConstantSourceOptions({
    required this.offset,
  });

  static Future<ConstantSourceOptions> default_() =>
      RustLib.instance.api.webAudioApiNodeConstantSourceOptionsDefault();

  @override
  int get hashCode => offset.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConstantSourceOptions &&
          runtimeType == other.runtimeType &&
          offset == other.offset;
}

/// `ConvolverNode` options
class ConvolverOptions {
  /// The desired buffer for the ConvolverNode
  final AudioBuffer? buffer;

  /// The opposite of the desired initial value for the normalize attribute
  final bool disableNormalization;

  /// AudioNode options
  final AudioNodeOptions audioNodeOptions;

  const ConvolverOptions({
    this.buffer,
    required this.disableNormalization,
    required this.audioNodeOptions,
  });

  static Future<ConvolverOptions> default_() =>
      RustLib.instance.api.webAudioApiNodeConvolverOptionsDefault();

  @override
  int get hashCode =>
      buffer.hashCode ^
      disableNormalization.hashCode ^
      audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConvolverOptions &&
          runtimeType == other.runtimeType &&
          buffer == other.buffer &&
          disableNormalization == other.disableNormalization &&
          audioNodeOptions == other.audioNodeOptions;
}

/// Options for constructing a [`DelayNode`]
class DelayOptions {
  final double maxDelayTime;
  final double delayTime;
  final AudioNodeOptions audioNodeOptions;

  const DelayOptions({
    required this.maxDelayTime,
    required this.delayTime,
    required this.audioNodeOptions,
  });

  static Future<DelayOptions> default_() =>
      RustLib.instance.api.webAudioApiNodeDelayOptionsDefault();

  @override
  int get hashCode =>
      maxDelayTime.hashCode ^ delayTime.hashCode ^ audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DelayOptions &&
          runtimeType == other.runtimeType &&
          maxDelayTime == other.maxDelayTime &&
          delayTime == other.delayTime &&
          audioNodeOptions == other.audioNodeOptions;
}

/// Algorithm to reduce the volume of an audio source as it moves away from the listener
enum DistanceModelType {
  linear,
  inverse,
  exponential,
  ;

  static Future<DistanceModelType> default_() =>
      RustLib.instance.api.webAudioApiNodeDistanceModelTypeDefault();
}

/// Options for constructing a [`DynamicsCompressorNode`]
class DynamicsCompressorOptions {
  final double attack;
  final double knee;
  final double ratio;
  final double release;
  final double threshold;
  final AudioNodeOptions audioNodeOptions;

  const DynamicsCompressorOptions({
    required this.attack,
    required this.knee,
    required this.ratio,
    required this.release,
    required this.threshold,
    required this.audioNodeOptions,
  });

  static Future<DynamicsCompressorOptions> default_() =>
      RustLib.instance.api.webAudioApiNodeDynamicsCompressorOptionsDefault();

  @override
  int get hashCode =>
      attack.hashCode ^
      knee.hashCode ^
      ratio.hashCode ^
      release.hashCode ^
      threshold.hashCode ^
      audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DynamicsCompressorOptions &&
          runtimeType == other.runtimeType &&
          attack == other.attack &&
          knee == other.knee &&
          ratio == other.ratio &&
          release == other.release &&
          threshold == other.threshold &&
          audioNodeOptions == other.audioNodeOptions;
}

/// Options for constructing a [`GainNode`]
class GainOptions {
  final double gain;
  final AudioNodeOptions audioNodeOptions;

  const GainOptions({
    required this.gain,
    required this.audioNodeOptions,
  });

  static Future<GainOptions> default_() =>
      RustLib.instance.api.webAudioApiNodeGainOptionsDefault();

  @override
  int get hashCode => gain.hashCode ^ audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GainOptions &&
          runtimeType == other.runtimeType &&
          gain == other.gain &&
          audioNodeOptions == other.audioNodeOptions;
}

/// Options for constructing an [`OscillatorNode`]
class OscillatorOptions {
  /// The shape of the periodic waveform
  final OscillatorType type;

  /// The frequency of the fundamental frequency.
  final double frequency;

  /// A detuning value (in cents) which will offset the frequency by the given amount.
  final double detune;

  /// Optional custom waveform, if specified (set `type` to "custom")
  final PeriodicWave? periodicWave;

  /// channel config options
  final AudioNodeOptions audioNodeOptions;

  const OscillatorOptions({
    required this.type,
    required this.frequency,
    required this.detune,
    this.periodicWave,
    required this.audioNodeOptions,
  });

  static Future<OscillatorOptions> default_() =>
      RustLib.instance.api.webAudioApiNodeOscillatorOptionsDefault();

  @override
  int get hashCode =>
      type.hashCode ^
      frequency.hashCode ^
      detune.hashCode ^
      periodicWave.hashCode ^
      audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OscillatorOptions &&
          runtimeType == other.runtimeType &&
          type == other.type &&
          frequency == other.frequency &&
          detune == other.detune &&
          periodicWave == other.periodicWave &&
          audioNodeOptions == other.audioNodeOptions;
}

/// Type of the waveform rendered by an `OscillatorNode`
enum OscillatorType {
  /// Sine wave
  sine,

  /// Square wave
  square,

  /// Sawtooth wave
  sawtooth,

  /// Triangle wave
  triangle,

  /// type used when periodic_wave is specified
  custom,
  ;

  static Future<OscillatorType> default_() =>
      RustLib.instance.api.webAudioApiNodeOscillatorTypeDefault();
}

/// enumerates the oversampling rate available for `WaveShaperNode`
enum OverSampleType {
  /// No oversampling is applied
  none,

  /// Oversampled by a factor of 2
  x2,

  /// Oversampled by a factor of 4
  x4,
  ;

  static Future<OverSampleType> default_() =>
      RustLib.instance.api.webAudioApiNodeOverSampleTypeDefault();
}

/// Options for constructing a [`PannerNode`]
class PannerOptions {
  final PanningModelType panningModel;
  final DistanceModelType distanceModel;
  final double positionX;
  final double positionY;
  final double positionZ;
  final double orientationX;
  final double orientationY;
  final double orientationZ;
  final double refDistance;
  final double maxDistance;
  final double rolloffFactor;
  final double coneInnerAngle;
  final double coneOuterAngle;
  final double coneOuterGain;
  final AudioNodeOptions audioNodeOptions;

  const PannerOptions({
    required this.panningModel,
    required this.distanceModel,
    required this.positionX,
    required this.positionY,
    required this.positionZ,
    required this.orientationX,
    required this.orientationY,
    required this.orientationZ,
    required this.refDistance,
    required this.maxDistance,
    required this.rolloffFactor,
    required this.coneInnerAngle,
    required this.coneOuterAngle,
    required this.coneOuterGain,
    required this.audioNodeOptions,
  });

  static Future<PannerOptions> default_() =>
      RustLib.instance.api.webAudioApiNodePannerOptionsDefault();

  @override
  int get hashCode =>
      panningModel.hashCode ^
      distanceModel.hashCode ^
      positionX.hashCode ^
      positionY.hashCode ^
      positionZ.hashCode ^
      orientationX.hashCode ^
      orientationY.hashCode ^
      orientationZ.hashCode ^
      refDistance.hashCode ^
      maxDistance.hashCode ^
      rolloffFactor.hashCode ^
      coneInnerAngle.hashCode ^
      coneOuterAngle.hashCode ^
      coneOuterGain.hashCode ^
      audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PannerOptions &&
          runtimeType == other.runtimeType &&
          panningModel == other.panningModel &&
          distanceModel == other.distanceModel &&
          positionX == other.positionX &&
          positionY == other.positionY &&
          positionZ == other.positionZ &&
          orientationX == other.orientationX &&
          orientationY == other.orientationY &&
          orientationZ == other.orientationZ &&
          refDistance == other.refDistance &&
          maxDistance == other.maxDistance &&
          rolloffFactor == other.rolloffFactor &&
          coneInnerAngle == other.coneInnerAngle &&
          coneOuterAngle == other.coneOuterAngle &&
          coneOuterGain == other.coneOuterGain &&
          audioNodeOptions == other.audioNodeOptions;
}

/// Spatialization algorithm used to position the audio in 3D space
enum PanningModelType {
  equalPower,
  hrtf,
  ;

  static Future<PanningModelType> default_() =>
      RustLib.instance.api.webAudioApiNodePanningModelTypeDefault();
}

/// Options for constructing a [`StereoPannerOptions`]
class StereoPannerOptions {
  /// initial value for the pan parameter
  final double pan;

  /// audio node options
  final AudioNodeOptions audioNodeOptions;

  const StereoPannerOptions({
    required this.pan,
    required this.audioNodeOptions,
  });

  static Future<StereoPannerOptions> default_() =>
      RustLib.instance.api.webAudioApiNodeStereoPannerOptionsDefault();

  @override
  int get hashCode => pan.hashCode ^ audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StereoPannerOptions &&
          runtimeType == other.runtimeType &&
          pan == other.pan &&
          audioNodeOptions == other.audioNodeOptions;
}

/// `WaveShaperNode` options
class WaveShaperOptions {
  /// The distortion curve
  final Float32List? curve;

  /// Oversampling rate - default to `None`
  final OverSampleType oversample;

  /// audio node options
  final AudioNodeOptions audioNodeOptions;

  const WaveShaperOptions({
    this.curve,
    required this.oversample,
    required this.audioNodeOptions,
  });

  static Future<WaveShaperOptions> default_() =>
      RustLib.instance.api.webAudioApiNodeWaveShaperOptionsDefault();

  @override
  int get hashCode =>
      curve.hashCode ^ oversample.hashCode ^ audioNodeOptions.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WaveShaperOptions &&
          runtimeType == other.runtimeType &&
          curve == other.curve &&
          oversample == other.oversample &&
          audioNodeOptions == other.audioNodeOptions;
}
