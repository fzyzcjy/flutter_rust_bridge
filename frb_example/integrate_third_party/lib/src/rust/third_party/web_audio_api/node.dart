// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.42.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../api/override_web_audio_api.dart';
import '../../frb_generated.dart';
import '../web_audio_api.dart';
import 'media_streams.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'worklet.dart';

// These functions are ignored because they have generic arguments: `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect_from_output_to_input`, `connect`, `connect`, `connect`, `set_onended`, `set_onended`, `set_onended`, `set_onended`
// These types are ignored because they are not used by any `pub` functions: `AnalyserOptions`, `AudioBufferSourceOptions`, `AudioNodeOptions`, `BiquadFilterOptions`, `ChannelConfig`, `ChannelMergerOptions`, `ChannelSplitterOptions`, `ConstantSourceOptions`, `ConvolverOptions`, `DelayOptions`, `DynamicsCompressorOptions`, `GainOptions`, `IIRFilterOptions`, `MediaElementAudioSourceOptions`, `MediaStreamAudioSourceOptions`, `MediaStreamRenderer`, `MediaStreamTrackAudioSourceOptions`, `OscillatorOptions`, `PannerOptions`, `ScriptProcessorOptions`, `StereoPannerOptions`, `WaveShaperOptions`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `context`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest_from_output`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `disconnect_dest`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`, `set_onprocessorerror`
// These functions are ignored (category: IgnoreBecauseNotAllowedOwner): `channel_config`, `channel_count_mode`, `channel_count`, `channel_interpretation`, `clear_onprocessorerror`, `context`, `disconnect_dest_from_output_to_input`, `disconnect_dest_from_output`, `disconnect_dest`, `disconnect_output`, `disconnect`, `number_of_inputs`, `number_of_outputs`, `registration`, `set_channel_count_mode`, `set_channel_count`, `set_channel_interpretation`, `set_onprocessorerror`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AnalyserNode>>
abstract class AnalyserNode
    implements RustOpaqueInterface, AnalyserNodeExt, AudioNode {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  /// The size of the FFT used for frequency-domain analysis (in sample-frames)
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<int> fftSize();

  Future<void> connect({required AudioNode dest});

  /// Number of bins in the FFT results, is half the FFT size
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<int> frequencyBinCount();

  /// Maximum power value in the scaling range for the FFT analysis data for
  /// conversion to unsigned byte values. The default value is -30.
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<double> maxDecibels();

  /// Minimum power value in the scaling range for the FFT analysis data for
  /// conversion to unsigned byte values. The default value is -100.
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<double> minDecibels();

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  /// Set FFT size
  ///
  /// # Panics
  ///
  /// This function panics if fft_size is not a power of two or not in the range [32, 32768]
  Future<void> setFftSize({required int fftSize});

  /// Set max decibels
  ///
  /// # Panics
  ///
  /// This function panics if the value is set to a value less than or equal
  /// to min decibels.
  Future<void> setMaxDecibels({required double value});

  /// Set min decibels
  ///
  /// # Panics
  ///
  /// This function panics if the value is set to a value more than or equal
  /// to max decibels.
  Future<void> setMinDecibels({required double value});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  /// Set smoothing time constant
  ///
  /// # Panics
  ///
  /// This function panics if the value is set to a value less than 0 or more than 1.
  Future<void> setSmoothingTimeConstant({required double value});

  /// Time averaging parameter with the last analysis frame.
  /// A value from 0 -> 1 where 0 represents no time averaging with the last
  /// analysis frame. The default value is 0.8.
  ///
  /// # Panics
  ///
  /// This method may panic if the lock to the inner analyser is poisoned
  Future<double> smoothingTimeConstant();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioBufferSourceNode>>
abstract class AudioBufferSourceNode
    implements
        RustOpaqueInterface,
        AudioBufferSourceNodeExt,
        AudioBufferSourceNodeScheduledSourceNodeMiscExt,
        AudioNode,
        AudioScheduledSourceNode {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when the source node has stopped playing
  Future<void> clearOnended();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// K-rate [`AudioParam`] that defines a pitch transposition of the file,
  /// expressed in cents
  ///
  /// see <https://en.wikipedia.org/wiki/Cent_(music)>
  AudioParam get detune;

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// Defines if the playback the [`AudioBuffer`] should be looped
  Future<bool> loop();

  /// Defines the loop end point, in the time reference of the [`AudioBuffer`]
  Future<double> loopEnd();

  /// Defines the loop start point, in the time reference of the [`AudioBuffer`]
  Future<double> loopStart();

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// K-rate [`AudioParam`] that defines the speed at which the [`AudioBuffer`]
  /// will be played, e.g.:
  /// - `0.5` will play the file at half speed
  /// - `-1` will play the file in reverse
  ///
  /// Note that playback rate will also alter the pitch of the [`AudioBuffer`]
  AudioParam get playbackRate;

  /// Current playhead position in seconds within the [`AudioBuffer`].
  ///
  /// This value is updated at the end of each render quantum.
  ///
  /// Unofficial v2 API extension, not part of the spec yet.
  /// See also: <https://github.com/WebAudio/web-audio-api/issues/2397#issuecomment-709478405>
  Future<double> position();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Provide an [`AudioBuffer`] as the source of data to be played bask
  ///
  /// # Panics
  ///
  /// Panics if a buffer has already been given to the source (though `new` or through
  /// `set_buffer`)
  Future<void> setBuffer({required AudioBuffer audioBuffer});

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setLoop({required bool value});

  Future<void> setLoopEnd({required double value});

  Future<void> setLoopStart({required double value});

  Future<void> setOnEnded({required FutureOr<void> Function(Event) callback});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  /// Play immediately
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> start();

  /// Schedule playback start at given timestamp
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> startAt({required double when});

  /// Start the playback at the given time and with a given offset
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> startAtWithOffset(
      {required double start, required double offset});

  /// Start the playback at the given time, with a given offset, for a given duration
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> startAtWithOffsetAndDuration(
      {required double start,
      required double offset,
      required double duration});

  /// Stop immediately
  ///
  /// # Panics
  ///
  /// Panics if the source was already stopped
  Future<void> stop();

  /// Schedule playback stop at given timestamp
  ///
  /// # Panics
  ///
  /// Panics if the source was already stopped
  Future<void> stopAt({required double when});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<AudioDestinationNode>>
abstract class AudioDestinationNode
    implements RustOpaqueInterface, AudioDestinationNodeExt, AudioNode {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// The maximum number of channels that the channelCount attribute can be set to (the max
  /// number of channels that the hardware is capable of supporting).
  /// <https://www.w3.org/TR/webaudio/#dom-audiodestinationnode-maxchannelcount>
  Future<int> maxChannelCount();

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<BiquadFilterNode>>
abstract class BiquadFilterNode
    implements RustOpaqueInterface, AudioNode, BiquadFilterNodeExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Returns the detune audio parameter
  AudioParam get detune;

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// Returns the frequency audio parameter
  AudioParam get frequency;

  /// Returns the gain audio parameter
  AudioParam get gain;

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Returns the Q audio parameter
  AudioParam get q;

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  /// biquad filter type setter
  ///
  /// # Arguments
  ///
  /// * `type_` - the biquad filter type (lowpass, highpass,...)
  Future<void> setType({required BiquadFilterType type});

  /// Returns the biquad filter type
  Future<BiquadFilterType> type();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelMergerNode>>
abstract class ChannelMergerNode
    implements RustOpaqueInterface, AudioNode, ChannelMergerNodeExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ChannelSplitterNode>>
abstract class ChannelSplitterNode
    implements RustOpaqueInterface, AudioNode, ChannelSplitterNodeExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConstantSourceNode>>
abstract class ConstantSourceNode
    implements
        RustOpaqueInterface,
        AudioNode,
        AudioScheduledSourceNode,
        ConstantSourceNodeExt,
        ConstantSourceNodeScheduledSourceNodeMiscExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when the source node has stopped playing
  Future<void> clearOnended();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  AudioParam get offset;

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnEnded({required FutureOr<void> Function(Event) callback});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  /// Play immediately
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> start();

  /// Schedule playback start at given timestamp
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> startAt({required double when});

  /// Stop immediately
  ///
  /// # Panics
  ///
  /// Panics if the source was already stopped
  Future<void> stop();

  /// Schedule playback stop at given timestamp
  ///
  /// # Panics
  ///
  /// Panics if the source was already stopped
  Future<void> stopAt({required double when});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ConvolverNode>>
abstract class ConvolverNode
    implements RustOpaqueInterface, AudioNode, ConvolverNodeExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// Denotes if the response buffer will be scaled with an equal-power normalization
  Future<bool> normalize();

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Set or update the impulse response buffer
  ///
  /// # Panics
  ///
  /// Panics when the sample rate of the provided AudioBuffer differs from the audio context
  /// sample rate.
  Future<void> setBuffer({required AudioBuffer buffer});

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  /// Update the `normalize` setting. This will only have an effect when `set_buffer` is called.
  Future<void> setNormalize({required bool value});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DelayNode>>
abstract class DelayNode
    implements RustOpaqueInterface, AudioNode, DelayNodeExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// A-rate [`AudioParam`] representing the amount of delay (in seconds) to apply.
  AudioParam get delayTime;

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DynamicsCompressorNode>>
abstract class DynamicsCompressorNode
    implements RustOpaqueInterface, AudioNode, DynamicsCompressorNodeExt {
  AudioParam get attack;

  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  AudioParam get knee;

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  AudioParam get ratio;

  Future<double> reduction();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  AudioParam get release;

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  AudioParam get threshold;
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GainNode>>
abstract class GainNode implements RustOpaqueInterface, AudioNode, GainNodeExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  AudioParam get gain;

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<IIRFilterNode>>
abstract class IirFilterNode
    implements RustOpaqueInterface, AudioNode, IIRFilterNodeExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaElementAudioSourceNode>>
abstract class MediaElementAudioSourceNode
    implements RustOpaqueInterface, AudioNode, MediaElementAudioSourceNodeExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioDestinationNode>>
abstract class MediaStreamAudioDestinationNode
    implements
        RustOpaqueInterface,
        AudioNode,
        MediaStreamAudioDestinationNodeExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  /// A [`MediaStream`] producing audio buffers with the same number of channels as the node
  /// itself
  Future<MediaStream> stream();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamAudioSourceNode>>
abstract class MediaStreamAudioSourceNode
    implements RustOpaqueInterface, AudioNode, MediaStreamAudioSourceNodeExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MediaStreamTrackAudioSourceNode>>
abstract class MediaStreamTrackAudioSourceNode
    implements
        RustOpaqueInterface,
        AudioNode,
        MediaStreamTrackAudioSourceNodeExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<OscillatorNode>>
abstract class OscillatorNode
    implements
        RustOpaqueInterface,
        AudioNode,
        AudioScheduledSourceNode,
        OscillatorNodeExt,
        OscillatorNodeScheduledSourceNodeMiscExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when the source node has stopped playing
  Future<void> clearOnended();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// A-rate [`AudioParam`] that defines a transposition according to the
  /// frequency, expressed in cents.
  ///
  /// see <https://en.wikipedia.org/wiki/Cent_(music)>
  ///
  /// The final frequency is calculated as follow: frequency * 2^(detune/1200)
  AudioParam get detune;

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// A-rate [`AudioParam`] that defines the fundamental frequency of the
  /// oscillator, expressed in Hz
  ///
  /// The final frequency is calculated as follow: frequency * 2^(detune/1200)
  AudioParam get frequency;

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnEnded({required FutureOr<void> Function(Event) callback});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  /// Sets a `PeriodicWave` which describes a waveform to be used by the oscillator.
  ///
  /// Calling this sets the oscillator type to `custom`, once set to `custom`
  /// the oscillator cannot be reverted back to a standard waveform.
  Future<void> setPeriodicWave({required PeriodicWave periodicWave});

  /// Set the oscillator type
  ///
  /// # Arguments
  ///
  /// * `type_` - oscillator type (sine, square, triangle, sawtooth)
  ///
  /// # Panics
  ///
  /// if `type_` is `OscillatorType::Custom`
  Future<void> setType({required OscillatorType type});

  /// Play immediately
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> start();

  /// Schedule playback start at given timestamp
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> startAt({required double when});

  /// Stop immediately
  ///
  /// # Panics
  ///
  /// Panics if the source was already stopped
  Future<void> stop();

  /// Schedule playback stop at given timestamp
  ///
  /// # Panics
  ///
  /// Panics if the source was already stopped
  Future<void> stopAt({required double when});

  /// Returns the oscillator type
  Future<OscillatorType> type();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PannerNode>>
abstract class PannerNode
    implements RustOpaqueInterface, AudioNode, PannerNodeExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  Future<double> coneInnerAngle();

  Future<double> coneOuterAngle();

  Future<double> coneOuterGain();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<DistanceModelType> distanceModel();

  Future<void> connect({required AudioNode dest});

  Future<double> maxDistance();

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  AudioParam get orientationX;

  AudioParam get orientationY;

  AudioParam get orientationZ;

  Future<PanningModelType> panningModel();

  AudioParam get positionX;

  AudioParam get positionY;

  AudioParam get positionZ;

  Future<double> refDistance();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  Future<double> rolloffFactor();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setConeInnerAngle({required double value});

  Future<void> setConeOuterAngle({required double value});

  /// Set the coneOuterGain attribute
  ///
  /// # Panics
  ///
  /// Panics if the provided value is not in the range [0, 1]
  Future<void> setConeOuterGain({required double value});

  Future<void> setDistanceModel({required DistanceModelType value});

  /// Set the maxDistance attribute
  ///
  /// # Panics
  ///
  /// Panics if the provided value is negative.
  Future<void> setMaxDistance({required double value});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  Future<void> setOrientation(
      {required double x, required double y, required double z});

  Future<void> setPanningModel({required PanningModelType value});

  Future<void> setPosition(
      {required double x, required double y, required double z});

  /// Set the refDistance attribute
  ///
  /// # Panics
  ///
  /// Panics if the provided value is negative.
  Future<void> setRefDistance({required double value});

  /// Set the rolloffFactor attribute
  ///
  /// # Panics
  ///
  /// Panics if the provided value is negative.
  Future<void> setRolloffFactor({required double value});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ScriptProcessorNode>>
abstract class ScriptProcessorNode
    implements RustOpaqueInterface, AudioNode, ScriptProcessorNodeExt {
  Future<int> bufferSize();

  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when the AudioProcessingEvent is dispatched
  Future<void> clearOnaudioprocess();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<StereoPannerNode>>
abstract class StereoPannerNode
    implements RustOpaqueInterface, AudioNode, StereoPannerNodeExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Returns the pan audio parameter
  AudioParam get pan;

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<WaveShaperNode>>
abstract class WaveShaperNode
    implements
        RustOpaqueInterface,
        AudioNode,
        WaveShaperNodeExt,
        WaveShaperNodeMiscExt {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  Future<void> connect({required AudioNode dest});

  Future<Float32List?> curve();

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Returns the `oversample` faactor of this node
  Future<OverSampleType> oversample();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});

  /// Set the distortion `curve` of this node
  ///
  /// # Arguments
  ///
  /// * `curve` - the desired distortion `curve`
  ///
  /// # Panics
  ///
  /// Panics if a curve has already been given to the source (though `new` or through
  /// `set_curve`)
  Future<void> setCurve({required List<double> curve});

  Future<void> setOnProcessorError(
      {required FutureOr<void> Function(String) callback});

  /// set the `oversample` factor of this node
  ///
  /// # Arguments
  ///
  /// * `oversample` - the desired `OversampleType` variant
  Future<void> setOversample({required OverSampleType oversample});
}

abstract class AudioNode {
  /// Config for up/down-mixing of input channels for this node.
  ///
  /// Only when implementing the [`AudioNode`] trait manually, this struct is of any concern.
  Future<void> channelConfig();

  /// Represents an integer used to determine how many channels are used when up-mixing and
  /// down-mixing connections to any inputs to the node.
  Future<int> channelCount();

  /// Represents an enumerated value describing the way channels must be matched between the
  /// node's inputs and outputs.
  Future<ChannelCountMode> channelCountMode();

  /// Represents an enumerated value describing the meaning of the channels. This interpretation
  /// will define how audio up-mixing and down-mixing will happen.
  Future<ChannelInterpretation> channelInterpretation();

  /// Unset the callback to run when an unhandled exception occurs in the audio processor.
  Future<void> clearOnprocessorerror();

  /// Disconnects all outgoing connections from the AudioNode.
  Future<void> disconnect();

  /// Disconnects all outgoing connections at the given output port from the AudioNode.
  ///
  /// # Panics
  ///
  /// This function will panic when
  /// - if the output port is out of bounds for this node
  Future<void> disconnectOutput({required int output});

  /// The number of inputs feeding into the AudioNode. For source nodes, this will be 0.
  Future<int> numberOfInputs();

  /// The number of outputs coming out of the AudioNode.
  Future<int> numberOfOutputs();

  /// Handle of the associated [`BaseAudioContext`](crate::context::BaseAudioContext).
  ///
  /// Only when implementing the AudioNode trait manually, this struct is of any concern.
  Future<void> registration();

  /// Update the `channel_count` attribute
  Future<void> setChannelCount({required int v});

  /// Update the `channel_count_mode` attribute
  Future<void> setChannelCountMode({required ChannelCountMode v});

  /// Update the `channel_interpretation` attribute
  Future<void> setChannelInterpretation({required ChannelInterpretation v});
}

abstract class AudioScheduledSourceNode {
  /// Unset the callback to run when the source node has stopped playing
  Future<void> clearOnended();

  /// Play immediately
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> start();

  /// Schedule playback start at given timestamp
  ///
  /// # Panics
  ///
  /// Panics if the source was already started
  Future<void> startAt({required double when});

  /// Stop immediately
  ///
  /// # Panics
  ///
  /// Panics if the source was already stopped
  Future<void> stop();

  /// Schedule playback stop at given timestamp
  ///
  /// # Panics
  ///
  /// Panics if the source was already stopped
  Future<void> stopAt({required double when});
}

/// Biquad filter types
enum BiquadFilterType {
  /// Allows frequencies below the cutoff frequency to pass through and
  /// attenuates frequencies above the cutoff. (12dB/oct rolloff)
  lowpass,

  /// Frequencies above the cutoff frequency are passed through, but
  /// frequencies below the cutoff are attenuated. (12dB/oct rolloff)
  highpass,

  /// Allows a range of frequencies to pass through and attenuates the
  /// frequencies below and above this frequency range.
  bandpass,

  /// Allows all frequencies through, except for a set of frequencies.
  notch,

  /// Allows all frequencies through, but changes the phase relationship
  /// between the various frequencies.
  allpass,

  /// Allows all frequencies through, but adds a boost (or attenuation) to
  /// a range of frequencies.
  peaking,

  /// Allows all frequencies through, but adds a boost (or attenuation) to
  /// the lower frequencies.
  lowshelf,

  /// Allows all frequencies through, but adds a boost (or attenuation) to
  /// the higher frequencies.
  highshelf,
  ;
}

/// How channels must be matched between the node's inputs and outputs.
enum ChannelCountMode {
  /// `computedNumberOfChannels` is the maximum of the number of channels of all connections to an
  /// input. In this mode channelCount is ignored.
  max,

  /// `computedNumberOfChannels` is determined as for "max" and then clamped to a maximum value of
  /// the given channelCount.
  clampedMax,

  /// `computedNumberOfChannels` is the exact value as specified by the channelCount.
  explicit,
  ;
}

/// The meaning of the channels, defining how audio up-mixing and down-mixing will happen.
enum ChannelInterpretation {
  speakers,
  discrete,
  ;
}

/// Algorithm to reduce the volume of an audio source as it moves away from the listener
enum DistanceModelType {
  linear,
  inverse,
  exponential,
  ;
}

/// Type of the waveform rendered by an `OscillatorNode`
enum OscillatorType {
  /// Sine wave
  sine,

  /// Square wave
  square,

  /// Sawtooth wave
  sawtooth,

  /// Triangle wave
  triangle,

  /// type used when periodic_wave is specified
  custom,
  ;
}

/// enumerates the oversampling rate available for `WaveShaperNode`
enum OverSampleType {
  /// No oversampling is applied
  none,

  /// Oversampled by a factor of 2
  x2,

  /// Oversampled by a factor of 4
  x4,
  ;
}

/// Spatialization algorithm used to position the audio in 3D space
enum PanningModelType {
  equalPower,
  hrtf,
  ;
}
