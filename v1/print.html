<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>flutter_rust_bridge</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">flutter_rust_bridge</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>The documentation of flutter_rust_bridge v1.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h1>
<p>Write down Rust functions and types normally.</p>
<pre><code class="language-rust ignore">// A normal Rust function ...
pub fn draw_tree(root: TreeNode, mode: DrawMode) -&gt; Result&lt;Vec&lt;u8&gt;&gt; { /* ... */ }

// ... with rich types
pub struct TreeNode { pub value: String, pub children: Vec&lt;MyTreeNode&gt; }
pub enum DrawMode { Colorful {palette: String}, Grayscale }</code></pre>
<p>Install the code generator <code>flutter_rust_bridge_codegen</code>:</p>
<pre><code class="language-bash">cargo install flutter_rust_bridge_codegen
# or with cargo-binstall
cargo binstall flutter_rust_bridge_codegen
# or with scoop (Windows)
scoop bucket add frb https://github.com/Desdaemon/scoop-repo
scoop install flutter_rust_bridge_codegen
# or with Homebrew
brew install desdaemon/repo/flutter_rust_bridge_codegen
</code></pre>
<p><small>(Remark: Thanks @Desdaemon for scripts to publish to brew/scoop)</small></p>
<p>Then run the code generator.</p>
<p><small>Remark: It needs some installation steps. You may refer to <a href="tutorial_with_flutter.html">the tutorial</a>, <a href="template.html">create new projects from a template</a> or <a href="integrate.html">integrating with existing projects</a> for details.</small></p>
<pre><code class="language-bash">flutter_rust_bridge_codegen --rust-input path/to/api.rs \
                            --dart-output path/to/bridge_generated.dart
</code></pre>
<p>With bindings automatically generated, use it seamlessly in Flutter/Dart:</p>
<pre><code class="language-dart">api.drawTree(TreeNode(value: "root", ...), Colorful(palette: "viridis"));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-a-flutterrust-app"><a class="header" href="#tutorial-a-flutterrust-app">Tutorial: A Flutter+Rust app</a></h1>
<p>In this tutorial, let us draw a <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot set</a> (a well-known infinite-resolution "image" generated by a simple math formula). The image is plotted in Flutter UI, generated by Rust algorithm, and communicated via this library.</p>
<!-- markdownlint-disable MD033 -->
<details>
<summary>(Click to see: What is a Mandelbrot set)</summary>
<p>The Mandelbrot set is the set of complex numbers <code>c</code> for which the function <code>f_c(z)=z^{2}+c</code> does not diverge to infinity when iterated from <code>z=0</code>. Images of the Mandelbrot set exhibit an elaborate and infinitely complicated boundary that reveals progressively ever-finer recursive detail at increasing magnifications.</p>
<p align="center">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Mandelbrot_sequence_new.gif/220px-Mandelbrot_sequence_new.gif">
</p>
<p>Image credit: <a href="https://en.wikipedia.org/wiki/User:Simpsons_contributor">Simpsons contributor</a></p>
</details>
<h2 id="get-code"><a class="header" href="#get-code">Get code</a></h2>
<p>Please <a href="https://flutter.dev/docs/get-started/install">install Flutter</a> (optionally with <a href="https://flutter.dev/desktop">desktop support</a> if you want to run app on desktop instead of cellphones), <a href="https://www.rust-lang.org/learn/get-started">install Rust</a>, and have some familiarity with them. Then get the example codebase:</p>
<pre><code class="language-shell">git clone https://github.com/fzyzcjy/flutter_rust_bridge &amp;&amp; cd flutter_rust_bridge/frb_example/with_flutter
</code></pre>
<h2 id="optional-run-generator"><a class="header" href="#optional-run-generator">Optional: Run generator</a></h2>
<p>This step is optional, since I have generated the source code already (in quickstart). Even if you do it, you should not see anything changed.</p>
<p>As soon as you make any modification to <code>api.rs</code>, you need to run codegen again. More information about requirements for code generation can be seen in the <a href="integrate/deps.html">Installing dependencies</a> section.</p>
<p>At this step you may need to <a href="./integrate/deps.html">setup dependencies</a>.</p>
<h2 id="run-app"><a class="header" href="#run-app">Run app</a></h2>
<h3 id="prelogue-command-details"><a class="header" href="#prelogue-command-details">Prelogue: Command details</a></h3>
<p>The <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/workflows/ci.yaml">CI workflow</a> is useful if you want details of each command. The <code>flutter_android_test</code>, <code>flutter_ios_test</code>, <code>flutter_windows_test</code>, <code>flutter_macos_test</code> and <code>flutter_linux_test</code> demonstrates the exact commands needed to run this tutorial codebase from a brand new machine.</p>
<h3 id="android-app"><a class="header" href="#android-app">Android app</a></h3>
<p>See <a href="tutorial/setup_android.html">Android setup</a></p>
<h3 id="ios-app"><a class="header" href="#ios-app">iOS app</a></h3>
<p>Modify <code>Cargo.toml</code> to change <code>cdylib</code> to <code>staticlib</code>, then run <code>cargo lipo &amp;&amp; cp target/universal/debug/libflutter_rust_bridge_example.a ../ios/Runner</code> to build Rust and copy the static library. Then run the Flutter app normally such as <code>flutter run</code>.</p>
<p><strong>Remark</strong>: <a href="https://stackoverflow.com/q/69515032/4619958">This tutorial</a> will help you automatically execute <code>cargo</code> builds when building Flutter app.</p>
<h3 id="windows-app"><a class="header" href="#windows-app">Windows app</a></h3>
<p>Run it directly using <code>flutter run</code> assuming <a href="https://flutter.dev/desktop#set-up">Flutter desktop support</a> has been configured. More details can be seen in <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/66">#66</a>.</p>
<h3 id="linux-app"><a class="header" href="#linux-app">Linux app</a></h3>
<p>Same as Windows. If you install Flutter through <code>snap</code>, please be wary of <a href="https://github.com/canonical/flutter-snap/issues/53">#53</a>.</p>
<h3 id="macos-app"><a class="header" href="#macos-app">MacOS app</a></h3>
<p>Same as Windows. (P.S. Under the hood, <code>cargo-xcode</code> is used to automate the process)</p>
<h3 id="web-as-a-webpage"><a class="header" href="#web-as-a-webpage">Web (as a webpage)</a></h3>
<p>Install <code>flutter_rust_bridge_serve</code> to simplify the process of building and serving a WASM binary.
See <a href="template/setup_web.html">Web setup</a> for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android-setup"><a class="header" href="#android-setup">Android setup</a></h1>
<h2 id="jdk-8"><a class="header" href="#jdk-8">JDK 8</a></h2>
<p>Android Studio depends on the <code>javax</code> library being present in the Java runtime, and the only reliable way to ensure this is to install an older version of Java. On Unix-like systems, you can use <a href="https://asdf-vm.com/">asdf</a> or similar tools to manage your Java versions, and the template defines a known working version of Java in the <code>.tool-versions</code> file.</p>
<h2 id="android-ndk"><a class="header" href="#android-ndk">Android NDK</a></h2>
<p><a href="https://github.com/rust-lang/rust/pull/85806">An issue</a> regarding building Rust's <code>core</code> library against the latest NDK means that when using Rust 1.67 and lower, only NDK versions 22 and older can be used. The issue has been patched in Rust 1.68, which is not yet stable at the time of writing.</p>
<p>Rust &lt; 1.68:</p>
<blockquote>
<p>Android Studio &gt; SDK Manager &gt; SDK Tools &gt; uncheck Hide Obsolete Packages &gt; NDK (version 22)</p>
</blockquote>
<p>Rust &gt;= 1.68:</p>
<blockquote>
<p>Android Studio &gt; SDK Manager &gt; SDK Tools &gt; NDK (side by side)</p>
</blockquote>
<p>The <a href="https://developer.android.com/ndk">Android NDK</a>, or Native Development Kit, enables code written in other
languages to be run on the JVM via the <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html">Java Native Interface</a>, or JNI for short. In this case, we would like to pass the dynamic libraries created by Cargo to be included in the bundle when we run or build the project.</p>
<p>After following the instructions above, the NDK should be installed in your <code>$ANDROID_HOME/ndk</code> folder, where <code>ANDROID_HOME</code> usually is:</p>
<ul>
<li>on Windows: <code>%APPDATA%\Local\Android\sdk</code></li>
<li>on MacOS: <code>~/Library/Android/sdk</code></li>
<li>on Linux: set via the environment variable <code>ANDROID_HOME</code>, or <code>~/Android/sdk</code></li>
</ul>
<h2 id="android_ndk-gradle-property"><a class="header" href="#android_ndk-gradle-property"><code>ANDROID_NDK</code> Gradle property</a></h2>
<pre><code class="language-shell">echo "ANDROID_NDK=(path to NDK)" &gt;&gt; ~/.gradle/gradle.properties
</code></pre>
<p>Next, you need to make this NDK visible to Gradle. The way to do this depends on your current system and is unlikely to be portable, but generally you can add a <code>gradle.properties</code> in your <code>~/.gradle</code> folder like this:</p>
<pre><code>ANDROID_NDK=(path to NDK)
</code></pre>
<p>or edit one of the <code>gradle.properties</code> that resides within the <code>android</code> folder.</p>
<h2 id="cargo-ndk"><a class="header" href="#cargo-ndk"><a href="https://github.com/bbqsrc/cargo-ndk">cargo-ndk</a></a></h2>
<p><a href="https://github.com/bbqsrc/cargo-ndk">cargo-ndk</a> is a Cargo plugin for compiling code suitable for plugging into
the JNI without additional configuration.
Version 2.7.0 of cargo-ndk introduced changes that broke support for NDK
version 22, so 2.6.0 must be used if you are on a Rust version below 1.68. If you still want to use cargo-ndk 2.7.0 or above on Rust versions below 1.68 with
a workaround, see <a href="tutorial/./alternative_ndk.html">this article</a>.</p>
<p>Rust &lt; 1.68:</p>
<pre><code class="language-shell">cargo install cargo-ndk --version 2.6.0
</code></pre>
<p>Rust &gt;= 1.68:</p>
<pre><code class="language-shell">cargo install cargo-ndk
</code></pre>
<p>Then run (all Rust versions)</p>
<pre><code class="language-shell">cargo ndk -o ../android/app/src/main/jniLibs build
</code></pre>
<p>Then run the Flutter app normally with <code>flutter run</code>.</p>
<p><strong>Remark</strong>: <a href="https://stackoverflow.com/q/69515032/4619958">This tutorial</a> will help you automatically execute <code>cargo</code> builds when building Flutter app.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alternative-ndk-setup"><a class="header" href="#alternative-ndk-setup">Alternative NDK setup</a></h1>
<p>This is only needed if you wish to use a version of the Android NDK higher than version 22 with versions of Rust that are lower than version 1.68.
This guide details how to prevent the <a href="https://github.com/bbqsrc/cargo-ndk/issues/22">unable to find library -lgcc error</a>.</p>
<h2 id="android-ndk-1"><a class="header" href="#android-ndk-1">Android NDK</a></h2>
<p>Install the latest NDK:</p>
<blockquote>
<p>Android Studio &gt; SDK Manager &gt; SDK Tools &gt; NDK (Side by side)</p>
</blockquote>
<p>Click on OK at the bottom right corner to start the installation.</p>
<h2 id="cargo-ndk-1"><a class="header" href="#cargo-ndk-1"><a href="https://github.com/bbqsrc/cargo-ndk">cargo-ndk</a></a></h2>
<p>You should install <code>cargo-ndk</code> version 2.7.0 or above which works for
Android NDK versions greater than 22.</p>
<pre><code>cargo install cargo-ndk --version ^2.7.0
</code></pre>
<p>A workaround may be under development in the cargo-ndk project. Until it is finished,
you need to manually create four text files to redirect calls from libgcc to libunwind (<a href="https://github.com/rust-lang/rust/pull/85806#issuecomment-1096266946">reference</a>):</p>
<ol>
<li>
<p>Find out all the 4 folders containing file <code>libunwind.a</code>.</p>
<ul>
<li>
<p>On Windows, it is similar to:</p>
<pre><code>C:\Users\Administrator\AppData\Local\Android\Sdk\ndk\24.0.8215888\toolchains\llvm\prebuilt\windows-x86_64\lib64\clang\14.0.1\lib\linux\x86_64\
</code></pre>
</li>
<li>
<p>On macOS Monterey, it is similar to:</p>
<pre><code>~/Library/Android/sdk/ndk/24.0.8215888/toolchains/llvm/prebuilt/darwin-x86_64/lib64/clang/14.0.1/lib/linux/x86_64/
</code></pre>
</li>
</ul>
<p>The three other folders end with <code>aarch64</code>, <code>arm</code>,    <code>i386</code> instead of <code>x86_64</code>.</p>
</li>
<li>
<p>Create 4 text files named <code>libgcc.a</code> in the four folders mentioned above with these contents</p>
<pre><code>INPUT(-lunwind)
</code></pre>
</li>
</ol>
<h2 id="more-details-on-ndk-with-flutter_rust_bridge"><a class="header" href="#more-details-on-ndk-with-flutter_rust_bridge">More details on NDK with flutter_rust_bridge</a></h2>
<p>For more details on how NDK works with <code>flutter_rust_bridge</code>, have a look at this <a href="tutorial/../integrate/android_tasks.html">article</a> please.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>In this chapter, we are going to demonstrate the features. Please use the menu bar at the left / left-top of the page to navigate.</p>
<h2 id="prelogue"><a class="header" href="#prelogue">Prelogue</a></h2>
<h3 id="what-this-library-is-and-is-not"><a class="header" href="#what-this-library-is-and-is-not">What this library is and is not</a></h3>
<p>This library is nothing but a code generator that helps your Flutter/Dart functions call Rust functions. It only generates some boilerplate code that you will manually write down otherwise. Moreover, we have provided detailed tutorials for you to play with examples, set up brand new apps, and integrate with existing apps.</p>
<p>Of course, you may still need to have some basic familiarity with Flutter/Dart, Rust, and its ffi. (Link for <a href="https://docs.flutter.dev/platform-integration/android/c-interop">Android</a>, <a href="https://docs.flutter.dev/platform-integration/ios/c-interop">iOS</a> and <a href="https://docs.flutter.dev/platform-integration/macos/c-interop">macOS</a>)</p>
<h3 id="full-examples"><a class="header" href="#full-examples">Full examples</a></h3>
<p>If you want to look at a lot of examples - I have to warn you, really too many - have a look at <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/pure_dart/rust/src/api.rs">pure_dart's api.rs</a>. It contains all tests for this library.</p>
<p>In addition, when you are quite familiar with the basic example, you can then take a look at <a href="https://github.com/fzyzcjy/flutter_rust_bridge/tree/master/frb_example/pure_dart_multi/rust/src">pure_dart_multi</a>. This example contains multiple blocks of APIs instead of one, which is quite useful for complex projects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-translations"><a class="header" href="#language-translations">Language translations</a></h1>
<p>In this section, we will show how various language features are translated between Rust and Dart.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-correspondence"><a class="header" href="#simple-correspondence">Simple correspondence</a></h1>
<p>Here is a brief glance showing what the code generator can generate (non-exhaustive). Some rows have hyper-links pointing to more detailed explanations.</p>
<div class="table-wrapper"><table><thead><tr><th>Rust</th><th>Dart</th></tr></thead><tbody>
<tr><td><a href="feature/lang_vec.html"><code>Vec&lt;u8&gt;</code>..<code>Vec&lt;u64&gt;</code></a></td><td><code>Uint8List</code>..<code>Uint64List</code></td></tr>
<tr><td><a href="feature/lang_vec.html"><code>Vec&lt;i8&gt;</code>..<code>Vec&lt;i64&gt;</code></a></td><td><code>Int8List</code>..<code>Int64List</code></td></tr>
<tr><td><a href="feature/lang_vec.html"><code>Vec&lt;f32&gt;</code>, <code>Vec&lt;f64&gt;</code></a></td><td><code>Float32List</code>, <code>Float64List</code></td></tr>
<tr><td><a href="feature/lang_vec.html"><code>Vec&lt;T&gt;</code></a></td><td><code>List&lt;T&gt;</code></td></tr>
<tr><td><a href="feature/lang_vec.html"><code>[T; N]</code></a></td><td><code>List&lt;T&gt;</code></td></tr>
<tr><td><a href="feature/lang_struct.html"><code>struct { .. }</code>, <code>struct( .. )</code></a></td><td><code>class</code></td></tr>
<tr><td><a href="feature/lang_enum.html"><code>enum { A, B }</code></a></td><td><code>enum</code></td></tr>
<tr><td><a href="feature/lang_enum.html"><code>enum { A(..) }</code></a></td><td><code>@freezed sealed class</code></td></tr>
<tr><td><a href="feature/lang_external.html"><code>use ...</code></a></td><td>act normally</td></tr>
<tr><td><a href="feature/lang_option.html"><code>Option&lt;T&gt;</code></a></td><td><code>T?</code></td></tr>
<tr><td><a href="feature/lang_rust_opaque.html">Arbitrary Rust types (opaque)</a></td><td><code>RustOpaque</code></td></tr>
<tr><td><code>DartOpaque</code></td><td><a href="feature/lang_dart_opaque.html">Arbitrary Dart types (opaque)</a></td></tr>
<tr><td><a href="feature/lang_exceptions.html"><code>Result::Err</code>, panic</a></td><td><code>throw Exception</code></td></tr>
<tr><td><code>Box&lt;T&gt;</code></td><td><code>T</code></td></tr>
<tr><td>comments</td><td>same</td></tr>
<tr><td><code>i8</code>, <code>u8</code>, .., <code>usize</code></td><td><code>int</code></td></tr>
<tr><td><code>f32</code>, <code>f64</code></td><td><code>double</code></td></tr>
<tr><td><code>bool</code></td><td><code>bool</code></td></tr>
<tr><td><code>String</code></td><td><code>String</code></td></tr>
<tr><td><code>()</code></td><td><code>void</code></td></tr>
<tr><td><code>type A = B</code></td><td><a href="feature/lang_type_alias.html">type alias</a></td></tr>
<tr><td><a href="feature/lang_tuple.html"><code>(T, U, ..)</code></a></td><td><a href="https://dart.dev/language/records"><code>(T, U, ..)</code></a></td></tr>
</tbody></table>
</div>
<p>Types from <code>chrono</code> crate are supported as a feature, see <a href="feature/lang_chrono.html">here</a>.
Types from <code>uuid</code> crate are supported as a feature, see <a href="feature/lang_uuid.html">here</a>.</p>
<p>Raw strings are supported for struct field names. For example, you can have <code>struct S { r#type: i32 }</code>. In dart, the <code>r#</code> prefix will be correctly removed. They are not yet supported for function arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vec-and-array"><a class="header" href="#vec-and-array">Vec and array</a></h1>
<h2 id="vecu8-veci8-"><a class="header" href="#vecu8-veci8-"><code>Vec&lt;u8&gt;</code>, <code>Vec&lt;i8&gt;</code>, ...</a></h2>
<p>In Dart, when you want to express a long byte array such as a big image or some binary blob, people normally use <code>Uint8List</code> instead of <code>List&lt;int&gt;</code> since the former is much performant. <code>flutter_rust_bridge</code> takes this into consideration for you. When you have <code>Vec&lt;u8&gt;</code> (or <code>Vec&lt;i8&gt;</code>, or <code>Vec&lt;i32&gt;</code>, etc), it will be translated into <code>Uint8List</code> or its friends.</p>
<p><a href="feature/lang_simple.html">This section</a> provides more details about <code>Vec&lt;u8&gt;</code> and its friends.</p>
<h2 id="vect"><a class="header" href="#vect"><code>Vec&lt;T&gt;</code></a></h2>
<p>When you have normal <code>Vec&lt;T&gt;</code> for <code>T</code> types other than <code>u8</code>, <code>i8</code> etc, it will be converted to normal <code>List&lt;T&gt;</code>.</p>
<p>Remark: <code>Vec&lt;Box&lt;T&gt;&gt;</code> is not supported yet though fixable (<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/1072">#1072</a>), but according to <a href="https://rust-lang.github.io/rust-clippy/master/index.html#vec_box">clippy lints</a>, it is usually better to use <code>Vec&lt;T&gt;</code> directly.</p>
<h2 id="t-n"><a class="header" href="#t-n"><code>[T; N]</code></a></h2>
<p>Since Dart does not have special treatment for static-sized arrays, it is converted to <code>List&lt;T&gt;</code> as well.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-rust noplayground">pub fn draw_tree(tree: Vec&lt;TreeNode&gt;) -&gt; Vec&lt;u8&gt; { ... }</code></pre>
<p>Becomes:</p>
<pre><code class="language-Dart">Future&lt;Uint8List&gt; drawTree({required List&lt;TreeNode&gt; tree});
</code></pre>
<p>Remark: If you are curious about <code>Future</code>, have a look at <a href="feature/async_dart.html">this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs"><code>struct</code>s</a></h1>
<p>Normal Rust structs are supported. You can even use recursive fields, such as <code>pub struct TreeNode { pub value: String, pub children: Vec&lt;MyTreeNode&gt;, pub parent: Box&lt;MyTreeNode&gt; }</code>.</p>
<p>For versions older than v1.66.0 (no need for latest version), if a struct field has type being a struct or an enum, please add a <code>Box</code> on it, or it will lead to compile-time error. For example, <code>struct A {b: B}</code> should be <code>struct A {b: Box&lt;B&gt;}</code> instead.</p>
<h2 id="tuple-structs"><a class="header" href="#tuple-structs">Tuple structs</a></h2>
<p>Tuple structs <code>struct Foo(A, B)</code> are translated as <code>class Foo { A field0; B field1; }</code>, since Dart does not have anonymous fields.</p>
<h2 id="non-final-fields"><a class="header" href="#non-final-fields">Non-final fields</a></h2>
<p>By adding <code>#[frb(non_final)]</code> to a field of struct, the corresponding field in Dart will be non-final. By default, we make all generated fields final because of Rust's philosophy - immutable by default.</p>
<p>Unless a field has been annotated with <code>#[frb(non_final)]</code>, generated classes will also be const-constructible.</p>
<h2 id="dart-metadata-annotations"><a class="header" href="#dart-metadata-annotations">Dart metadata annotations</a></h2>
<p>You can add dart metadata annotations using <code>dart_metadata</code> parameter in <code>frb</code> macro.</p>
<ul>
<li>For annotations that are prelude by dart (e.g. <code>@deprecated</code>), just put annotation as a Rust literal.</li>
<li>If importing is needed, then add importing part behind the annotation string. Currently two forms of importing supported:
<ul>
<li><code>import 'somepackage'</code></li>
<li><code>import 'somepackage' as somename</code>, where <code>somename</code> will be the prefix of the annotation</li>
</ul>
</li>
<li>Multiple annotations are separated by comma <code>,</code>.</li>
</ul>
<p>See below for an example.</p>
<h2 id="freezed-dart-classes"><a class="header" href="#freezed-dart-classes"><code>freezed</code> Dart classes</a></h2>
<p>If you want the generated Dart class to be <a href="https://pub.dev/packages/freezed"><code>freezed</code></a> (which is like data-classes in other languages like Kotlin), simply put <code>#[frb(dart_metadata=("freezed"))]</code> and it will generate everything needed for you.</p>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<h3 id="example-1-recursive-fields"><a class="header" href="#example-1-recursive-fields">Example 1: Recursive fields</a></h3>
<pre><code class="language-rust noplayground">pub struct MyTreeNode {
    pub value: Vec&lt;u8&gt;,
    pub children: Vec&lt;MyTreeNode&gt;,
}</code></pre>
<p>Becomes:</p>
<pre><code class="language-Dart">class MyTreeNode {
  final Uint8List value;
  final List&lt;MyTreeNode&gt; children;
  MyTreeNode({required this.value, required this.children});
}
</code></pre>
<p>Remark: If you are curious about <code>Future</code>, have a look at <a href="feature/async_dart.html">this</a>.</p>
<h3 id="example-2-metadata"><a class="header" href="#example-2-metadata">Example 2: Metadata</a></h3>
<pre><code class="language-rust noplayground">#[frb(dart_metadata=("freezed", "immutable" import "package:meta/meta.dart" as meta))]
pub struct UserId {
    pub value: u32,
}</code></pre>
<p>Becomes:</p>
<pre><code class="language-dart">import 'package:meta/meta.dart' as meta;

@freezed
@meta.immutable
class UserId with _$UserId {
  const factory UserId({
    required int value,
  }) = _UserId;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums"><code>enum</code>s</a></h1>
<p>Rust's <code>enum</code> are known to be very expressive and powerful - it allows each enum variant to have different associated data. Dart does not have such things in built-in enums, but no worries - we will automatically translate it into the equivalent using the <code>freezed</code> Dart library. The syntax for <code>freezed</code> may look a bit strange at the first glance, but please look at <a href="https://pub.dev/packages/freezed">its doc</a> and see its powerfulness.</p>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<pre><code class="language-rust noplayground">pub enum KitchenSink {
    Empty,
    Primitives {
        /// Dart field comment
        int32: i32,
        float64: f64,
        boolean: bool,
    },
    Nested(Box&lt;KitchenSink&gt;),
    Optional(
        /// Comment on anonymous field
        Option&lt;i32&gt;,
        Option&lt;i32&gt;,
    ),
    Buffer(ZeroCopyBuffer&lt;Vec&lt;u8&gt;&gt;),
    Enums(Weekdays),
}</code></pre>
<p>Becomes:</p>
<pre><code class="language-Dart">@freezed
class KitchenSink with _$KitchenSink {
  /// Comment on variant
  const factory KitchenSink.empty() = Empty;
  const factory KitchenSink.primitives({
    /// Dart field comment
    required int int32,
    required double float64,
    required bool boolean,
  }) = Primitives;
  const factory KitchenSink.nested(
    KitchenSink field0,
  ) = Nested;
  const factory KitchenSink.optional([
    /// Comment on anonymous field
    int? field0,
    int? field1,
  ]) = Optional;
  const factory KitchenSink.buffer(
    Uint8List field0,
  ) = Buffer;
  const factory KitchenSink.enums(
    Weekdays field0,
  ) = Enums;
}
</code></pre>
<p>And they are powered with <a href="https://pub.dev/packages/freezed">all functionalities</a> of <code>freezed</code>.</p>
<p>Remark: If you are curious about <code>Future</code>, have a look at <a href="feature/async_dart.html">this</a>.</p>
<h2 id="pattern-matching-in-dart"><a class="header" href="#pattern-matching-in-dart">Pattern matching in Dart</a></h2>
<p>Introduced in Dart 3, sealed classes can be used to <a href="https://dart.dev/language/patterns">pattern match</a> values,
enabling exhaustive variant checks and refuable patterns among other capabilities. Refer to <a href="https://dart.dev/language/patterns#switch-statements-and-expressions">the documentation</a>
for more details.</p>
<p>This feature supersedes Freezed's <code>map</code> and <code>when</code> families of methods.
You can opt out of generating sealed classes by passing <code>--no-dart3</code> when running codegen.</p>
<pre><code class="language-rust noplayground">pub enum Maybe {
    None,
    Some { value: i32 },
}</code></pre>
<pre><code class="language-dart">Maybe maybe;
final value = switch (maybe) {
  Maybe_None() =&gt; 'got nothing',
  Maybe_Some(:final value) =&gt; 'got value: $value',
};
// single case à la if-let
if (maybe case Maybe_Some(:final value)) {
  ..
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<p>Introduced in Dart 3, <a href="https://dart.dev/language/records">records</a> provide the equivalent of Rust's tuples.
Tuples of up to 10 elements are supported, and more can be added by nesting tuples. Tuples can be returned,
received as parameters, and stored inside structs.</p>
<pre><code class="language-rust noplayground">pub fn my_coordinate() -&gt; (f64, f64);</code></pre>
<pre><code class="language-dart">(double, double) myCoordinate();
final (lat, long) = myCoordinate();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-types"><a class="header" href="#external-types">External types</a></h1>
<h2 id="types-in-other-files-within-the-same-crate"><a class="header" href="#types-in-other-files-within-the-same-crate">Types in other files within the same crate</a></h2>
<p>Imported symbols can be used normally. For example, with <code>use crate::data::{MyEnum, MyStruct};</code>, you can use <code>MyEnum</code> or <code>MyStruct</code> in your code normally.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-rust noplayground">use crate::data::{MyEnum, MyStruct};

pub fn use_imported_things(my_struct: MyStruct, my_enum: MyEnum) { ... }</code></pre>
<p>Becomes:</p>
<pre><code class="language-Dart">// Well it just behaves normally as you expect
Future&lt;void&gt; useImportedThings({required MyStruct myStruct, required MyEnum myEnum});
</code></pre>
<p>Remark: If you are curious about <code>Future</code>, have a look at <a href="feature/async_dart.html">this</a>.</p>
<h2 id="types-in-other-crates"><a class="header" href="#types-in-other-crates">Types in other crates</a></h2>
<p>The feature is called "mirroring". In short, you need to define the type again mirroring the external type that you want to use. That definition is only used at code-generation time to tell <code>flutter_rust_bridge</code> type information. To see exact grammar, have a look at the example below.</p>
<p>No need to worry whether this breaks the DRY principle, or what happens when you accidentally write down a wrong field. This is because <em>compile errors will happen</em> if your mirrored type is not exactly same as the original type.</p>
<p>More information: <a href="https://github.com/fzyzcjy/flutter_rust_bridge/pull/352">#352</a></p>
<p>When multiple structs have the same fields, you can mirror them <em>once</em> using grammar like <code>#[frb(mirror(FirstStruct, SecondStruct, ThirdStruct))]</code>. (<a href="https://github.com/fzyzcjy/flutter_rust_bridge/pull/619">#619</a>)</p>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-rust noplayground">// Mirroring example:
// The goal of mirroring is to use external objects without needing to convert them with an intermediate type
// In this case, the struct ApplicationSettings is defined in another crate (called external-lib)

// To use an external type with mirroring, it MUST be imported publicly (aka. re-export)
pub use external_lib::{ApplicationEnv, ApplicationMode, ApplicationSettings};

// To mirror an external struct, you need to define a placeholder type with the same definition
#[frb(mirror(ApplicationSettings))]
pub struct _ApplicationSettings {
    pub name: String,
    pub version: String,
    pub mode: ApplicationMode,
    pub env: Box&lt;ApplicationEnv&gt;,
}

// It works with basic enums too
// Enums with struct variants are not yet supported
#[frb(mirror(ApplicationMode))]
pub enum _ApplicationMode {
    Standalone,
    Embedded,
}

#[frb(mirror(ApplicationEnv))]
pub struct _ApplicationEnv {
    pub vars: Vec&lt;String&gt;,
}

// This function can directly return an object of the external type ApplicationSettings because it has a mirror
pub fn get_app_settings() -&gt; ApplicationSettings {
    external_lib::get_app_settings()
}

// Similarly, receiving an object from Dart works. Please note that the mirror definition must match entirely and the original struct must have all its fields public.
pub fn is_app_embedded(app_settings: ApplicationSettings) -&gt; bool {
    // println!("env: {}", app_settings.env.vars[0]);
    match app_settings.mode {
        ApplicationMode::Standalone =&gt; false,
        ApplicationMode::Embedded =&gt; true,
    }
}</code></pre>
<p>Another example using one struct to mirror multiple structs:</p>
<pre><code class="language-rust noplayground">// *no* need to do these
#[frb(mirror(MessageId))]
pub struct MId(pub [u8; 32]);
#[frb(mirror(BlobId))]
pub struct BId(pub [u8; 32]);
#[frb(mirror(FeedId))]
pub struct FId(pub [u8; 32]);

// simply do this is sufficient
#[frb(mirror(MessageId, BlobId, FeedId))]
pub struct Id(pub [u8; 32]);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options"><a class="header" href="#options"><code>Option</code>s</a></h1>
<p>Dart has special syntaxs for nullable variables - the <code>?</code> symbol, and we translate <code>Option</code> into <code>?</code> automatically. You may refer to <a href="https://dart.dev/null-safety">the official doc</a> for more information.</p>
<p>In addition, <code>flutter_rust_bridge</code> also understands the <code>required</code> keyword in Dart: If an argument is not-null, it is marked as <code>required</code> since you have to provide a value. On the other hand, if it is nullable, no <code>required</code> is needed since by Dart's convention a null is there in absence of manually providing a value.</p>
<h2 id="example-5"><a class="header" href="#example-5">Example</a></h2>
<pre><code class="language-rust noplayground">pub struct Element {
    pub tag: Option&lt;String&gt;,
    pub text: Option&lt;String&gt;,
    pub attributes: Option&lt;Vec&lt;Attribute&gt;&gt;,
    pub children: Option&lt;Vec&lt;Element&gt;&gt;,
}

pub fn parse(mode: String, document: Option&lt;String&gt;) -&gt; Option&lt;Element&gt; { ... }</code></pre>
<p>Becomes:</p>
<pre><code class="language-Dart">Future&lt;Element?&gt; handleOptionalStruct({required String mode, String? document});

class Element {
  final String? tag;
  final String? text;
  final List&lt;Attribute&gt;? attributes;
  final List&lt;Element&gt;? children;
  Element({this.tag, this.text, this.attributes, this.children});
}
</code></pre>
<p>Remark: If you are curious about <code>Future</code>, have a look at <a href="feature/async_dart.html">this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<p>There is support for structs with methods. Both static methods, and non-static methods are supported.</p>
<p>Related configuration: <code>--no-use-bridge-in-method</code> (see below for an example).</p>
<h2 id="example-6"><a class="header" href="#example-6">Example</a></h2>
<pre><code class="language-rust noplayground">pub struct SumWith { pub x: u32 }

impl SumWith {
    pub fn sum(&amp;self, y: u32) -&gt; u32 { self.x + y }
    pub fn sum_static(x: u32, y: u32) -&gt; u32 { x + y }
}</code></pre>
<p>Becomes:</p>
<pre><code class="language-Dart">class SumWith {
  final FlutterRustBridgeExampleSingleBlockTest bridge;
  final int x;

  SumWith({
    required this.bridge,
    required this.x,
  });

  Future&lt;int&gt; sum({required int y, dynamic hint}) =&gt; ..
  static Future&lt;int&gt; sum({required int x, required int y, dynamic hint}) =&gt; ..
}
</code></pre>
<p>Or show as follow if you use flag <code>--no-use-bridge-in-method</code>:</p>
<pre><code class="language-dart">class SumWith {
  final int x;

  const SumWith({
    required this.x,
  });

  Future&lt;int&gt; sum({required int y, dynamic hint}) =&gt; api.sumMethodSumWith(
        that: this,
        y: y,
      );

  static Future&lt;int&gt; sumStatic({required int x, required int y, dynamic hint}) =&gt;
      api.sumStaticStaticMethodSumWith(x: x, y: y, hint: hint);
}
</code></pre>
<p>Remark: If you are curious about <code>Future</code>, have a look at <a href="feature/async_dart.html">this</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return-types"><a class="header" href="#return-types">Return Types</a></h1>
<p>The return type can be either <code>anyhow::Result&lt;YourType&gt;</code>, or <code>YourType</code> directly. For exceptions (errors), please refer to <a href="feature/lang_exceptions.html">exceptions section</a> as well.</p>
<h2 id="example-7"><a class="header" href="#example-7">Example</a></h2>
<pre><code class="language-rust noplayground">pub fn f(a: i32, b: i32) -&gt; i32 { a + b }

pub fn g(a: i32, b: i32) -&gt; anyhow::Result&lt;i32&gt; { Ok(a + b) }</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-types"><a class="header" href="#dynamic-types">Dynamic Types</a></h1>
<p>Dart's <code>dynamic</code> is a special type that can hold any type of value. Although it is possible
to return a <code>dynamic</code> to Dart in the form of <a href="https://docs.rs/flutter_rust_bridge/latest/flutter_rust_bridge/ffi/type.DartAbi.html"><code>DartAbi</code></a>, it is preferable to
return an <code>enum</code> instead that has a variant for each type you want to support.</p>
<h2 id="example-8"><a class="header" href="#example-8">Example</a></h2>
<p>Let's say you have a struct that can hold either a <code>u32</code> or a <code>String</code> and some
other fields (in a significantly worse design):</p>
<pre><code class="language-rust noplayground">struct MyStruct {
    a: Optional&lt;u32&gt;,
    b: Optional&lt;String&gt;,
}

struct DataStruct {
    msg:  String,
    data: MyStruct,
}</code></pre>
<p>You can define an <code>enum</code> in Rust to represent this:</p>
<pre><code class="language-rust noplayground">enum MyEnum {
    U32(u32),
    String(String),
}</code></pre>
<p>And then you can define a struct that holds this <code>enum</code>:</p>
<pre><code class="language-rust noplayground">struct MyStruct {
    msg:  String,
    data: MyEnum,
}</code></pre>
<h2 id="returning-dynamics"><a class="header" href="#returning-dynamics">Returning <code>dynamic</code>s</a></h2>
<p>Aside from <a href="feature/./lang_dart_opaque.html"><code>DartOpaque</code></a>, you may also return a <code>dynamic</code> type to Dart by specifing the return type as <a href="https://docs.rs/flutter_rust_bridge/latest/flutter_rust_bridge/ffi/type.DartAbi.html"><code>DartAbi</code></a>.
<a href="https://docs.rs/flutter_rust_bridge/latest/flutter_rust_bridge/ffi/type.DartAbi.html"><code>DartAbi</code></a> is the umbrella type for all <a href="https://docs.rs/flutter_rust_bridge/latest/flutter_rust_bridge/ffi/io/ffi/enum.DartCObjectType.html">C-representable</a>
Dart values, which can be obtained from Rust types that implement
<a href="https://docs.rs/flutter_rust_bridge/latest/flutter_rust_bridge/ffi/trait.IntoDart.html"><code>IntoDart</code></a>.</p>
<pre><code class="language-rust noplayground">pub fn return_dynamic() -&gt; DartAbi {
    vec![
        ().into_dart(),
        0i32.into_dart(),
        format!("Hello there!").into_dart()
    ].into_dart()
}</code></pre>
<pre><code class="language-dart">final dynamic values = await api.returnDynamic();
assert(values is List&lt;dynamic&gt;);
assert(values[0] == null);
assert(values[1] == 0);
assert(values[2] == "Hello there!");
</code></pre>
<p><a href="https://docs.rs/flutter_rust_bridge/latest/flutter_rust_bridge/ffi/type.DartAbi.html"><code>DartAbi</code></a> is not supported as parameters, and structs that transitively include them may not be used in parameter positions either.
If you only care about accepting or returning an opaque Dart object without interacting with it, consider <a href="feature/./lang_dart_opaque.html"><code>DartOpaque</code></a>.</p>
<p>This type is meant to be used only as an esacpe hatch, if your data cannot be expressed as either a fixed <a href="feature/./lang_struct.html">struct</a> or <a href="feature/./lang_enum.html">enum</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arbitrary-rust-types-opaque"><a class="header" href="#arbitrary-rust-types-opaque">Arbitrary Rust types (opaque)</a></h1>
<p>On one hand, any Rust type, even if it is not supported using features of this library, can be used in Dart. This is done by wrapping it with <code>RustOpaque</code>.</p>
<p>The Rust opaque objects in Dart should be disposed <em>manually</em>, though it will also be disposed when it is GCed, that is discouraged, due to <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/775#issuecomment-1274635037">suggestions by Dart team</a>. Think of it just like a lot of Flutter objects that we are familiar with, such as <code>ui.Image</code> - we have to manually dispose them as well.</p>
<p>Different from non-opaque types, opaque types are not copied/moved/reconstructed at all. For example, if you pass around <code>RwLock&lt;Mutex&lt;ArbitraryData&gt;</code> in arguments and return values, you will get the exact <em>same</em> <code>RwLock&lt;ArbitraryData&gt;</code> object.</p>
<h2 id="example-rustopaque"><a class="header" href="#example-rustopaque">Example <code>RustOpaque</code></a></h2>
<p>Rust:</p>
<pre><code class="language-rust noplayground">struct ArbitraryData { ... }
pub fn use_opaque(a: RustOpaque&lt;ArbitraryData&gt;) { ... }
pub fn even_use_locks(b: RustOpaque&lt;Mutex&lt;ArbitraryData&gt;) -&gt; RustOpaque&lt;RwLock&lt;ArbitraryData&gt;&gt; { ... }
enum AnEnumContainingOpaque { Hello(RustOpaque&lt;ArbitraryData&gt;), World(i32) }
...</code></pre>
<p>And use it in Dart:</p>
<pre><code class="language-dart">var opaque = await api.functionThatCreatesSomeOpaqueData();
await api.functionThatUsesSomeOpaqueData(opaque);
opaque.dispose();
</code></pre>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation details</a></h2>
<p>As for how it is implemented as well as the design towards safety, please refer to <a href="feature/../contributing/rust_opaque_type_safety.html">this doc</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arbitrary-dart-types-opaque"><a class="header" href="#arbitrary-dart-types-opaque">Arbitrary Dart types (opaque)</a></h1>
<p>Any Dart type can be passed to Rust. This is done by wrapping it with <code>DartOpaque</code>.</p>
<p>This library ensures that any Dart objects are always removed on the parent Dart thread.</p>
<p>Different from non-opaque types, opaque types are not copied/moved/reconstructed at all. For example, if you pass around a Dart object <code>MyObject</code> in arguments and return values, you will get the exact <em>same</em> object.</p>
<h2 id="example-dartopaque"><a class="header" href="#example-dartopaque">Example <code>DartOpaque</code></a></h2>
<p>Rust:</p>
<pre><code class="language-rust noplayground">pub fn get_dart_opaque(a: DartOpaque) { ... }
pub fn return_dart_opaque() -&gt; DartOpaque { ... }
...</code></pre>
<p>And use it in Dart:</p>
<pre><code class="language-dart">var opaque = await api.getDartOpaque(() =&gt; '42');
Object answer_obj = await api.returnDartOpaque();
var fn = answer_obj as String Function();
print(fn());
</code></pre>
<h2 id="implementation-details-1"><a class="header" href="#implementation-details-1">Implementation details</a></h2>
<p>As for how it is implemented as well as the design towards safety, please refer to <a href="feature/../contributing/dart_opaque_type_safety.html">this doc</a>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-alias"><a class="header" href="#type-alias">Type alias</a></h1>
<p>Type alias is also supported. For example:</p>
<pre><code class="language-rust noplayground">enum MyEnum {...}
struct MyStruct {...}

// type aliases
pub type Id = u64;
pub type EnumAlias = MyEnum;
pub type StructAlias = MyStruct;

// can also use them in fields, etc
pub struct TestModel { pub id: Id, pub e: EnumAlias, pub s: StructAlias}

pub fn f(input: Id) -&gt; TestModel {...}</code></pre>
<h2 id="limitation"><a class="header" href="#limitation">Limitation</a></h2>
<p>The <code>ItemType</code> inside Generic is not supported yet, such as <code>SyncReturn&lt;Id&gt;</code>. The nested <code>ItemType</code> may also not be supported.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result--exceptions"><a class="header" href="#result--exceptions">Result / Exceptions</a></h1>
<ol>
<li>For Result/Error, the<code>anyhow::Result</code>/<code>anyhow::Error</code> is supported. It will be automatically converted to a Dart Exception.</li>
<li>For <code>panic</code>s, it will also be automatically captured and converted to Dart exceptions.</li>
<li>For error hierarchy, or arbitrary error types, it is also supported. For example, you can create your own <code>CustomError</code> (such as using <code>thiserror</code>), and it will automatically be converted to a new Dart class.</li>
</ol>
<p>If you want to see stack traces (backtraces), <a href="feature/stack_trace.html">this doc page</a> discusses how to configure it.</p>
<h2 id="example-9"><a class="header" href="#example-9">Example</a></h2>
<h3 id="example-1-anyhow-result"><a class="header" href="#example-1-anyhow-result">Example 1: Anyhow Result</a></h3>
<p>For example, the following code, when called by Dart code, will throw Dart exceptions.</p>
<pre><code class="language-rust noplayground">pub fn f() -&gt; anyhow::Result&lt;i32&gt; { bail!("oops I failed") }</code></pre>
<h3 id="example-2-panic"><a class="header" href="#example-2-panic">Example 2: Panic</a></h3>
<p>All functions below, when called, will throw Dart exceptions at the Dart side due to the <code>panic</code>.</p>
<pre><code class="language-rust noplayground">pub fn g1() -&gt; i32 { panic!("oops I failed") }
pub fn g2() -&gt; anyhow::Result&lt;String&gt; { panic!("oops I failed") }
pub fn g3() -&gt; Result&lt;Vec&lt;u8&gt;, CustomError&gt; { panic!("oops I failed") }</code></pre>
<h3 id="example-3-custom-error-without-backtrace"><a class="header" href="#example-3-custom-error-without-backtrace">Example 3: Custom Error Without backtrace</a></h3>
<pre><code class="language-rust noplayground">pub enum CustomError {
    Error0(String),
    Error1(u32),
}

pub fn return_err_custom_error() -&gt; Result&lt;u32, CustomError&gt; {
    Err(CustomError::Error1(3))
}</code></pre>
<p>Becomes something that can be used like this:</p>
<pre><code class="language-Dart">try {
    final r = await api.returnErrCustomError();
    print("received $r");
} catch (e) {
    print('dart catch e: $e');
    expect(e, isA&lt;CustomError&gt;());
}
</code></pre>
<h3 id="example-4-custom-error-with-backtrace"><a class="header" href="#example-4-custom-error-with-backtrace">Example 4: Custom Error With backtrace</a></h3>
<p>Errors with custom fields are also supported, and you can even pass a backtrace:</p>
<pre><code class="language-rust noplayground">pub enum CustomStructError {
    Error0 { e: String, backtrace: Backtrace },
    Error1 { e: u32, backtrace: Backtrace },
}</code></pre>
<p>As for how to fill it in or use it, you can refer to <code>thiserror</code> crate for some hints.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parameter-defaults"><a class="header" href="#parameter-defaults">Parameter defaults</a></h1>
<p>Dart allows default values for function and constructor parameters, and you can achieve the same effect using <code>#[frb(default)]</code>. The syntax is as follows:</p>
<ul>
<li>If the parameter is a <code>String</code> or any other primitive, <code>#[frb(default = ".." | 0 | true | ..)]</code> annotates its default value.</li>
<li>If the parameter is a class or an enum, <code>#[frb(default = "..")]</code> annotates the <em>Dart code</em> to initialize the parameter.
Note that this is run in the <em>constant context</em>, so classes can only be constructed if they are preceded with <code>const</code>.</li>
</ul>
<p>This will be translated to either a default value annotation, or Freezed's <code>@Default</code> in the case of enum constructor parameters.</p>
<pre><code class="language-rust noplayground">pub enum Answer { Yes, No }
pub struct Point(pub f64, pub f64);

#[frb]
pub fn defaults(
    #[frb(default = "Answer.Yes")]
    answer: Answer,
    #[frb(default = "const Point(field0: 2, field1: 3)")]
    point: Point,
);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-copy"><a class="header" href="#zero-copy">Zero copy</a></h1>
<p><code>ZeroCopyBuffer&lt;Vec&lt;u8&gt;&gt;</code> (and its friends like <code>ZeroCopyBuffer&lt;Vec&lt;i8&gt;&gt;</code>) sends the data from Rust to Dart without making copies<sup class="footnote-reference"><a href="#1">1</a></sup>. Thus, you save the time of copying data, which can be large if your data is big (such as a high-resolution image).</p>
<h2 id="make-it-the-default"><a class="header" href="#make-it-the-default">Make it the default</a></h2>
<p>If you don't want to wrap <code>Vec&lt;u8&gt;</code> and its friends with <code>ZeroCopyBuffer</code> over and over again to avoid copying memory, you can alternatively provide a cargo feature called <code>zero-copy</code>. With this feature enabled, <code>Vec&lt;u8&gt;</code> and its friends will be zero-copied by default.</p>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
flutter_rust_bridge = { version = "...", features = ["zero-copy"] }
</code></pre>
<h2 id="example-10"><a class="header" href="#example-10">Example</a></h2>
<pre><code class="language-rust noplayground">pub fn draw_tree(tree: Vec&lt;TreeNode&gt;) -&gt; ZeroCopyBuffer&lt;Vec&lt;u8&gt;&gt; { ... }</code></pre>
<p>Becomes:</p>
<pre><code class="language-Dart">Future&lt;Uint8List&gt; drawTree({required List&lt;TreeNode&gt; tree});
</code></pre>
<p>The generated Dart code looks exactly the same as the case without <code>ZeroCopyBuffer</code>. However, the internal implementation changes and now there is no memory copy at all!</p>
<p>If you are curious about what those <code>Vec&lt;u8&gt;</code> and its friends actually are, take a look at <a href="feature/lang_simple.html">this</a>.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Not currently supported on Web, and will fallback to copying the buffer.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stream--iterator"><a class="header" href="#stream--iterator"><code>Stream</code> / <code>Iterator</code></a></h1>
<p>What is <code>Stream</code>? In short: call once, return multiple times; like <code>Iterator</code>s.</p>
<p>Flutter's <a href="https://dart.dev/tutorials/language/streams">Stream</a> is a powerful abstraction. When using it as the return value of Rust function, we can allow the scenario that we call function once, and then return multiple times.</p>
<p>For example, your Rust function may run computationally heavy algorithms, and for every hundreds of milliseconds, it finds out a new piece of the full solution. In this case, it can immediately give that piece to Flutter, then Flutter can render it to UI immediately. Therefore, users do not need to wait for the full algorithm to finish before he can see some partial results on the user interface.</p>
<p>As for the details, a Rust function with signature like <code>fn f(sink: StreamSink&lt;T&gt;, ..) -&gt; Result&lt;()&gt;</code> is translated to a Dart function <code>Stream&lt;T&gt; f(..)</code>.</p>
<p>Notice that, you can hold that <code>StreamSink</code> forever, and use it freely even <em>after the Rust function itself returns</em>. The logger example below also demonstrates this (the <code>create_log_stream</code> returns almost immediately, while you can use the <code>StreamSink</code> after, say, an hour).</p>
<p>The <code>StreamSink</code> can be placed at any location. For example, <code>fn f(a: i32, b: StreamSink&lt;String&gt;)</code> and <code>fn f(a: StreamSink&lt;String&gt;, b: i32)</code> are both valid.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>See <a href="feature/logging.html">logging examples</a> which uses streams extensively.</p>
<h2 id="what-about-streaming-from-dartflutter-to-rust"><a class="header" href="#what-about-streaming-from-dartflutter-to-rust">What about streaming from Dart/Flutter to Rust?</a></h2>
<p>This is not currently supported. As a workaround, consider iterating through your Dart stream and calling a normal Rust function for each item.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-in-dart"><a class="header" href="#asynchronous-in-dart">Asynchronous in Dart</a></h1>
<p>This library generates functions that are <em>asynchronous</em> in Dart by default. So you will see <code>fn f(..) -&gt; String</code> becomes <code>Future&lt;String&gt; f(..)</code> with that interesting <code>Future</code>.</p>
<p>Why? Flutter UI is single-threaded. If you use the intuitive synchronous approach, just like what you will (have to) do with plain-old Flutter bindings, your UI will be <em>stuck</em> as long as your Rust code is executing. If your Rust code run for 100ms for a heavy computation, your UI will fully freeze for 100ms and the users will not be happy.</p>
<p>On the other hand, with the generated asynchronous bindings in Dart, you can simply call functions directly in main isolate (thread) of Dart/Flutter, and Rust code will not block the Flutter UI.</p>
<p>Indeed async and <code>Future</code>s is almost everywhere in Flutter/Dart, and it has very good built-in support. So no worries about it ;)</p>
<p>Remark: A common mistake is to call Rust code in <em>another</em> Dart isolate (i.e. "thread") instead of the main isolate. That is completely not needed, and will only make your life harder. As is described above, even if your Rust code computes for 100ms, the async call will only take, say, 0.1ms, and will not block your UI.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="synchronous-in-dart"><a class="header" href="#synchronous-in-dart">Synchronous in Dart</a></h1>
<p>If you need to generate synchronous functions in Dart, you can use <code>SyncReturn&lt;T&gt;</code> as the return type. It supports whatever types that we have described in other places, i.e. whatever types that async mode supports.</p>
<p>We suggest only do this for very quick Rust functions, or the Dart UI will be blocked.</p>
<p>If you are using the default handler, the behavior about threading is different from normal Rust functions. Normal function calls are executed in the <a href="feature/worker_pool.html">worker pool</a>. However, Rust functions with return type of <code>SyncReturn&lt;T&gt;</code> are executed on the <em>main</em> thread. This means that if a <code>SyncReturn&lt;T&gt;</code> function takes time, Dart UI will not be able to respond.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<p>Multiple Rust functions can be running at the same time, and they will be running concurrently. This is because by default we use a thread pool to execute the Rust functions. However, you can fully customize this behavior (and even throw away the thread pool).</p>
<h2 id="example-11"><a class="header" href="#example-11">Example</a></h2>
<p>Consider the following Rust code:</p>
<pre><code class="language-rust noplayground">pub fn compute() {
  thread::sleep(Duration::from_millis(1000));
}</code></pre>
<p>And the following Dart code using it:</p>
<pre><code class="language-dart">var a = compute();
var b = compute();
var c = compute();
await Future.wait([a, b, c]); // You may need to learn `Future` and `async` in Dart to understand this
</code></pre>
<p>Then it will take 1 second instead of 3 seconds to complete the code, because multiple <code>compute</code> can run concurrently.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handler"><a class="header" href="#handler">Handler</a></h1>
<p>By default, the <code>DefaultHandler</code> is used for handling function calls. You can implement your own <code>Handler</code> with other custom behaviors you want. In order to do this, create a module variable named <code>FLUTTER_RUST_BRIDGE_HANDLER</code> in <code>api.rs</code>(probably using <code>lazy_static</code>) of your project. You may not need to create a brand new struct implementing <code>Handler</code>, but instead, use the <code>SimpleHandler</code> and customize its generic arguments such as its <code>Executor</code>.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<h3 id="example-report-errors-to-your-backend-in-addition-to-telling-dart"><a class="header" href="#example-report-errors-to-your-backend-in-addition-to-telling-dart">Example: Report errors to your backend in addition to telling Dart</a></h3>
<pre><code class="language-rust noplayground">pub struct MyErrorHandler(ReportDartErrorHandler);

impl ErrorHandler for MyErrorHandler {
    fn handle_error(&amp;self, port: i64, error: handler::Error) {
        send_error_to_your_backend(&amp;error);
        self.0.handle_error(port, error)
    }

    ...
}</code></pre>
<h3 id="example-log-when-execution-starts-and-ends"><a class="header" href="#example-log-when-execution-starts-and-ends">Example: Log when execution starts and ends</a></h3>
<pre><code class="language-rust noplayground">pub struct MyExecutor(ThreadPoolExecutor&lt;MyErrorHandler&gt;);

impl Executor for MyExecutor {
    fn execute&lt;TaskFn, TaskRet&gt;(&amp;self, wrap_info: WrapInfo, task: TaskFn) {
        let debug_name_string = wrap_info.debug_name.to_string();
        self.thread_pool_executor
            .execute(wrap_info, move |task_callback| {
                Self::log_around(&amp;debug_name_string, move || task(task_callback))
            })
    }
}

impl MyExecutor {
    fn log_around&lt;F, R&gt;(debug_name: &amp;str, f: F) -&gt; R where F: FnOnce() -&gt; R {
        let start = Instant::now();
        debug!("(Rust) execute [{}] start", debug_name);
        let ret = f();
        debug!("(Rust) execute [{}] end delta_time={}ms", debug_name, start.elapsed().as_millis());
        ret
    }
}</code></pre>
<h3 id="example-use-a-simple-handler"><a class="header" href="#example-use-a-simple-handler">Example: Use a simple handler</a></h3>
<pre><code class="language-rust noplayground">// api.rs

use flutter_rust_bridge::handler::ReportDartErrorHandler;
use flutter_rust_bridge::handler::SimpleHandler;
use flutter_rust_bridge::handler::ThreadPoolExecutor;
use lazy_static::lazy_static;

lazy_static! {
    static ref FLUTTER_RUST_BRIDGE_HANDLER:
    SimpleHandler&lt;ThreadPoolExecutor&lt;ReportDartErrorHandler&gt;, ReportDartErrorHandler&gt; =
        SimpleHandler::new(
            ThreadPoolExecutor::new(ReportDartErrorHandler),
            ReportDartErrorHandler {}
        );
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initialization"><a class="header" href="#initialization">Initialization</a></h1>
<p>If you want that feature, have a look at <code>FlutterRustBridgeSetupMixin</code> in the Dart side. (More documentaions to be added; you can create an issue if you have questions now.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-in-rust"><a class="header" href="#async-in-rust">Async in Rust</a></h1>
<p>Currently, this feature has not been supported yet. However, it is implementable and the flutter_rust_bridge barely has assumption that user Rust functions should be sync. Issue <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/966">#966</a> has some discussions about how to implement it.</p>
<p><a href="feature/../article/async_in_rust.html">This</a> older article also describes some workarounds, which may be useful before the function is implemented.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-files"><a class="header" href="#multiple-files">Multiple files</a></h1>
<p>When having a large project, it is often insufficient to put everything in a single <code>api.rs</code>, but instead we may want to separate it into <code>api_of_one_module.rs</code>, <code>api_of_another_module.rs</code>, etc. That is why we have this feature.</p>
<p>Basically, just specify all input Rust files and all output locations and we are done. Here is an example:</p>
<pre><code class="language-shell">flutter_rust_bridge_codegen \
  --rust-input "$REPO_DIR/native/src/api_1.rs" "$REPO_DIR/native/src/api_2.rs" \
  --dart-output "$REPO_DIR/lib/bridge_generated_api_1.dart" "$REPO_DIR/lib/bridge_generated_api_2.dart" \
  --class-name ApiClass1 ApiClass2 \
  --rust-output generated_api_1 generated_api_2
</code></pre>
<p>For more details, have a look at <a href="feature/../article/generate_multiple_files.html">this article</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-in-buildrs"><a class="header" href="#run-in-buildrs">Run in <code>build.rs</code></a></h1>
<p>There are basically two approaches to execute the code generator. The first and most evident approach is to directly execute the <code>flutter_rust_bridge</code> in command line.</p>
<p>The second approach is to integrate it into <code>build.rs</code> of your project. With this approach, the code generator is automatically triggered whenever you build your Rust project. For example configuration, have a look at this <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/pure_dart/rust/build.rs">build.rs</a> file.</p>
<p>If the <code>build.rs</code> in the example projects is making it difficult to modify and test flutter_rust_bridge_codegen, you can rename it to disable it, and instead use the pure_dart and pure_dart_multi tests to debug any issues. Please refer to <code>frb_codegen/src/main.rs</code>'s tests for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cancellable-tasks"><a class="header" href="#cancellable-tasks">Cancellable tasks</a></h1>
<p>When the Rust code is computationally heavy, you may want to cancel it at the middle when, for example, the user does not need it anymore. Then the precious computation power can be saved.</p>
<p>Installation: Currently, the feature is complete, and I have used it in my own app for a long time. (I have not merge this PR to the main repo just because I need to figure out how to put those code as if in <code>api.rs</code>.) Thus, visit <a href="https://github.com/fzyzcjy/flutter_rust_bridge/pull/333">#333</a> and copy the code directly to your project, and use it as normal.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-pools"><a class="header" href="#object-pools">Object pools</a></h1>
<p>When there are some big objects in the Rust side, you may not want to copy them between Rust and Dart over and over again. That is when object pools become useful: You only pass around a "object handle" (indeed just a few integers) between Rust and Dart, and the Rust side will convert that handle from and to the real object.</p>
<p>Installation: Same as <a href="feature/cancelable_task.html">cancelable tasks</a>, please see doc there.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wasm"><a class="header" href="#wasm">WASM</a></h1>
<p><code>flutter_rust_bridge_codegen</code> can also generate code to run in browsers using
<code>wasm_bindgen</code>. To generate a WASM-specific file, pass this option to your invocation:</p>
<pre><code class="language-shell">flutter_rust_bridge_codegen .. --wasm
</code></pre>
<p>By default this will create several new files:</p>
<pre><code>├── lib
│   ├── ...
│   ├── bridge_generated.io.dart
│   └── bridge_generated.web.dart
└── native/src
    ├── bridge_generated.io.rs
    └── bridge_generated.web.rs
</code></pre>
<p>The <code>.io</code> and <code>.web</code> modules implement platform-specific helpers. This
split is mandatory for Dart due to its module system, however if you prefer to keep the Rust bridge in a single file pass the <code>--inline-rust</code>
flag as well.</p>
<p>Check out <a href="feature/../integrate/web.html">Integrating with Web</a> for instructions
on how to consume the web bridge.</p>
<p>have a look at <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/860">issue 860</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h1>
<h2 id="separate-generated-definitions-from-implementations"><a class="header" href="#separate-generated-definitions-from-implementations">Separate generated definitions from implementations</a></h2>
<p>The generated <code>bridge_generated.dart</code> by default contains definitions of the APIs as well as the implementations. With the flag <code>--dart-decl-output</code>, the two can be separated, and the definitions will not contain anything like <code>dart:ffi</code>.</p>
<p>A command example as follow:</p>
<pre><code class="language-shell">flutter_rust_bridge_codegen .. --dart-decl-output &lt;DECL&gt;
</code></pre>
<p>where <code>DECL</code> is the path to the common class/function declarations file.
For example, if you emit your Dart bridge to <code>lib/bridge_generated.dart</code>,
you can put the declarations file at <code>lib/bridge_definitions.dart</code></p>
<p>By default this will create new file:</p>
<pre><code>├── lib
│   ├── bridge_definitions.dart
</code></pre>
<p>More information: <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/298">#298</a>.</p>
<h2 id="injecting-wasm-initialization-code"><a class="header" href="#injecting-wasm-initialization-code">Injecting WASM initialization code</a></h2>
<p>By default, this library injects its own initialization code to facilitate panic information recovery
using <a href="https://lib.rs/crates/console_error_panic_hook"><code>console_error_panic_hook</code></a>.
If you would like to run some initialization code for WASM, e.g. to set up logging libraries,
specify <code>default-features = false</code> in Cargo.toml:</p>
<pre><code class="language-toml">flutter_rust_bridge = { version = "..", default-features = false, features = [..] }
</code></pre>
<p>The <code>wasm-start</code> feature governs this behavior and is enabled by default.</p>
<h2 id="logging-for-developers"><a class="header" href="#logging-for-developers">Logging for developers</a></h2>
<p>For developers who want to contribute to this project, here is the feature logging that needs to mention.</p>
<p>When the code in <code>frb_codegen</code> is modified, usually developers want to build and run it locally for testing. Now with the <code>init_logger</code> in <code>logs.rs</code> from <code>frb_codegen</code>, it is easy to do so.  Take <code>frb_example/pure_dart</code> as an example, in <code>./rust/build.rs</code>, with:</p>
<pre><pre class="playground"><code class="language-rust">use lib_flutter_rust_bridge_codegen::init_logger;
fn main() {
    init_logger("./logs/").unwrap();
...
}</code></pre></pre>
<p>Then, all information from standard panic, <code>log::info!()</code>,<code> log::debug()!</code>...  of <code>frb_codegen</code> would be recorded to  <code>./logs/</code> with a file name of date, like <code>2023-02-01.log</code> in <code>frb_example/pure_dart/rust</code> as long as the example is built through <code>build.rs</code>. Note, the data from the same day would be appended to the same file.</p>
<p>Moreover, if rust-analyzer is used, then whenever <code>frb_codegen</code> is modified, all examples with <code>build.rs</code> would be automatically triggered to rebuild. Then the log would be updated automatically to disk, which makes the whole developing routine easier.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>Since I have seen some questions asking how logging can be implemented with a Flutter + Rust application, here are some examples.</p>
<h2 id="logger-in-production"><a class="header" href="#logger-in-production">Logger in production</a></h2>
<p>In my own app in production, I use the following strategy for Rust logging: Use normal Rust logging methods, such as <code>info!</code> and <code>debug!</code> macros. The logs are consumed in two places: They are printed via platform-specific methods (like android Logcat and iOS NSLog), and also use a Stream to send them to the Dart side such that my Dart code and further process are using the same pipeline as normal Dart logs (e.g. save to a file, send to server, etc).</p>
<p>The <em>full</em> code related to logging in my app can be seen here: <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/486">#486</a>.</p>
<h2 id="simple-logger"><a class="header" href="#simple-logger">Simple logger</a></h2>
<p>Let us implement a simple logging system (adapted from the logging system I use with <code>flutter_rust_bridge</code> in my app in production), where Rust code can send logs to Dart code.</p>
<p>The Rust <code>api.rs</code>:</p>
<pre><code class="language-rust noplayground">pub struct LogEntry {
    pub time_millis: i64,
    pub level: i32,
    pub tag: String,
    pub msg: String,
}

// Simplified just for demonstration.
// To compile, you need a OnceCell, or Mutex, or RwLock
// Also see https://github.com/fzyzcjy/flutter_rust_bridge/issues/398
lazy_static! { static ref log_stream_sink: StreamSink&lt;LogEntry&gt;; }

pub fn create_log_stream(s: StreamSink&lt;LogEntry&gt;) {
    stream_sink = s;
}</code></pre>
<p>Now Rust will probably complain at you because <code>IntoDart</code> is not implemented for <code>LogEntry</code>. This is expected, because <code>flutter_rust_bridge</code> will generate this trait implementation for you.
To fix this error you should just rerun <code>flutter_rust_bridge_codegen</code>.</p>
<p>Generated Dart code:</p>
<pre><code class="language-Dart">Stream&lt;LogEntry&gt; createLogStream();
</code></pre>
<p>Now let us use it in Dart:</p>
<pre><code class="language-dart">Future&lt;void&gt; setup() async {
    createLogStream().listen((event) {
      print('log from rust: ${event.level} ${event.tag} ${event.msg} ${event.timeMillis}');
    });
}
</code></pre>
<p>And now we can happily log anything in Rust:</p>
<pre><code class="language-rust noplayground">log_stream_sink.add(LogEntry { msg: "hello I am a log from Rust", ... })</code></pre>
<p>Of course, you can implement a logger following the Rust's <code>log</code> crate wrapping this raw stream sink, then you can use standard Rust logging mechanisms like <code>info!</code>. I did exactly that in my project.</p>
<h3 id="example-simple-timer"><a class="header" href="#example-simple-timer">Example: Simple timer</a></h3>
<p>Credits: <a href="https://gist.github.com/Desdaemon/be5da0a1c6b4724f20093ef434959744">this</a> and <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/347">#347</a>.</p>
<pre><code class="language-rust noplayground">use anyhow::Result;
use std::{thread::sleep, time::Duration};

use flutter_rust_bridge::StreamSink;

const ONE_SECOND: Duration = Duration::from_secs(1);

// can't omit the return type yet, this is a bug
pub fn tick(sink: StreamSink&lt;i32&gt;) -&gt; Result&lt;()&gt; {
    let mut ticks = 0;
    loop {
        sink.add(ticks);
        sleep(ONE_SECOND);
        if ticks == i32::MAX {
            break;
        }
        ticks += 1;
    }
    Ok(())
}</code></pre>
<p>And use it in Dart:</p>
<pre><code class="language-dart">import 'package:flutter/material.dart';
import 'ffi.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: const MyHomePage(title: 'Flutter Demo Home Page'),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({Key? key, required this.title}) : super(key: key);
  final String title;

  @override
  State&lt;MyHomePage&gt; createState() =&gt; _MyHomePageState();
}

class _MyHomePageState extends State&lt;MyHomePage&gt; {
  late Stream&lt;int&gt; ticks;

  @override
  void initState() {
    super.initState();
    ticks = api.tick();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.title),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: &lt;Widget&gt;[
            const Text("Time since starting Rust stream"),
            StreamBuilder&lt;int&gt;(
              stream: ticks,
              builder: (context, snap) {
                final style = Theme.of(context).textTheme.headlineMedium;
                final error = snap.error;
                if (error != null)
                  return Tooltip(
                      message: error.toString(),
                      child: Text('Error', style: style));

                final data = snap.data;
                if (data != null) return Text('$data second(s)', style: style);

                return const CircularProgressIndicator();
              },
            )
          ],
        ),
      ),
    );
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-traces"><a class="header" href="#stack-traces">Stack Traces</a></h1>
<p>To pass Rust stack traces to flutter, you need to set <code>RUST_BACKTRACE</code> in the running application. For that simply add <code>env::set_var("RUST_BACKTRACE", "1");</code> before initialising the bridge.</p>
<p>Note: The <code>--dart-define</code> will not work, you <strong>must</strong> use <code>env::set_var</code>, because the former does not set the "environment variable" in the common sense, but instead a special thing only visible to Dart.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="worker-pool"><a class="header" href="#worker-pool">Worker pool</a></h1>
<p>Note: You can customize <a href="feature/handler.html">handlers</a> and even completely get rid of the worker pool. The following doc only works for those who wants to use the default handler and thus pool.</p>
<p>When you call a Rust function with generated code from Dart side, it is executed inside a separate worker pool handled by flutter_rust_bridge. Thanks to the pool, type of the return values in Dart is async <code>Future</code> which means heavy calculation in Rust does not block the user interface from responding.</p>
<p>In non-WASM configuration, flutter_rust_bridge internally creates a pool of 4 threads. In WASM configuration, a pool with 4 web workers is used.</p>
<p>However, if you think that this number of 4 is inappropriate for your project, you can choose a different option. By specifying features in <code>Cargo.toml</code>, you can optimize the number of threads or workers in the pool. Just include <code>features</code> key when adding flutter_rust_bridge as a dependency.</p>
<pre><code class="language-toml">// Cargo.toml

[dependencies]
flutter_rust_bridge = { workspace = true, features = ["worker-max"] }
</code></pre>
<p>Currently available options related to worker pool are:</p>
<ul>
<li><code>worker-single</code>: Uses 1 worker in the pool.</li>
<li><code>worker-max</code>: Uses all available logical cores.</li>
</ul>
<p>Note that both non-WASM and WASM configurations provide true multithreaded parallelism. They both utilize actual threads in logical cores. However, you do need to be aware of the limitations of WASM, such as inability to use shared memory, etc.</p>
<p>The options are experimental, and may change later. However, it should be trivial to migrate even if it changes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expanding-macros"><a class="header" href="#expanding-macros">Expanding macros</a></h1>
<p>This library automatically handles macros inside your code. For example, support you calls a macro that will generate a struct, then even if that struct is not in the code directly, this library can understand it.</p>
<p>The implementation is as follows: To produce code for types or functions that are generated through macros, it is necessary to first expand the code before it is parsed. This is done by invoking <a href="https://crates.io/crates/cargo-expand">cargo-expand</a>, a tool that expands all macros, resulting in code that can then be parsed.</p>
<p>Caution: This expansion process <strong>cannot</strong> be utilized when the code-generator is invoked within a <code>build.rs</code> script.
The issue here is that <code>cargo-expand</code> triggers a project build, and invoking it within <code>build.rs</code> would lead to a deadlock, as <code>cargo-expand</code> would wait for the calling cargo build to complete.
In such cases, code is read from files without macro expansion.
If your API definition does not rely on macros for code generation, this works fine.
Otherwise, you have to call the <code>flutter_rust_bridge_codegen</code> binary seperately.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-new-projects-from-a-template"><a class="header" href="#create-new-projects-from-a-template">Create new projects from a template</a></h1>
<p>In this chapter, we are going to use create your own project from a code template. It seems a bit long, but it is just because we have tried to describe <em>every detail</em> that you may encounter.</p>
<p><strong>Remark:</strong> Most complexity does <em>not</em> come from this library, <code>flutter_rust_bridge</code> - it is as same complex as using raw Dart/Flutter FFI with Rust. In other words, it is the Dart/Flutter + Rust toolchain that takes time to set up.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-new-project"><a class="header" href="#creating-a-new-project">Creating a new project</a></h1>
<p>Start by creating a repository using the template from <a href="https://github.com/Desdaemon/flutter_rust_bridge_template">flutter_rust_bridge_template</a>
and cloning it. This template is set up to be able to <code>flutter run</code> for most platforms
that Flutter supports.</p>
<p>(Remark: The template is created by <a href="https://github.com/Desdaemon">@Desdaemon</a> who
contributed many features into flutter_rust_bridge, instead of the creator of
flutter_rust_bridge, <a href="https://github.com/fzyzcjy">@fzyzcjy</a>. Thus, it is not a typo to
see <code>Desdaemon</code> in the URL instead of <code>fzyzcjy</code> for that template repo.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android-setup-1"><a class="header" href="#android-setup-1">Android setup</a></h1>
<p>Before trying this, ensure you can <a href="template/../tutorial/setup_android.html">run the example project</a></p>
<h2 id="rust-targets"><a class="header" href="#rust-targets">Rust targets</a></h2>
<p>If you have not already done so, cross-compiling to Android requires some additional
targets which can easily be added:</p>
<pre><code class="language-shell">rustup target add \
    aarch64-linux-android \
    armv7-linux-androideabi \
    x86_64-linux-android \
    i686-linux-android
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios-setup"><a class="header" href="#ios-setup">iOS setup</a></h1>
<p>iOS requires some additional Rust targets for cross-compilation:</p>
<pre><code class="language-bash"># 64 bit targets (real device &amp; simulator):
rustup target add aarch64-apple-ios x86_64-apple-ios
# New simulator target for Xcode 12 and later
rustup target add aarch64-apple-ios-sim
# 32 bit targets (you probably don't need these):
rustup target add armv7-apple-ios i386-apple-ios
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-setup"><a class="header" href="#web-setup">Web setup</a></h1>
<p>Building on web requires nightly Rust, the <code>wasm32-unknown-unknown</code> target
and <a href="https://rustwasm.github.io/wasm-pack/">wasm-pack</a>, which can be installed using these commands:</p>
<pre><code class="language-bash">rustup toolchain install nightly
rustup +nightly component add rust-src
rustup +nightly target add wasm32-unknown-unknown
# either of these
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
cargo install wasm-pack
</code></pre>
<p>Optionally (but highly recommended), install <code>flutter_rust_bridge_serve</code>
to expedite the process of building the WASM binary and setting up HTTP headers:</p>
<pre><code class="language-bash"># in your Flutter/Dart package
flutter pub add flutter_rust_bridge
# then run this instead of "flutter web -d chrome"
dart run flutter_rust_bridge:serve
# or install globally
dart pub global activate flutter_rust_bridge
flutter_rust_bridge_serve
</code></pre>
<h2 id="limitations-of-wasm"><a class="header" href="#limitations-of-wasm">Limitations of WASM</a></h2>
<p>Running code on the Web entails several restrictions on the kinds of code that
can be executed. Please refer to <a href="template/../wasm_limitations.html">Limitations of WASM</a>
to see if your code is compatible with WASM.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows-and-linux"><a class="header" href="#windows-and-linux">Windows and Linux</a></h1>
<p>Windows and Linux share the same build system (CMake), making setup for these two
platforms the easiest even from scratch. The template uses <a href="https://github.com/corrosion-rs/corrosion">Corrosion</a> to expedite the process, which has to clone and initialize the builder first. If you are running builds continuously, it might be a good idea to follow <a href="https://github.com/corrosion-rs/corrosion#installation">this guide</a> to learn how to install <a href="https://github.com/corrosion-rs/corrosion">Corrosion</a> permanently onto your system. Once that's done, go ahead and modify <code>rust.cmake</code> in <code>windows</code> and <code>linux</code>:</p>
<pre><code class="language-diff">-# find_package(Corrosion REQUIRED)
+find_package(Corrosion REQUIRED)

-include(FetchContent)
-
-FetchContent_Declare(
-    Corrosion
-    GIT_REPOSITORY https://github.com/AndrewGaspar/corrosion.git
-    GIT_TAG v0.4.4 # Optionally specify a version tag or branch here
-)
-
-FetchContent_MakeAvailable(Corrosion)
</code></pre>
<h2 id="troubleshooting-cmake-on-linux"><a class="header" href="#troubleshooting-cmake-on-linux">Troubleshooting: CMake on Linux</a></h2>
<p>Unless you have certain use-cases that you require from the latest versions of <a href="https://github.com/corrosion-rs/corrosion">Corrosion</a>, it is recommended to
use <strong>v0.4.x</strong> in your build scripts since CMake versions supplied by the system and/or Flutter snap installations
trail behind the master branch. This will relax the CMake requirement to v15, which should be generally available
from most package maintainers and Flutter snaps.</p>
<p>A workaround is to ignore <code>rust.cmake</code> and manually configure CMake to build and bundle the Rust library, as suggested by
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/318#issuecomment-1038751426">this comment</a>
in the case of Flutter on ARM Linux.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-platforms"><a class="header" href="#other-platforms">Other platforms</a></h1>
<p>For all remaining platforms, there are no required setup steps to take, apart from those listed in <a href="https://docs.flutter.dev/desktop">Desktop support for Flutter</a>. If you need to check your progress, run <code>flutter doctor -v</code> and it will display the status of your toolchain and any actionable steps. The rest of this page
documents additional hints for each of the platforms that might be useful for newcomers to
Flutter and/or Rust.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-tour"><a class="header" href="#template-tour">Template tour</a></h1>
<p><img src="template/success.png" alt="success-screen" /></p>
<p>Congratulations! 🎉 You should have a working Flutter app equipped with
a Rust runtime component. This section is meant to be a gentle introduction to the details of Rust integration with the existing Flutter toolchain. Feel free to skip forward to <a href="template/generate.html">Generating code</a> to learn how to write new code, or visit
<a href="template/../integrate.html">Integrating with existing projects</a> to add Rust to your preexisting Flutter project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nativesrcapirs"><a class="header" href="#nativesrcapirs"><code>native/src/api.rs</code></a></h1>
<p>This is the default entry point for your library. Only functions defined here will be eligible for codegen.
Functions may use types not defined in this file as parameter or return types, but those types must have
been imported through <code>pub use</code> so that they are visible from <code>native/src/bridge_generated.rs</code>.</p>
<p>Only types defined within the current crate are eligible for codegen.
Furthermore, structs and enums may only comprise of types that are themselves eligible.</p>
<p>To review the subset of currently eligible functions and types, see <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/pure_dart/rust/src/api.rs">the example file here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="androidappbuildgradle"><a class="header" href="#androidappbuildgradle"><code>android/app/build.gradle</code></a></h1>
<p>This file is part of the default Flutter build process for Android apps.
The template injects additional hooks to run <a href="https://lib.rs/crates/cargo-ndk"><code>cargo-ndk</code></a>
upon invoking <code>flutter run</code>. This method is explained more in detail in
<a href="template/../integrate/android_tasks.html">Hooking onto tasks</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nativenativexcodeproj"><a class="header" href="#nativenativexcodeproj"><code>native/native.xcodeproj</code></a></h1>
<p>This is the Xcode project folder for the Rust native library generated by <a href="https://lib.rs/crates/cargo-xcode"><code>cargo-xcode</code></a>.
The iOS and MacOS root projects import this folder as a <em>subproject</em> and depends on it during
build-time.</p>
<p>It is important that the suitable <code>crate-type</code>s are configured for your target devices.
Make sure these lines exist in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[lib]
crate-type = ["lib", "cdylib", "staticlib"]
</code></pre>
<p>where</p>
<ul>
<li><code>lib</code> is required for non-library targets, such as tests and benchmarks</li>
<li><code>staticlib</code> is required for iOS</li>
<li><code>cdylib</code> for all other platforms</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="justfile"><a class="header" href="#justfile"><code>justfile</code></a></h1>
<p>This file defines the recipes for the <a href="https://github.com/casey/just">just</a> command runner, in a similar vein to <code>make</code> and Makefile. <a href="https://github.com/casey/just">just</a> is built using Rust and improves upon the traditional Makefile syntax with better support for
conditionals, arguments, cross-platform compatibility and more.</p>
<p>One non-trivial feature of <a href="https://github.com/casey/just">just</a> utilized by this template is the
conditional LLVM flag for MacOS. On certain setups, a <code>brew install llvm</code> does not make the LLVM libraries visible to other executables, which causes problems for <code>ffigen</code>, a C-to-Dart codegen that <code>flutter_rust_bridge_codegen</code> uses under the hood.</p>
<p>Running <code>just</code> by default runs the <code>gen</code> and <code>lint</code> tasks.</p>
<h2 id="just-gen"><a class="header" href="#just-gen"><code>just gen</code></a></h2>
<p>Generates the Rust bindings and puts them into the correct folders.
The <a href="template/generate.html">Generating new code</a> section goes into detail how to modify
this task to perform side jobs as well.</p>
<h2 id="just-lint"><a class="header" href="#just-lint"><code>just lint</code></a></h2>
<p>Runs the default linters for Dart and Rust.</p>
<h2 id="just-clean"><a class="header" href="#just-clean"><code>just clean</code></a></h2>
<p>Runs the default clean commands for Flutter and Rust.
Useful when you want to debug build-related issues.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustcmake"><a class="header" href="#rustcmake"><code>rust.cmake</code></a></h1>
<p>In <code>windows</code> and <code>linux</code> are two identical files named <code>rust.cmake</code>.
These files are included in the existing <code>CMakeLists.txt</code> that Flutter uses
to compile its applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-code"><a class="header" href="#generating-code">Generating code</a></h1>
<p>This section assumes you followed the instructions in <a href="template/template.html">Creating a new project</a>, and has successfully <code>flutter run</code> on your target device.</p>
<p>Up until now, all the code necessary for executing the program has been supplied for you, so there was no need to install anything. We will now look at how to create new Rust code, generate the necessary glue code and use them in Dart.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-codegen"><a class="header" href="#installing-codegen">Installing codegen</a></h1>
<p>More information in the <a href="template/../integrate/deps.html">Installing dependencies</a> section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-new-code"><a class="header" href="#adding-new-code">Adding new code</a></h1>
<p>Let's say we need to change <code>Platform</code> such that we don't really care about whether it
is running on Intel or Apple Silicon, but we would like to keep this information so
downlevel code can act on it. We would like to merge <code>MacApple</code> and <code>MacIntel</code> into a
single <code>MacOs(String)</code> that contains the current CPU architecture. Go ahead and update
<code>native/src/api.rs</code>:</p>
<pre><code class="language-diff"> pub enum Platform {
     ..
-    MacIntel,
-    MacApple,
+    MacOs(String),
     ..
 }
</code></pre>
<p>Now run <code>just</code> and see that your binding code now has changed.</p>
<h2 id="troubleshooting-please-supply-one-or-more-pathtollvm"><a class="header" href="#troubleshooting-please-supply-one-or-more-pathtollvm">Troubleshooting: "Please supply one or more path/to/llvm..."</a></h2>
<p>A common issue with <code>ffigen</code> is that its detection of the LLVM installation is not reliable
across platforms. Especially for MacOS and the split between x86-64 and arm64 binaries,
you might have to modify <code>justfile</code> to explicitly point to its location:</p>
<pre><code>llvm_path := if os() == "macos" {
    "--llvm-path /opt/homebrew/opt/llvm"
} else {
    ""
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-build_runner"><a class="header" href="#using-build_runner">Using <code>build_runner</code></a></h1>
<p>Inspect your <code>lib/bridge_generated.dart</code> and you will see that the definition of <code>Platform</code> has changed:</p>
<pre><code class="language-dart">@freezed
sealed class Platform with _$Platform {
    const factory Platform.unknown() = Platform_Unknown;
    const factory Platform.android() = Platform_Android;
    const factory Platforn.ios() = Platform_Ios;
    const factory Platform.windows() = Platform_Windows;
    const factory Platform.unix() = Platform_Unix;
    const factory Platform.macOs(
        String field0,
    ) = Platform_MacOs;
    const factory Platform.wasm() = Platform_Wasm;
}
</code></pre>
<p>It is no longer a plain enum, but a full-blown enum class with variants! As it is right now, this code
cannot compile yet since it is missing some components, namely the <a href="https://pub.dev/packages/freezed"><code>freezed</code></a> library. <a href="https://pub.dev/packages/freezed"><code>freezed</code></a> is a
codegen library similar to those we've encountered thus far, but generates more Dart code instead.
All such libraries perform their code generation upon invoking <code>build_runner</code>, i.e. when <code>flutter pub run build_runner build</code> is executed.</p>
<p>Regardless, to make this code compile again, we need to make a few changes:</p>
<ul>
<li>Run the following commands to add the latest version of <a href="https://pub.dev/packages/freezed"><code>freezed</code></a>:</li>
</ul>
<pre><code class="language-shell">flutter pub add -d build_runner
flutter pub add -d freezed
flutter pub add freezed_annotation
</code></pre>
<ul>
<li>Update <code>justfile</code> to run <code>build_runner</code> after Rust codegen:</li>
</ul>
<pre><code class="language-diff"> gen:
     ..
     # Uncomment this line to invoke build_runner as well
-    # flutter pub run build_runner build
+    flutter pub run build_runner build
</code></pre>
<p>Now calling <code>just</code> will generate both the Rust bindings <em>and</em> the Dart library code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping up</a></h1>
<p>With our new definition of <code>Platform</code> in place, we can rewrite the previous code to make use
of it! Here is an example of what you can do with freezed enums.</p>
<p>In <code>lib/main.dart</code>:</p>
<pre><code class="language-diff">- final text = const {
-   Platform.Android: 'Android',
-   Platform.Ios: 'iOS',
-   Platform.MacApple: 'MacOS with Apple Silicon',
-   Platform.MacIntel: 'MacOS',
-   Platform.Windows: 'Windows',
-   Platform.Unix: 'Unix',
-   Platform.Wasm: 'the Web',
- }[platform] ??
- 'Unknown OS';
+ final text = platform.when(
+   android: () =&gt; 'Android',
+   ios: () =&gt; 'iOS',
+   macOs: (arch) =&gt; 'MacOS on $arch',
+   windows: () =&gt; 'Windows',
+   unix: () =&gt; 'Unix',
+   wasm: () =&gt; 'the Web',
+ );
</code></pre>
<p>In <code>native/src/api.rs</code>:</p>
<pre><code class="language-diff">     } else if cfg!(target_os = "ios") {
         Platform::Ios
     } else if cfg!(all(target_os = "macos", target_arch = "aarch64")) {
-        Platform::MacApple
+        Platform::MacOs("Apple Silicon".into())
     } else if cfg!(target_os = "macos") {
-        Platform::MacIntel
+        Platform::MacOs("Intel".into())
     } else if cfg!(target_family = "wasm") {
         Platform::Wasm
     } else if cfg!(unix) {
</code></pre>
<p>When you <code>flutter run</code>, you should get something like this:
<img src="template/macos_intel.png" alt="macos-intel" /></p>
<h2 id="tip-using-switch-expressions"><a class="header" href="#tip-using-switch-expressions">Tip: Using switch expressions</a></h2>
<p>Introduced in Dart 3, switch expressions provide the equivalent of Rust's <code>match</code> expressions, complete with exhaustive checks.
Instead of using <code>when()</code> in the above example, you could also use this syntax:</p>
<pre><code class="language-dart">final text = switch (platform) {
  Platform_Android() =&gt; 'Android',
  Platform_Ios() =&gt; 'iOS',
  Platform_MacOs(:final arch) =&gt; 'MacOS on $arch',
  Platform_Windows() =&gt; 'Windows',
  Platform_Unix() =&gt; 'Unix',
  Platform_Wasm() =&gt; 'the Web',
  // we have covered all cases, so this compiles.
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-existing-projects"><a class="header" href="#integrating-with-existing-projects">Integrating with existing projects</a></h1>
<p>This guide is an intermediate-level introduction to integrating Rust with
an existing Flutter project. If you are new to Rust or configuring
build processes in general, we suggest looking at <a href="template/tour.html">the template tour</a>
to learn about the moving parts behind a <code>flutter run</code>.</p>
<p>Before following this guide, upgrade your Flutter SDK, and if possible
refresh your native build folders (<code>android</code>, <code>ios</code>, etc.) to make the process
as straightforward as possible.</p>
<p><strong>Remark:</strong> Most complexity does <em>not</em> come from this library, <code>flutter_rust_bridge</code> - it is as same complex as using raw Dart/Flutter FFI with Rust. In other words, it is the Dart/Flutter + Rust toolchain that takes time to set up.</p>
<h2 id="using-the-flutter_rust_bridge-brick"><a class="header" href="#using-the-flutter_rust_bridge-brick">Using the <code>flutter_rust_bridge</code> brick</a></h2>
<p>The following sections cover how to set up Rust support from scratch for completeness' sake,
however for your convenience you can also use the <a href="https://brickhub.dev/bricks/flutter_rust_bridge/"><code>fluttter_rust_bridge</code> brick</a>
to scaffold most of<sup class="footnote-reference"><a href="#1">1</a></sup> the code written here.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Some setup steps are still required even with the brick, which we will go into more detail in the later sections.
The brick is a work-in-progress.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-new-crate"><a class="header" href="#creating-a-new-crate">Creating a new crate</a></h1>
<p>First, if you haven't done so already, create a new crate within your project directory
using <code>cargo new --lib</code>. It is recommended that the crate root is a sibling of the other native build
folders for ease of config, e.g.:</p>
<pre><code>├── android
├── ios
├── lib
├── linux
├── macos
├── $crate
│   ├── Cargo.toml
│   └── src
├── test
├── web
└── windows
</code></pre>
<p>Throughout this section we will refer to your crate name as $crate. Unless otherwise noted, the crate folder
and the crate name will be used interchangeably.</p>
<p>Next, add these two lines to your <code>Cargo.toml</code>:</p>
<pre><code class="language-diff">+[lib]
+crate-type = ["staticlib", "cdylib"]
</code></pre>
<p>This configures your crate to be output as a static library for MacOS and iOS,
and a dynamic library on other platforms. Configure this to your needs.
If you would like to write tests or benchmarks, append <code>"rlib"</code> to the list
as well.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-dependencies"><a class="header" href="#installing-dependencies">Installing dependencies</a></h1>
<p>Next, we need to install a few build-time and runtime dependencies.</p>
<h2 id="build-time-dependencies"><a class="header" href="#build-time-dependencies">Build-time dependencies</a></h2>
<p>These dependencies are required only in build-time:</p>
<ul>
<li><a href="https://lib.rs/crates/flutter_rust_bridge_codegen"><code>flutter_rust_bridge_codegen</code></a>, the core codegen for Rust-Dart glue code</li>
<li><a href="https://pub.dev/packages/ffigen"><code>ffigen</code></a>, to generate Dart code from C headers</li>
<li>A working installation of LLVM, see <a href="https://pub.dev/packages/ffigen#installing-llvm">Installing LLVM</a>, used by <code>ffigen</code></li>
<li>(Optional) <a href="https://lib.rs/crates/cargo-xcode"><code>cargo-xcode</code></a>, if you want to generate Xcode projects for iOS and MacOS</li>
</ul>
<p>An easy way to install most of these dependencies is to run:</p>
<ul>
<li>
<p>dart project</p>
<pre><code class="language-bash">cargo install flutter_rust_bridge_codegen
dart pub add --dev ffigen &amp;&amp; dart pub add ffi
# if building for iOS or MacOS
cargo install cargo-xcode
</code></pre>
</li>
<li>
<p>flutter project</p>
<pre><code class="language-bash">cargo install flutter_rust_bridge_codegen
flutter pub add --dev ffigen &amp;&amp; flutter pub add ffi
# if building for iOS or MacOS
cargo install cargo-xcode
</code></pre>
</li>
</ul>
<p>Alternatively, each of these dependencies may provide prebuilt binaries. Check with
your package manager and review them individually.</p>
<h2 id="dart-dependencies"><a class="header" href="#dart-dependencies">Dart dependencies</a></h2>
<p>On the Dart side, <code>flutter_rust_bridge</code> is the required runtime component of
<code>flutter_rust_bridge_codegen</code>. If you plan to use enum structs in Rust, the
following dependencies are also needed:</p>
<ul>
<li><code>build_runner</code> (dev)</li>
<li><code>freezed</code> (dev)</li>
<li><code>freezed_annotation</code></li>
</ul>
<p>Their usage is explained in <a href="integrate/../generate/build_runner.html">Using <code>build_runner</code></a>.</p>
<pre><code class="language-bash">flutter pub add flutter_rust_bridge
# if using Dart codegen
flutter pub add -d build_runner
flutter pub add -d freezed
flutter pub add freezed_annotation
</code></pre>
<h2 id="rust-dependencies"><a class="header" href="#rust-dependencies">Rust dependencies</a></h2>
<p>Similar to Dart, Rust requires the <code>flutter_rust_bridge</code> runtime component for support.</p>
<p>Add these lines to <code>Cargo.toml</code>:</p>
<pre><code class="language-diff">+[dependencies]
+flutter_rust_bridge = "1"
</code></pre>
<h2 id="system-dependencies"><a class="header" href="#system-dependencies">System dependencies</a></h2>
<h3 id="non-debian-linux"><a class="header" href="#non-debian-linux">Non-Debian Linux</a></h3>
<p>For non-debian based Linux distributions, there are a few prerequisites:</p>
<p>Firstly, ensure that packages are up to date (or install by demand).</p>
<ul>
<li>clang</li>
<li>llvm-libs</li>
<li>glibc</li>
</ul>
<p>Restarting system may be required.</p>
<p>Secondly, set the environment variable in your shell profile (<code>.bashrc</code>, <code>.zshrc</code>, etc):</p>
<pre><code class="language-bash">export CPATH="$(clang -v 2&gt;&amp;1 | grep "Selected GCC installation" | rev | cut -d' ' -f1 | rev)/include"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-android"><a class="header" href="#integrating-with-android">Integrating with Android</a></h1>
<p>The setup process is identical to <a href="integrate/../template/setup_android.html">Android setup</a>,
so go ahead and follow the steps described there. Once you're done, we will discuss
how to modify the existing toolchain to accommodate Rust.</p>
<p>There is more than one way to set up Cargo to run alongside Gradle, so this guide
will cover the two main ones: hooking onto tasks, and integrating with CMake.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hooking-onto-tasks"><a class="header" href="#hooking-onto-tasks">Hooking onto tasks</a></h1>
<p>This is the same method used by the app template and also the easier one.
Go ahead and install <code>cargo-ndk</code> if you have not already done so:</p>
<pre><code>cargo install cargo-ndk
</code></pre>
<p>Next, add these lines<sup class="footnote-reference"><a href="#1">1</a></sup> near the bottom of <code>android/app/build.gradle</code>:</p>
<pre><code class="language-gradle">[
    new Tuple2('Debug', ''),
    new Tuple2('Profile', '--release'),
    new Tuple2('Release', '--release')
].each {
    def taskPostfix = it.first
    def profileMode = it.second
    tasks.whenTaskAdded { task -&gt;
        if (task.name == "javaPreCompile$taskPostfix") {
            task.dependsOn "cargoBuild$taskPostfix"
        }
    }
    tasks.register("cargoBuild$taskPostfix", Exec) {
        // Until https://github.com/bbqsrc/cargo-ndk/pull/13 is merged,
        // this workaround is necessary.

        def ndk_command = """cargo ndk \
            -t armeabi-v7a -t arm64-v8a -t x86_64 -t x86 \
            -o ../android/app/src/main/jniLibs build $profileMode"""

        workingDir "../../$crate"
        environment "ANDROID_NDK_HOME", "$ANDROID_NDK"
        if (org.gradle.nativeplatform.platform.internal.DefaultNativePlatform.currentOperatingSystem.isWindows()) {
            commandLine 'cmd', '/C', ndk_command
        } else {
            commandLine 'sh', '-c', ndk_command
        }
    }
}
</code></pre>
<p>Note the ANDROID_NDK variable, this is a Gradle property that points to
your installation of the Android NDK. If you don't rely on portability,
you can hardcode this value, but note that it can be supplied by one
of the many <code>gradle.properties</code> scattered throughout your filesystem.
The most reliable way is to create a file at <code>~/.gradle/gradle.properties</code>
and fill it with this:</p>
<pre><code>ANDROID_NDK=(path to NDK)
</code></pre>
<p>Note the ABIs <code>x86_64</code> and <code>x86</code> in <code>ndk_command</code> are usually used for Android simulators. Feel free to remove them as needed.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This excerpt might be outdated, please check out
the <a href="https://github.com/Desdaemon/flutter_rust_bridge_template/blob/main/android/app/build.gradle">source file</a> at the <a href="https://github.com/Desdaemon/flutter_rust_bridge_template">template repository</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmake-with-gradle"><a class="header" href="#cmake-with-gradle">CMake with Gradle</a></h1>
<p>If you have taken a look at either the <code>windows</code> or <code>linux</code> folder,
you will see a file named <code>CMakeLists.txt</code>. This is the definition file
for the CMake toolchain that Flutter uses to build Windows and Linux apps.
You can also use this strategy on Gradle, but this setup is beyond the scope
of this guide and reserved for advanced tinkers.</p>
<p>Refer to the <a href="https://developer.android.com/studio/projects/add-native-code">Add C and C++ code to your project</a>
page on the official Android docs, modify around C-specific parts and use a
tool like <a href="https://github.com/corrosion-rs/corrosion"><code>Corrosion</code></a> to integrate
with Cargo. The advantage of this setup is that you can reuse your C tools
<em>and</em> benefit from various techniques such as caching builds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-iosmacos"><a class="header" href="#integrating-with-iosmacos">Integrating with iOS/MacOS</a></h1>
<p><em>Credit to <a href="https://github.com/brotskydotcom/rust-on-ios">brotskydotcom/rust-on-ios</a>
for the inspiration of this method.</em></p>
<p>Setting up <code>flutter run</code> for iOS and MacOS is slightly more complicated than other platforms,
due to its reliance on the Xcode user interface. This guide assumes you are running
a relatively recent version of Xcode, which at the time of writing is Xcode 13.
Other versions might have minor variances but the overall process should be the same.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-rust-project"><a class="header" href="#creating-the-rust-project">Creating the Rust project</a></h1>
<p>First, follow the instructions on the <a href="https://gitlab.com/kornelski/cargo-xcode#usage">Usage</a>
section of <code>cargo-xcode</code>. The instructions that follow are quoted from there, but keep in mind
that it might have become outdated.</p>
<hr />
<p>Ensure that these lines are present in your <code>$crate/Cargo.toml</code>:</p>
<pre><code class="language-toml">[lib]
crate-type = ["lib", "staticlib", "cdylib"]
</code></pre>
<p>where</p>
<ul>
<li><code>lib</code> is required for non-library targets, such as tests and benchmarks</li>
<li><code>staticlib</code> is required for iOS</li>
<li><code>cdylib</code> for all other platforms</li>
</ul>
<p>Configure this to suit your needs. Then run this command in <code>$crate</code>:</p>
<pre><code class="language-bash">cargo xcode
</code></pre>
<p>This will generate a <code>$crate/$crate.xcodeproj</code> that can be imported into other Xcode projects.
You only have to do this once per crate.</p>
<p>Now, open up that <code>$crate/$crate.xcodeproj</code> file with Xcode and select the root item at the left pane. The item's name will be identical to your crate's name. In the <strong>Build Settings</strong> tab, search for <code>Dynamic Library Install Name Base</code> and change the value into <code>@executable_path/../Frameworks/</code>. This is <a href="https://lib.rs/crates/cargo-xcode#:~:text=DYLIB_INSTALL_NAME_BASE">required by cargo-xcode</a> to enable macOS executable to properly locate <code>.dylib</code> library files in the package.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linking-the-project"><a class="header" href="#linking-the-project">Linking the project</a></h1>
<p>Open <code>ios/Runner.xcodeproj</code> in Xcode, then add <code>$crate/$crate.xcodeproj</code> as a <em>subproject</em>
of the Runner project. It should look like this:</p>
<p><img src="integrate/ios_proj_tree.png" alt="proj-tree" /></p>
<p>Click on the <code>Runner</code> root project, then go to the <strong>Build Phases</strong> tab.
First, expand the <strong>Dependencies</strong> phase, and add <strong>$crate-staticlib</strong>
for iOS, or <strong>$crate-cdylib</strong> for MacOS.</p>
<p><img src="integrate/ios_dep_phase.png" alt="dep-phase" /></p>
<p>Then, expand the <strong>Link Binary With Libraries</strong> phase, and add <strong>lib$crate_static.a</strong>
for iOS, or <strong>$crate.dylib</strong> for MacOS.</p>
<p><img src="integrate/ios_link_phase.png" alt="link-phase" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-bindings"><a class="header" href="#generating-bindings">Generating bindings</a></h1>
<p>Now that we've got most of the plumbing out of the way, let's compile our Rust
application. If you just created your crate a few moments ago, go ahead and
add a new file at <code>$crate/src/api.rs</code> and replace its contents with this snippet or
whatever suits your fancy:</p>
<pre><code class="language-rust ignore">pub fn greet() -&gt; String {
    "Hello from Rust! 🦀".into()
}</code></pre>
<p>then in <code>$crate/src/lib.rs</code>:</p>
<pre><code class="language-diff">+mod api;
</code></pre>
<h2 id="running-the-codegen"><a class="header" href="#running-the-codegen">Running the codegen</a></h2>
<p>Before we can compile the library, we need to generate the bindings first.
From the root of the app, run these commands:</p>
<pre><code class="language-bash">flutter_rust_bridge_codegen \
    -r $crate/src/api.rs \
    -d lib/bridge_generated.dart \
    -c ios/Runner/bridge_generated.h \
    -e macos/Runner/   # if building for MacOS, extra path is essential
</code></pre>
<blockquote>
<p><strong>Note:</strong> These will be the same commands to use whenever you modify your Rust library code.</p>
</blockquote>
<p>Running this command yields the C header of the functions and types exported
by the Rust library, which we will need to keep the symbols from being stripped.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-dummy-headers"><a class="header" href="#using-dummy-headers">Using dummy headers</a></h1>
<p><code>flutter_rust_bridge_codegen</code> created a C header which lists all the
exported symbols from our library, then uses it so that Xcode won't strip
the symbols.</p>
<p>Add <code>ios/Runner/bridge_generated.h</code> (or <code>macos/Runner/bridge_generated.h</code>)
to the project, either by dragging it onto the project tree or
via the <strong>Add Files to "Runner"...</strong> menu option.</p>
<p>Switch to the <strong>Build Phases</strong> tab and drag the <code>bridge_generated.h</code> file over
to the <strong>Copy Bundle Resources</strong> section, if it isn't already present.</p>
<h2 id="ios"><a class="header" href="#ios">iOS</a></h2>
<p>Next, add this line to <code>ios/Runner/Runner-Bridging-Header.h</code>:</p>
<pre><code class="language-diff">+#import "bridge_generated.h"
</code></pre>
<p>and in <code>ios/Runner/AppDelegate.swift</code>:</p>
<pre><code class="language-diff"> override func application(
     _ application: UIApplication,
     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
 ) -&gt; Bool {
+    let dummy = dummy_method_to_enforce_bundling()
+    print(dummy)
     ..
 }
</code></pre>
<p>It is important that you use the result of <code>dummy_method_to_enforce_bundling()</code> (like in the example above), otherwise the symbols might still get stripped.</p>
<h3 id="stripping-ios-symbols"><a class="header" href="#stripping-ios-symbols">Stripping iOS symbols</a></h3>
<p>If you release your app through App Store, the steps above might not be sufficient. In that case you need to modify how Xcode strips the symbols:</p>
<ol>
<li>In Xcode, go to Target Runner &gt; Build Settings &gt; Strip Style.</li>
<li>Change from <strong>All Symbols</strong> to <strong>Non-Global Symbols</strong>.</li>
</ol>
<p>Ref: https://docs.flutter.dev/development/platform-integration/ios/c-interop#stripping-ios-symbols</p>
<h2 id="macos"><a class="header" href="#macos">MacOS</a></h2>
<p>Flutter on MacOS does not use headers by default, so let's go ahead
and add one ourselves. In the <strong>Build Settings</strong> tab, set the
<strong>Objective-C Bridging Header</strong> to be <strong>Runner/bridge_generated.h</strong>.</p>
<p>Also, head over to the <strong>Build Phases</strong> tab, <strong>Bundle Framework</strong> section and add your <code>$crate.dylib</code> by clicking the plus button. This includes your dynamic library file in your app package.</p>
<p>Finally, use <code>dummy_method_to_enforce_bundling</code> somewhere within
<code>macos/Runner/AppDelegate.swift</code>, as long as Xcode does not consider it dead code.</p>
<h1 id="for-multi-blocks"><a class="header" href="#for-multi-blocks">For multi-blocks</a></h1>
<p>If there are <a href="https://cjycode.com/flutter_rust_bridge/feature/multiple_files.html">multi-blocks</a>:</p>
<ul>
<li>For iOS, just add the 1st generated block-header files in <code>Runner-Bridging-Header.h</code>.</li>
<li>For MacOS, just add the 1st generated block-header files as <strong>Objective-C Bridging Header</strong>.</li>
</ul>
<p>For all cases, the <code>AppDelegate.swift</code> should be the same as that in the single-block case.
<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/1014">related issue</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-windows-and-linux"><a class="header" href="#integrating-with-windows-and-linux">Integrating with Windows and Linux</a></h1>
<p>This guide groups together instructions for Windows and Linux desktop apps,
as they use the same build system.</p>
<p>The idea is the same as other platforms: we hook onto the existing projects
using scripts, and we will also be borrowing from the template. Go ahead
and download <a href="https://raw.githubusercontent.com/Desdaemon/flutter_rust_bridge_template/main/windows/rust.cmake">rust.cmake</a>
into your <code>windows</code> and <code>linux</code> folders. Keep in mind that CMake will refuse
to use files that lie outside of its working directory, so there will be duplications
between the two build folders.</p>
<p>Next, add this line to your <code>CMakeLists.txt</code> files:</p>
<pre><code class="language-diff"> # Generated plugin build rules, which manage building the plugins and adding
 # them to the application.
 include(flutter/generated_plugins.cmake)

+include(./rust.cmake)

 # === Installation ===
 # Support files are copied into place next to the executable, so that it can
</code></pre>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<p>On Linux, you will need to bump the minimum CMake version to 3.12 to make use
of <a href="https://github.com/corrosion-rs/corrosion">Corrosion</a>, which is used by <code>rust.cmake</code>. Change this line in <code>linux/CMakeLists.txt</code>:</p>
<pre><code class="language-diff">-cmake_minimum_required(VERSION 3.10)
+cmake_minimum_required(VERSION 3.12)
</code></pre>
<p>Alternatively, you can install Corrosion permanently on your system.
Refer to the <a href="integrate/../template/setup_desktop.html">Linux troubleshooting notes</a> here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-with-web"><a class="header" href="#integrating-with-web">Integrating with Web</a></h1>
<p>Refer to the <a href="integrate/../template/setup_web.html">Web setup</a> page for required installables.</p>
<p>Once you have installed the required dependencies, you will need to create a wrapper
to consume the bridge files. In the case of <code>DynamicLibrary</code>
you only needed to supply the path to the binary,
but to import a WASM module you need to:</p>
<ul>
<li>Create a script tag to the JS file generated by <code>wasm_bindgen</code> and insert it into the document;</li>
<li>Invoke the <code>wasmModule</code> initializer defined in the
web bridge;</li>
<li>And finally, create the implementation class.</li>
</ul>
<p>Create a Dart file and copy these lines to it:</p>
<pre><code class="language-dart">import 'bridge_generated.web.dart';
export 'bridge_definitions.dart';

import 'dart:html';

// Path to the wasm_bindgen generated files
const root = 'pkg/native';
final api = NativeImpl.wasm(WasmModule.initialize(
    kind: const Modules.noModules(root: root),
));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-dynamic-library"><a class="header" href="#using-the-dynamic-library">Using the dynamic library</a></h1>
<p>If everything went well, running <code>flutter run</code> will now build your Rust library,
the Flutter binary and link the two together. Now the only thing left to do is
to actually use it!</p>
<p>Download <a href="https://raw.githubusercontent.com/Desdaemon/flutter_rust_bridge_template/main/lib/ffi.dart">this file</a>
to <code>lib/ffi.dart</code>, then modify its contents:</p>
<pre><code class="language-diff"> // Re-export the bridge so it is only necessary to import this file.
 export 'bridge_generated.dart';
 import 'dart:io' as io;

-const _base = 'native';
+const _base = '$crate';

 // On MacOS, the dynamic library is not bundled with the binary,
 // but rather directly **linked** against the binary.
 final _dylib = io.Platform.isWindows ? '$_base.dll' : 'lib$_base.so';
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-up-1"><a class="header" href="#wrapping-up-1">Wrapping up</a></h1>
<p>Congratulations! You have successfully added a Rust component to
your Flutter app using <code>flutter_rust_bridge</code> and configured
<code>flutter run</code> (more on web later) to build your Rust library and link it to the app.</p>
<p>As a reminder, you need to run these commands every time your Rust code changes <em>and</em>
before you run <code>flutter run</code>:</p>
<pre><code class="language-bash">flutter_rust_bridge_codegen \
    -r $crate/src/api.rs \
    -d lib/bridge_generated.dart \
    -c ios/Runner/bridge_generated.h \
    -e macos/Runner/   # if building for MacOS, extra path is essential
</code></pre>
<h2 id="renaming-the-rust-bridge-module"><a class="header" href="#renaming-the-rust-bridge-module">Renaming the Rust bridge module</a></h2>
<p>If you would like to use the <code>--rust-output</code> flag of <code>flutter_rust_bridge_codegen</code>,
keep in mind that you will have to update <code>$crate/src/lib.rs</code> to point to the correct
file, for example if you use this command instead:</p>
<pre><code class="language-bash">flutter_rust_bridge_codegen \
    ..
    --rust-output $crate/src/my_bridge.rs
</code></pre>
<p>then you need to modify this in <code>lib.rs</code>:</p>
<pre><code class="language-diff">- mod bridge_generated;
+ mod my_bridge;
</code></pre>
<h2 id="flutter_rust_bridge_serve-less-workflows"><a class="header" href="#flutter_rust_bridge_serve-less-workflows"><code>flutter_rust_bridge_serve</code>-less workflows</a></h2>
<p>If you don't need to run Flutter Web in development
mode and would rather build in release mode once
in a while, <a href="integrate/../build_wasm.html">read here</a> for instructions on how to build your WASM
binary without <code>flutter_rust_bridge_serve</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-dartflutter-library"><a class="header" href="#creating-a-dartflutter-library">Creating a Dart/Flutter library</a></h1>
<p>In this chapter, we discuss how to add <code>flutter_rust_bridge</code> (FRB)
to an already existing application or create a new application from scratch;
this section covers creating a Dart-only library with a Flutter wrapper library on top.</p>
<p>In many cases, following this guide is actually easier long-term than creating
an application around FRB directly, but it does have a bit of overhead to set up.
This is also true when only using a library internally, because this guide will
also help you get set up with Melos, a monorepo tool specifically built for Dart/Flutter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>This section of the user guide will walk you through the entire process of
making a Dart-only library base with a Flutter library built on top of it.</p>
<p>In the end, if you choose to publish to pub.dev, users can simply run:</p>
<ul>
<li><code>flutter pub add flutter_library_name</code> for Flutter</li>
<li><code>dart pub add library_name</code> for Dart-only (say for a CLI or server app)</li>
</ul>
<p>But you also don't need to publish your library either!
You can just use your library internally in a monorepo,
<a href="library/melos.html">as described later on</a>.</p>
<h2 id="high-level-design"><a class="header" href="#high-level-design">High Level Design</a></h2>
<p>We will build out our library from scratch, piece by piece, allowing you to include
only what you want in your library.
It is intended that whenever a code snippet/file is shown, you read and understand the
content of the snippet so that you can work with your library more easily in the future.
We will create the following components:</p>
<ul>
<li>Dart-only library</li>
<li>Flutter library wrapping the Dart-only library</li>
<li>CI/CD with GitHub Actions
<ul>
<li>Dart/Flutter unit &amp; integration testing
<ul>
<li>Test your code on all supported Flutter platforms automatically!</li>
</ul>
</li>
<li>Automate release creation
<ul>
<li>Release library binaries through GitHub releases</li>
<li>Create pub.dev releases automatically on GitHub release</li>
</ul>
</li>
</ul>
</li>
<li>Custom build system to cross-compile to all supported Flutter platforms
<ul>
<li>You need a Mac to compile to macOS/iOS (at least locally)
<ul>
<li>But CI can handle your compilation/releases if you don't have a Mac!</li>
</ul>
</li>
<li>Can cross-compile to all other Flutter platforms, no matter your dev device</li>
</ul>
</li>
</ul>
<p>For a full working example (that this guide was created based on!),
take a look at <a href="https://github.com/GregoryConrad/mimir">mimir</a> (which is created by the author of this chapter of document).
It incorporates all functionality present in this guide and some more.</p>
<h2 id="warning"><a class="header" href="#warning">Warning!</a></h2>
<p>Please note, this entire section will be outdated &amp; need to be overhauled once
<a href="https://github.com/dart-lang/sdk/issues/50565">"Native Assets"</a> are added to Dart.
A lot of the techniques described here are merely workarounds until Dart supports Native Assets.</p>
<p>Also, this guide does not currently cover web support, but provides the necessary ground work
to support web in the future.
It <em>may</em> be worth waiting for Native Assets before trying to come up with a custom solution for WASM.
Feel free to PR to add web support to this guide!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>To start developing your Dart/Flutter library, you will need to download some dependencies locally.</p>
<h3 id="required"><a class="header" href="#required">Required</a></h3>
<p>The rest of this guide assumes you have the following tools installed on any development machines:</p>
<ul>
<li><a href="https://docs.flutter.dev/get-started/install">Flutter</a></li>
<li><a href="https://rustup.rs">rustup</a></li>
<li><a href="https://melos.invertase.dev">Melos</a> (needed for our monorepo, see <a href="library/melos.html">here</a>)
<ul>
<li><code>dart pub global activate melos</code> to install once Dart/Flutter are installed</li>
</ul>
</li>
</ul>
<h3 id="optional"><a class="header" href="#optional">Optional</a></h3>
<p>If you would like to build your binaries (for Flutter devices) locally in addition to CI
(say, to test on a real device or emulator), you will additionally need the following:</p>
<ul>
<li>To compile to macOS/iOS targets
<ul>
<li>macOS</li>
</ul>
</li>
<li>To cross-compile to Android targets
<ul>
<li><a href="https://developer.android.com/ndk/downloads">Android NDK</a>
<ul>
<li>Most NDK versions should work nowadays due to fixes in <code>cargo-ndk</code>
<ul>
<li>Previously, NDK version 21 (<code>r21e</code>) was the only one that could be used easily
<ul>
<li>You might see reference to this elsewhere, but that is largely out of date</li>
</ul>
</li>
<li>NDK version 25 (<code>r25b</code>) was working at the time of writing this documentation</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>To cross-compile to Windows/Linux targets
<ul>
<li><a href="https://ziglang.org/learn/getting-started/#installing-zig">Zig</a></li>
<li>llvm (with <code>clang-cl</code>!)
<ul>
<li>Need to run <code>brew install llvm</code> on macOS since Apple's llvm doesn't have it</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="repository-structure"><a class="header" href="#repository-structure">Repository Structure</a></h2>
<p>We will be using the following structure for our repository, assuming our library name is <code>library_name</code>:</p>
<ul>
<li><code>.github/</code> for CI/CD (with GitHub Actions) &amp; dependabot</li>
<li><code>packages/</code> where our Flutter/Dart packages will live
<ul>
<li><code>library_name/</code> the Dart-only (library) package using flutter_rust_bridge (FRB)
<ul>
<li><code>native/</code> the Rust library used by Dart</li>
<li><code>test/</code> unit tests for our Dart-only library</li>
<li><code>example/</code> an example project showing how to use <code>library_name</code> from Dart-only
<ul>
<li><code>test/</code> (optional) tests for the example; can be used to ensure example continues to work in CI</li>
</ul>
</li>
</ul>
</li>
<li><code>flutter_library_name/</code> the Flutter (library) package wrapping around <code>library_name</code> for ease of use
<ul>
<li><code>android/</code>, <code>ios/</code>, <code>linux/</code>, <code>macos/</code>, &amp; <code>windows/</code> for platform-specific wrappers in order to bundle our library binaries with Flutter applications</li>
<li><code>test/</code> unit tests for our Flutter library (note: there might not be any if your Flutter library does not add any Flutter-specific functionality; in that case, add a dummy test in so CI is happy)</li>
<li><code>example/</code> an example project showing how to use <code>flutter_library_name</code> from within a Flutter application
<ul>
<li><code>integration_test/</code> integration tests to ensure your Flutter library, example, and platform-specific configuration are all working together correctly</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>scripts/</code> build Flutter binaries and handle release creation</li>
<li><code>platform-build/</code> the output (build) folder for all created Flutter binaries</li>
<li><code>analysis_options.yaml</code> to enable consistent Dart analysis in our Dart/Flutter libraries</li>
<li><code>Cargo.toml</code> so IDEs can find our Rust project under <code>packages/library_name/native</code></li>
<li><code>melos.yaml</code> to configure the monorepo, see more <a href="library/library/melos.html">here</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monorepo-with-melos"><a class="header" href="#monorepo-with-melos">Monorepo with Melos</a></h1>
<p>This page covers the basics of how to setup and use <a href="https://melos.invertase.dev">Melos</a>,
a Dart/Flutter focused monorepo tool, so you can use it to manage your own monorepo.</p>
<p>While you can, in theory, go about this guide without using Melos,
<em>using Melos will save you a lot of time and headache</em>.
There is some slight upfront cost of configuring and learning how Melos works,
but it pays off substantially in the long-term.</p>
<p>The rest of this guide assumes you are using Melos, so here are the steps to setup Melos,
along with some common commands.</p>
<p>It is also highly recommended that you read the Melos documentation linked above, as this
page only covers the bare minimum and it is likely you will want to do more than listed here.</p>
<h2 id="melosyaml"><a class="header" href="#melosyaml"><code>/melos.yaml</code></a></h2>
<p>Here is a sample of Melos' configuration file to get you started:</p>
<pre><code class="language-yaml">name: library_name

repository: https://github.com/YourGitHubAccount/library_name

packages:
  - packages/**

scripts:
  analyze:
    exec: flutter analyze .
    description: Analyze a specific package in this project.

  check-format:
    exec: dart format --set-exit-if-changed .
    description: Check the format of a specific package in this project.

  format:
    exec: dart format .
    description: Format a specific package in this project.

  version:
    description: Updates version numbers in all build files
    run: bash scripts/version.sh

  build:
    run: melos run build:apple &amp;&amp; melos run build:android &amp;&amp; melos run build:other
    description: Build all native libraries for the project.

  build:apple:
    run: bash scripts/build-apple.sh
    description: Build the XCFramework for iOS and macOS.

  build:android:
    run: bash scripts/build-android.sh
    description: Build the .tar.gz for Android.

  build:other:
    run: bash scripts/build-other.sh
    description: Build the .tar.gz for all other platforms.

  test:
    run: melos run test:dart --no-select &amp;&amp; melos run test:flutter --no-select
    description: Run all Dart &amp; Flutter tests in this project.

  test:dart:
    run: melos exec -c 1 --fail-fast -- "dart test test"
    description: Run Dart tests for a specific package in this project.
    select-package:
      flutter: false
      dir-exists: test

  test:flutter:
    run: melos exec -c 1 --fail-fast -- "flutter test test"
    description: Run Flutter tests for a specific package in this project.
    select-package:
      flutter: true
      dir-exists: test
</code></pre>
<p>You can run the melos "scripts" defined in this file with <code>melos run ...</code>,
e.g. <code>melos run build:android</code> to build a .tar.gz for Android devices.
Also, when you first setup your Melos repo, you will need to run <code>melos bootstrap</code> (or <code>melos bs</code> for short).
To clean your repo in the future, you can run <code>melos clean &amp;&amp; melos bs</code>.</p>
<h2 id="scriptsversionsh"><a class="header" href="#scriptsversionsh"><code>/scripts/version.sh</code></a></h2>
<p>Every time you need to make a new release of your library, Melos will take care of the heavy lifting for you.
Melos creates new versions via the simple command, <code>melos version</code>.
<code>melos version</code> creates and manages git tags, in addition to automatically incrementing the version numbers appropriately.</p>
<p>Since we are distributing our binaries separately from the Dart/Flutter packages on pub.dev, we take advantage of
a special "melos script" defined in the configuration file, named "version".
In this versioning script, we change the version numbers for our Flutter build process so that consumers of our library
will always get the binaries associated with their version.</p>
<p>Replace all instances of <code>library_name</code> below with your library name.</p>
<pre><code class="language-bash">#!/bin/bash

CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`

# iOS &amp; macOS
APPLE_HEADER="release_tag_name = '$CURR_VERSION' # generated; do not edit"
sed -i.bak "1 s/.*/$APPLE_HEADER/" packages/flutter_library_name/ios/flutter_library_name.podspec
sed -i.bak "1 s/.*/$APPLE_HEADER/" packages/flutter_library_name/macos/flutter_library_name.podspec
rm packages/flutter_library_name/macos/*.bak packages/flutter_library_name/ios/*.bak

# CMake platforms (Linux, Windows, and Android)
CMAKE_HEADER="set(LibraryVersion \"$CURR_VERSION\") # generated; do not edit"
for CMAKE_PLATFORM in android linux windows
do
    sed -i.bak "1 s/.*/$CMAKE_HEADER/" packages/flutter_library_name/$CMAKE_PLATFORM/CMakeLists.txt
    rm packages/flutter_library_name/$CMAKE_PLATFORM/*.bak
done

git add packages/flutter_library_name/
</code></pre>
<h2 id="conventional-commits"><a class="header" href="#conventional-commits">Conventional Commits</a></h2>
<p>For Melos versioning to work, which our monorepo relies on to distribute binaries properly,
you need to use "conventional commits."
If you are not familiar with conventional commits, that is ok.
Simply read up on conventional commits in the <a href="https://melos.invertase.dev/guides/automated-releases#versioning">Melos guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-libraries"><a class="header" href="#creating-the-libraries">Creating the libraries</a></h1>
<p>In this section, we will create our Dart-only base library and then
a Flutter wrapper library built on top of the Dart-only base.</p>
<p>The Flutter library can add additional Flutter-specific functionality
to your Dart-only base; however, it does not need to.
The main purpose of the Flutter wrapper is to bundle the Rust binaries
alongside your Dart library and to re-export the Dart library.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dart-only-base"><a class="header" href="#dart-only-base">Dart-only base</a></h1>
<p>This page details how to set up the initial structure of our monorepo,
including the crucial Dart-only base package.</p>
<h2 id="initialization-script"><a class="header" href="#initialization-script">Initialization script</a></h2>
<p>This script creates a new monorepo named <code>$LIBNAME</code> in the current working directory
and initializes it with some needed files.
The following script assumes a bash shell, which you should make sure to use to run it.
Also, the script generates some ffi convenience files in your Dart <code>src/</code> which you should
check out after the script completes.</p>
<p>After the script runs, change the <code>flutter_rust_bridge</code> dependency in <code>/packages/library_name/pubspec.yaml</code> to the following:</p>
<pre><code class="language-yaml">  flutter_rust_bridge: "1.62.1"
</code></pre>
<p>Note: If you so choose, you can update the <code>flutter_rust_bridge</code> versions in
<code>/packages/library_name/native/Cargo.toml</code> and <code>/packages/library_name/pubspec.yaml</code>
to the latest version available, but newer versions are not guaranteed to work
with this section of the guide due to a lack of CI testing.
Version 1.62.1 is known to work with this guide as-is.
CI testing is planned once the Native Assets feature is released.</p>
<p>Finally, change the variables at the top of the script to fit your needs.</p>
<pre><code class="language-bash">LIBNAME=library_name # snake_case
DART_CLASS_NAME=LibraryName # probably is PascalCase version of $LIBNAME

# Monorepo setup
mkdir -p $LIBNAME/packages
cd $LIBNAME
git init

cat &lt;&lt; EOF &gt;&gt; Cargo.toml
[workspace]
members = ["packages/$LIBNAME/native"]
EOF

cat &lt;&lt; EOF &gt;&gt; analysis_options.yaml
# TODO change the below options/lints as you see fit
analyzer:
  exclude:
    - '**.freezed.dart'
    - '**.g.dart'
  language:
    strict-inference: true
    strict-raw-types: true
  errors:
    invalid_annotation_target: ignore

linter:
  rules:
    # Custom lints
    - prefer_single_quotes

    # Core Dart lints
    - avoid_empty_else
    - avoid_relative_lib_imports
    - avoid_shadowing_type_parameters
    - avoid_types_as_parameter_names
    - await_only_futures
    - camel_case_extensions
    - camel_case_types
    - curly_braces_in_flow_control_structures
    - depend_on_referenced_packages
    - empty_catches
    - file_names
    - hash_and_equals
    - iterable_contains_unrelated_type
    - list_remove_unrelated_type
    - no_duplicate_case_values
    - non_constant_identifier_names
    - null_check_on_nullable_type_parameter
    - package_prefixed_library_names
    - prefer_generic_function_type_aliases
    - prefer_is_empty
    - prefer_is_not_empty
    - prefer_iterable_whereType
    - prefer_typing_uninitialized_variables
    - provide_deprecation_message
    - unnecessary_overrides
    - unrelated_type_equality_checks
    - valid_regexps
    - void_checks

    # Recommended Dart lints
    - always_require_non_null_named_parameters
    - annotate_overrides
    - avoid_function_literals_in_foreach_calls
    - avoid_init_to_null
    - avoid_null_checks_in_equality_operators
    - avoid_renaming_method_parameters
    - avoid_return_types_on_setters
    - avoid_returning_null_for_void
    - avoid_single_cascade_in_expression_statements
    - constant_identifier_names
    - control_flow_in_finally
    - empty_constructor_bodies
    - empty_statements
    - exhaustive_cases
    - implementation_imports
    - library_names
    - library_prefixes
    - library_private_types_in_public_api
    - no_leading_underscores_for_library_prefixes
    - no_leading_underscores_for_local_identifiers
    - null_closures
    - overridden_fields
    - package_names
    - prefer_adjacent_string_concatenation
    - prefer_collection_literals
    - prefer_conditional_assignment
    - prefer_contains
    - prefer_equal_for_default_values
    - prefer_final_fields
    - prefer_for_elements_to_map_fromIterable
    - prefer_function_declarations_over_variables
    - prefer_if_null_operators
    - prefer_initializing_formals
    - prefer_inlined_adds
    - prefer_interpolation_to_compose_strings
    - prefer_is_not_operator
    - prefer_null_aware_operators
    - prefer_spread_collections
    - prefer_void_to_null
    - recursive_getters
    - slash_for_doc_comments
    - type_init_formals
    - unnecessary_brace_in_string_interps
    - unnecessary_const
    - unnecessary_constructor_name
    - unnecessary_getters_setters
    - unnecessary_late
    - unnecessary_new
    - unnecessary_null_aware_assignments
    - unnecessary_null_in_if_null_operators
    - unnecessary_nullable_for_final_variable_declarations
    - unnecessary_string_escapes
    - unnecessary_string_interpolations
    - unnecessary_this
    - use_function_type_syntax_for_parameters
    - use_rethrow_when_possible

    # Flutter lints
    - avoid_print
    - avoid_unnecessary_containers
    - avoid_web_libraries_in_flutter
    - no_logic_in_create_state
    - prefer_const_constructors
    - prefer_const_constructors_in_immutables
    - prefer_const_declarations
    - prefer_const_literals_to_create_immutables
    - sized_box_for_whitespace
    - sort_child_properties_last
    - use_build_context_synchronously
    - use_full_hex_values_for_flutter_colors
    - use_key_in_widget_constructors
EOF

cat &lt;&lt; EOF &gt;&gt; .gitignore
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
pubspec.lock
pubspec_overrides.yaml
**/doc/api/
.dart_tool/
.packages
build/
.pub-cache/
.pub/
.flutter-plugins
.flutter-plugins-dependencies

# Rust related
/target/
/Cargo.lock
/platform-build
EOF

# Dart setup
DART_BASE=packages/$LIBNAME
dart create --template=package $DART_BASE
(cd $DART_BASE &amp;&amp; dart pub add flutter_rust_bridge ffi &amp;&amp; dart pub add ffigen --dev)
rm $DART_BASE/analysis_options.yaml # we provide our own in repo root
( # ffi setup
cd $DART_BASE
mkdir -p lib/src/ffi

cat &lt;&lt; EOF &gt;&gt; lib/src/ffi/stub.dart
import 'package:$LIBNAME/src/bridge_generated.dart';

/// Represents the external library for $LIBNAME
///
/// Will be a DynamicLibrary for dart:io or WasmModule for dart:html
typedef ExternalLibrary = Object;

$DART_CLASS_NAME createWrapperImpl(ExternalLibrary lib) =&gt;
    throw UnimplementedError();
EOF

cat &lt;&lt; EOF &gt;&gt; lib/src/ffi/io.dart
import 'dart:ffi';

import 'package:$LIBNAME/src/bridge_generated.dart';

typedef ExternalLibrary = DynamicLibrary;

$DART_CLASS_NAME createWrapperImpl(ExternalLibrary dylib) =&gt;
    ${DART_CLASS_NAME}Impl(dylib);
EOF

cat &lt;&lt; EOF &gt;&gt; lib/src/ffi/web.dart
import 'package:$LIBNAME/src/bridge_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';

typedef ExternalLibrary = WasmModule;

$DART_CLASS_NAME createWrapperImpl(ExternalLibrary module) =&gt;
    ${DART_CLASS_NAME}Impl.wasm(module);
EOF

cat &lt;&lt; EOF &gt;&gt; lib/src/ffi.dart
import 'bridge_generated.dart';
import 'ffi/stub.dart'
    if (dart.library.io) 'ffi/io.dart'
    if (dart.library.js_interop) 'ffi/web.dart';

$DART_CLASS_NAME? _wrapper;

$DART_CLASS_NAME createWrapper(ExternalLibrary lib) {
  _wrapper ??= createWrapperImpl(lib);
  return _wrapper!;
}
EOF

echo "export 'src/ffi.dart';" &gt;&gt; lib/$LIBNAME.dart
)

# Rust setup
RUST_BASE=$DART_BASE/native
mkdir -p $RUST_BASE/src

cat &lt;&lt; EOF &gt;&gt; $RUST_BASE/build.rs
use lib_flutter_rust_bridge_codegen::{
    config_parse, frb_codegen, get_symbols_if_no_duplicates, RawOpts,
};

const RUST_INPUT: &amp;str = "src/api.rs";
const DART_OUTPUT: &amp;str = "../lib/src/bridge_generated.dart";

const IOS_C_OUTPUT: &amp;str = "../../flutter_$LIBNAME/ios/Classes/frb.h";
const MACOS_C_OUTPUT_DIR: &amp;str = "../../flutter_$LIBNAME/macos/Classes/";

fn main() {
    // Tell Cargo that if the input Rust code changes, rerun this build script
    println!("cargo:rerun-if-changed={}", RUST_INPUT);

    // Options for frb_codegen
    let raw_opts = RawOpts {
        rust_input: vec![RUST_INPUT.to_string()],
        dart_output: vec![DART_OUTPUT.to_string()],
        c_output: Some(vec![IOS_C_OUTPUT.to_string()]),
        extra_c_output_path: Some(vec![MACOS_C_OUTPUT_DIR.to_string()]),
        inline_rust: true,
        wasm: true,
        ..Default::default()
    };

    // Generate Rust &amp; Dart ffi bridges
    let configs = config_parse(raw_opts);
    let all_symbols = get_symbols_if_no_duplicates(&amp;configs).unwrap();
    for config in configs.iter() {
        frb_codegen(config, &amp;all_symbols).unwrap();
    }

    // Format the generated Dart code
    _ = std::process::Command::new("flutter")
        .arg("format")
        .arg("..")
        .spawn();
}
EOF

cat &lt;&lt; EOF &gt;&gt; $RUST_BASE/.gitignore
# Rust library related
Cargo.lock
target
EOF

cat &lt;&lt; EOF &gt;&gt; $RUST_BASE/Cargo.toml
[package]
name = "$LIBNAME"
version = "0.0.0"
edition = "2018"

[lib]
crate-type = ["staticlib", "cdylib"]

[build-dependencies]
flutter_rust_bridge_codegen = "1.62.*"

[dependencies]
flutter_rust_bridge = "1.62.*"
EOF

touch $RUST_BASE/src/api.rs

cat &lt;&lt; EOF &gt;&gt; $RUST_BASE/src/lib.rs
mod api;
EOF

cargo build
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flutter-wrapper"><a class="header" href="#flutter-wrapper">Flutter wrapper</a></h1>
<p>On this page, we will start creating the Flutter wrapper around our Dart-only library package.
We start with the plugin_ffi Flutter template since it is somewhat similar to what we need,
but we will need to modify it significantly in the coming steps.
Configuring the build processes for each supported platform is also a bit involved,
so those are covered individually in the coming pages.</p>
<p>Run <code>flutter create --help</code> to see all the available options; you may want to set some (like <code>--org</code>).</p>
<p>Finally, in the <code>packages</code> folder, run the following, adding any other options you choose
and replacing <code>library_name</code> with your library name:</p>
<pre><code class="language-bash">flutter create --template=plugin_ffi --platforms=android,ios,macos,linux,windows --org=com.example flutter_library_name
</code></pre>
<h2 id="additional-setup-steps"><a class="header" href="#additional-setup-steps">Additional setup steps</a></h2>
<ol>
<li>Add your Dart-only base as a dependency in your new Flutter package's <code>pubspec.yaml</code>.
<em>Use the version syntax, e.g. <code>^1.0.0</code></em>. Melos will take care of the dependency resolution for us.</li>
<li>If you choose to have integration testing in CI (recommended),
add an <code>integration_test</code> folder to your Flutter package's and/or Flutter example package's root directory,
then add the following to the  <code>pubspec.yaml</code> of the applicable package(s):</li>
</ol>
<pre><code class="language-yaml">dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter
</code></pre>
<ol start="3">
<li>In <code>/packages/flutter_library_name/lib/flutter_library_name.dart</code>,
add the following near the top of the file, replacing <code>library_name</code> with your Dart-only package's name:</li>
</ol>
<pre><code class="language-dart">export 'package:library_name/library_name.dart';
</code></pre>
<p>This re-exports your Dart-only package to users of your Flutter package,
so they only need to do one <code>flutter pub add</code>.</p>
<ol start="4">
<li>Finally, we will need to write some code to be able to handle FFI in Flutter.
Modify the following as needed (replacing <code>library_name</code> and <code>LibraryName</code> with your library name).</li>
</ol>
<pre><code class="language-dart">// lib/src/ffi/stub.dart
Object createLibraryImpl() =&gt; throw UnimplementedError();
</code></pre>
<pre><code class="language-dart">// lib/src/ffi/io.dart
import 'dart:ffi';
import 'dart:io';

DynamicLibrary createLibraryImpl() {
  const base = 'library_name';

  if (Platform.isIOS || Platform.isMacOS) {
    return DynamicLibrary.open('$base.framework/$base');
  } else if (Platform.isWindows) {
    return DynamicLibrary.open('$base.dll');
  } else {
    return DynamicLibrary.open('lib$base.so');
  }
}
</code></pre>
<pre><code class="language-dart">// lib/src/ffi/web.dart
import 'package:library_name/library_name.dart';

WasmModule createLibraryImpl() {
  // TODO add web support. See:
  // https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/with_flutter/lib/ffi.web.dart
  throw UnsupportedError('Web support is not provided yet.');
}
</code></pre>
<pre><code class="language-dart">// lib/src/ffi.dart
import 'package:library_name/library_name.dart';
import 'ffi/stub.dart'
    if (dart.library.io) 'ffi/io.dart'
    if (dart.library.js_interop) 'ffi/web.dart';

LibraryName createLib() =&gt;
    createWrapper(createLibraryImpl());
</code></pre>
<ol start="5">
<li>Run <code>melos bs</code></li>
</ol>
<p>Now, inside your Flutter library, you can call <code>createLib()</code> to get an instance of the FRB-generated Dart class!
However, it won't work just yet; we will wire up our Flutter package to use our Rust binaries in the next subsection.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platform-setup"><a class="header" href="#platform-setup">Platform setup</a></h1>
<p>In this subsection, we will be exploring how to set up our Flutter wrapper package
to bundle the platform-specific Rust binaries so users of the library will be able
to actually use the library.
After creating the Flutter wrapper on the previous page, you may have noticed that
you get a runtime error when trying to use it as-is because of <code>DynamicLibrary</code>;
this is because the binaries are not yet distributed along with the package!</p>
<h2 id="binary-distribution"><a class="header" href="#binary-distribution">Binary distribution</a></h2>
<p>Unfortunately, at the time of writing, pub.dev has a hard 100 MB upload limit and
discourages distributing platform-specific binaries through pub.dev directly.
In the future, hopefully with Native Assets, there will be a way to distribute
our Rust binaries through pub.dev, or something similar, which will make
distribution as a library author <em>much</em> more convenient.</p>
<p>In the meantime, however, we will need to work around these limitations. There are
many ways to distribute the binaries ourselves, outside of pub.dev, but in this
subsection, we will cover using GitHub releases because it easily integrates with
our CI/CD solution, GitHub Actions (more on this <a href="library/ci.html">later</a>).</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>If you look in your Flutter wrapper's pubspec (<code>/packages/flutter_library_name/pubspec.yaml</code>),
you should notice the following section near the bottom
(if you don't see this, or it is incomplete, add it now!):</p>
<pre><code class="language-yaml">flutter:
  plugin:
    platforms:
      ios:
        ffiPlugin: true
      macos:
        ffiPlugin: true
      android:
        ffiPlugin: true
      linux:
        ffiPlugin: true
      windows:
        ffiPlugin: true
</code></pre>
<p>This section of the pubspec tells Flutter that our package is using the newer
ffi plugins format instead of the older platform channels Flutter has.
This makes the work on our end much simpler, because instead of having to
specify platform channels for each platform supported, we now only have to
bundle the binaries with our package.</p>
<p>But, the key here is that we still must bundle our binaries along with our package.
To do so, we have to follow a certain procedure (<em>read this; it is important</em>):</p>
<ol>
<li>We have a series of build scripts (<code>/scripts/build-*.sh</code>) that build all of our
platform specific binaries into <code>/platform-build</code> and package them up appropriately,
based on the target platform.
Example: on iOS/macOS, this bundle is an XCFramework, on Windows/Linux, it is a <code>.tar.gz</code>.</li>
<li>These binaries are uploaded to somewhere online; as mentioned previously, we will use
GitHub releases in this guide (which is <a href="library/ci.html">automated in ci</a>).</li>
<li>When the Dart tooling builds our library (such as when an application consuming
our library is built), it invokes the platform specific build process.
We hijack this build process by downloading a copy of the binaries for the needed platform,
<em>if not already present on the filesystem</em>. This last part is the key; it allows us to run
integration tests locally and in CI by providing our own copy of the binaries instead of
forcing our build process to always fetch the binaries from GitHub releases.</li>
<li>After the binaries are stored locally (either by being copied to the proper folder(s)
or by fetching them from online), we extract them and place them in the needed locations.</li>
</ol>
<p>Here are the relevant directories per platform.
This is helpful for if you want to test your library on a real device or emulator locally.
Also note: replace <code>library_name</code> below with your library name, and replace <code>library_tag</code> below with
<code>library_name-vVERSION</code> where <code>VERSION</code> is the current version in your Dart-only <code>pubspec.yaml</code>.
This setup is a bit of a pain to test locally with but I am not sure there is a better way at the moment
(other than creating a melos script to copy over all the binaries for you).
The idea here is that you will do most of your integration tests in CI.</p>
<ul>
<li>Binary archive locations (copy created archives from <code>/platform-build</code> to these locations to test locally)
<ul>
<li>iOS (<code>/plaform-build/LibraryName.xcframework.zip</code>): <code>/packages/flutter_library_name/ios/Frameworks/library_tag.zip</code></li>
<li>macOS (<code>/platform-build/LibraryName.xcframework.zip</code>): <code>/packages/flutter_library_name/macos/Frameworks/library_tag.zip</code></li>
<li>Android (<code>/platform-build/android.tar.gz</code>): <code>/packages/flutter_library_name/android/library_tag.tar.gz</code></li>
<li>Windows (<code>/platform-build/other.tar.gz</code>): <code>/packages/flutter_library_name/windows/library_tag.tar.gz</code></li>
<li>Linux (<code>/platform-build/other.tar.gz</code>): <code>/packages/flutter_library_name/linux/library_tag.tar.gz</code></li>
</ul>
</li>
<li>Extracted binary locations (not as important to know, but helps understand the build process)
<ul>
<li>iOS: <code>/packages/flutter_library_name/ios/Frameworks/</code></li>
<li>macOS: <code>/packages/flutter_library_name/macos/Frameworks/</code></li>
<li>Android: <code>/packages/flutter_library_name/android/src/main/jniLibs/</code>
<ul>
<li>If you know what an <code>aar</code> is, Flutter does something similar for android plug-ins under the hood</li>
</ul>
</li>
<li>Windows: <code>/packages/flutter_library_name/windows/</code></li>
<li>Linux: <code>/packages/flutter_library_name/linux/</code></li>
</ul>
</li>
</ul>
<p>Always use melos to build the latest version(s) of the binaries (e.g. <code>melos run build:android</code>)
<em>before copying the binary archives from <code>/platform-build/</code> and testing locally</em>!
Also, <em>do not check the <code>/platform-build/</code> or <code>/target/</code> directories into source control</em>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows--linux"><a class="header" href="#windows--linux">Windows &amp; Linux</a></h1>
<p>Windows and Linux both use CMake for their build system,
so this page will walk you through setting up CMake for Windows/Linux.</p>
<p>Also, this page will introduce the windows &amp; linux build script
to compile your Rust library to these platforms.</p>
<h2 id="cmake"><a class="header" href="#cmake">CMake</a></h2>
<p>CMake happens to be by far the easiest build process to set up
of of all the Flutter supported platforms.</p>
<p>Replace all instances of <code>library_name</code> below with your library name.
Also, replace other variables (i.e. <code>YourGitHubAccount</code> and <code>repo_name</code>) as needed.</p>
<h3 id="linux-cmakeliststxt-packagesflutter_library_namelinuxcmakeliststxt"><a class="header" href="#linux-cmakeliststxt-packagesflutter_library_namelinuxcmakeliststxt">Linux CMakeLists.txt (<code>/packages/flutter_library_name/linux/CMakeLists.txt</code>)</a></h3>
<pre><code class="language-cmake">set(LibraryVersion "library_name-v0.0.0") # generated; do not edit

# The Flutter tooling requires that developers have CMake 3.10 or later
# installed. You should not increase this version, as doing so will cause
# the plugin to fail to compile for some customers of the plugin.
cmake_minimum_required(VERSION 3.10)

# Project-level configuration.
set(PROJECT_NAME "flutter_library_name")
project(${PROJECT_NAME} LANGUAGES CXX)

# Download the binaries if they are not already present.
set(LibRoot "${CMAKE_CURRENT_SOURCE_DIR}/${LibraryVersion}")
set(ArchivePath "${LibRoot}.tar.gz")
if(NOT EXISTS ${ArchivePath})
  file(DOWNLOAD
    "https://github.com/YourGitHubAccount/repo_name/releases/download/${LibraryVersion}/other.tar.gz"
    ${ArchivePath}
    TLS_VERIFY ON
  )
endif()

# Extract the binaries, overriding any already present.
file(REMOVE_RECURSE ${LibRoot})
file(MAKE_DIRECTORY ${LibRoot})
execute_process(
  COMMAND ${CMAKE_COMMAND} -E tar xzf ${ArchivePath}
  WORKING_DIRECTORY ${LibRoot}
)

# List of absolute paths to libraries that should be bundled with the plugin.
# This list could contain prebuilt libraries, or libraries created by an
# external build triggered from this build file.
set(flutter_library_name_bundled_libraries
  "${LibRoot}/${FLUTTER_TARGET_PLATFORM}/liblibrary_name.so"
  PARENT_SCOPE
)
</code></pre>
<h3 id="windows-cmakeliststxt-packagesflutter_library_namewindowscmakeliststxt"><a class="header" href="#windows-cmakeliststxt-packagesflutter_library_namewindowscmakeliststxt">Windows CMakeLists.txt (<code>/packages/flutter_library_name/windows/CMakeLists.txt</code>)</a></h3>
<pre><code class="language-cmake">set(LibraryVersion "library_name-v0.0.0") # generated; do not edit

# TODO Remove this workaround once Flutter supports Windows ARM.
# https://github.com/flutter/flutter/issues/116196
set(FLUTTER_TARGET_PLATFORM windows-x64)

# The Flutter tooling requires that developers have a version of Visual Studio
# installed that includes CMake 3.14 or later. You should not increase this
# version, as doing so will cause the plugin to fail to compile for some
# customers of the plugin.
cmake_minimum_required(VERSION 3.14)

# Project-level configuration.
set(PROJECT_NAME "flutter_library_name")
project(${PROJECT_NAME} LANGUAGES CXX)

# Download the binaries if they are not already present.
set(LibRoot "${CMAKE_CURRENT_SOURCE_DIR}/${LibraryVersion}")
set(ArchivePath "${LibRoot}.tar.gz")
if(NOT EXISTS ${ArchivePath})
  file(DOWNLOAD
    "https://github.com/YourGitHubAccount/repo_name/releases/download/${LibraryVersion}/other.tar.gz"
    ${ArchivePath}
    TLS_VERIFY ON
  )
endif()

# Extract the binaries, overriding any already present.
file(REMOVE_RECURSE ${LibRoot})
file(MAKE_DIRECTORY ${LibRoot})
execute_process(
  COMMAND ${CMAKE_COMMAND} -E tar xzf ${ArchivePath}
  WORKING_DIRECTORY ${LibRoot}
)

# List of absolute paths to libraries that should be bundled with the plugin.
# This list could contain prebuilt libraries, or libraries created by an
# external build triggered from this build file.
set(flutter_library_name_bundled_libraries
  "${LibRoot}/${FLUTTER_TARGET_PLATFORM}/library_name.dll"
  PARENT_SCOPE
)
</code></pre>
<h3 id="platform-specific-peculiarities"><a class="header" href="#platform-specific-peculiarities">Platform-Specific Peculiarities</a></h3>
<p>There exists a few differences between the Linux and Windows <code>CMakeLists.txt</code>s:</p>
<ol>
<li>The minimum CMake version supported</li>
<li>At the time of writing, Windows CMake does not yet have a builtin <code>FLUTTER_TARGET_PLATFORM</code> variable; thus, we need to define a dummy version of the variable. See <a href="https://github.com/flutter/flutter/issues/116196">here</a> for updates on this issue</li>
<li>On linux, dynamic library names follow the form of <code>liblibrary_name.so</code> and on Windows, dynamic library names follow the form of <code>library_name.dll</code></li>
</ol>
<h2 id="gitignore"><a class="header" href="#gitignore"><code>.gitignore</code></a></h2>
<p>If you choose to have a .gitignore in your <code>linux/</code> and <code>windows/</code> directories, here is what the author of this page uses:</p>
<pre><code class="language-gitignore"># Set up as allowlist
*

# Allowed files
!.gitignore
!CMakeLists.txt
</code></pre>
<h2 id="build-script-scriptsbuild-othersh"><a class="header" href="#build-script-scriptsbuild-othersh">Build Script (<code>/scripts/build-other.sh</code>)</a></h2>
<p>Replace <code>library_name</code> below as needed.</p>
<pre><code class="language-bash">#!/bin/bash

# Setup
BUILD_DIR=platform-build
mkdir $BUILD_DIR
cd $BUILD_DIR

# Install build dependencies
cargo install cargo-zigbuild
cargo install cargo-xwin

zig_build () {
    local TARGET="$1"
    local PLATFORM_NAME="$2"
    local LIBNAME="$3"
    rustup target add "$TARGET"
    cargo zigbuild --target "$TARGET" -r
    mkdir "$PLATFORM_NAME"
    cp "../target/$TARGET/release/$LIBNAME" "$PLATFORM_NAME/"
}

win_build () {
    local TARGET="$1"
    local PLATFORM_NAME="$2"
    local LIBNAME="$3"
    rustup target add "$TARGET"
    cargo xwin build --target "$TARGET" -r
    mkdir "$PLATFORM_NAME"
    cp "../target/$TARGET/release/$LIBNAME" "$PLATFORM_NAME/"
}

# Build all the dynamic libraries
LINUX_LIBNAME=liblibrary_name.so
zig_build aarch64-unknown-linux-gnu linux-arm64 $LINUX_LIBNAME
zig_build x86_64-unknown-linux-gnu linux-x64 $LINUX_LIBNAME
WINDOWS_LIBNAME=library_name.dll
win_build aarch64-pc-windows-msvc windows-arm64 $WINDOWS_LIBNAME
win_build x86_64-pc-windows-msvc windows-x64 $WINDOWS_LIBNAME

# Archive the dynamic libs
tar -czvf other.tar.gz linux-* windows-*

# Cleanup
rm -rf linux-* windows-*
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ios--macos"><a class="header" href="#ios--macos">iOS &amp; macOS</a></h1>
<p>Flutter libraries targeting iOS and macOS use cocoapods for dependencies,
so this page will walk you through setting that up with FRB.</p>
<p>The simplist way the author of this page found to integrate with cocoapods for all
Apple platforms (iOS, iOS Simulator, and macOS) is to create an XCFramework.
While you don't need to know what an XCFramework is to follow this guide, if you
want to understand how this all works behind the scenes,
I'd recommend doing a quick Google search on "What is an XCFramework?".</p>
<p>Also, this page will introduce the iOS &amp; macOS build script (<code>build-apple.sh</code>)
to compile your Rust library for all Apple platforms. Note: unlike all of the other build scripts
presented in this guide (which we can run on any host OS), <code>build-apple.sh</code> must be run on macOS.</p>
<h2 id="directory-tree"><a class="header" href="#directory-tree">Directory Tree</a></h2>
<p>We will need to create several files for both iOS and macOS to:</p>
<ul>
<li>Prevent our Rust symbols from being accidentally stripped</li>
<li>Bundle our "XCFramework" with our Flutter library</li>
</ul>
<h3 id="iosclassesenforcebundlingswift-and-macosclassesenforcebundlingswift"><a class="header" href="#iosclassesenforcebundlingswift-and-macosclassesenforcebundlingswift"><code>ios/Classes/EnforceBundling.swift</code> and <code>macos/Classes/EnforceBundling.swift</code></a></h3>
<pre><code class="language-swift">public func dummyMethodToEnforceBundling() -&gt; Int64 {
  return dummy_method_to_enforce_bundling()
}
let dummyVar = dummyMethodToEnforceBundling();
</code></pre>
<h3 id="iosframeworksgitkeep-and-macosframeworksgitkeep"><a class="header" href="#iosframeworksgitkeep-and-macosframeworksgitkeep"><code>ios/Frameworks/.gitkeep</code> and <code>macos/Frameworks/.gitkeep</code></a></h3>
<p>No file contents here; simply add a blank file (i.e., <code>touch .gitkeep</code> in <code>bash</code>).</p>
<h3 id="iosgitignore"><a class="header" href="#iosgitignore"><code>ios/.gitignore</code></a></h3>
<pre><code class="language-gitignore">Flutter/
Runner/
Frameworks/*
!Frameworks/.gitkeep
</code></pre>
<h3 id="macosgitignore"><a class="header" href="#macosgitignore"><code>macos/.gitignore</code></a></h3>
<pre><code class="language-gitignore">Flutter/
Frameworks/*
!Frameworks/.gitkeep
</code></pre>
<h3 id="iosflutter_library_namepodspec-and-macosflutter_library_namepodspec-for-cocoapods"><a class="header" href="#iosflutter_library_namepodspec-and-macosflutter_library_namepodspec-for-cocoapods"><code>ios/flutter_library_name.podspec</code> and <code>macos/flutter_library_name.podspec</code> (for Cocoapods)</a></h3>
<p>We cannot use the CMake approach taken on other platforms with Cocoapods,
so we do something a bit different here. <code>.podspec</code> files are actually just ruby files;
due to this observation, we can access the system shell to make arbitrary changes.
While we could download and extract our Rust binaries for iOS/macOS in ruby directly,
it is much more straightforward to simply use bash/zsh.</p>
<p>Replace all instances of <code>library_name</code> and <code>LibraryName</code> below with your library name.
Also, replace other variables (i.e. <code>YourGitHubAccount</code> and <code>repo_name</code>) as needed.</p>
<p>Note: the same exact <code>flutter_library_name.podspec</code> is used for both iOS and macOS;
you can thank the <code>XCFramework</code> for this simplicity.</p>
<pre><code class="language-ruby">release_tag_name = 'library_name-v0.0.0' # generated; do not edit

# We cannot distribute the XCFramework alongside the library directly,
# so we have to fetch the correct version here.
framework_name = 'LibraryName.xcframework'
remote_zip_name = "#{framework_name}.zip"
url = "https://github.com/YourGitHubAccount/repo_name/releases/download/#{release_tag_name}/#{remote_zip_name}"
local_zip_name = "#{release_tag_name}.zip"
`
cd Frameworks
rm -rf #{framework_name}

if [ ! -f #{local_zip_name} ]
then
  curl -L #{url} -o #{local_zip_name}
fi

unzip #{local_zip_name}
cd -
`

Pod::Spec.new do |spec|
  spec.name          = 'library_name'
  spec.version       = '0.0.1'
  spec.license       = { :file =&gt; '../LICENSE' }
  spec.homepage      = 'https://github.com/YourGitHubAccount/repo_name'
  spec.authors       = { 'Your Name' =&gt; 'your-email@example.com' }
  spec.summary       = 'iOS/macOS Flutter bindings for library_name'

  spec.source              = { :path =&gt; '.' }
  spec.source_files        = 'Classes/**/*'
  spec.public_header_files = 'Classes/**/*.h'
  spec.vendored_frameworks = "Frameworks/#{framework_name}"

  spec.ios.deployment_target = '11.0'
  spec.osx.deployment_target = '10.11'
end
</code></pre>
<h2 id="build-script-scriptsbuild-applesh"><a class="header" href="#build-script-scriptsbuild-applesh">Build Script (<code>/scripts/build-apple.sh</code>)</a></h2>
<p>Replace <code>library_name</code> and <code>LibraryName</code> below as needed.</p>
<pre><code class="language-bash">#!/bin/bash

# Setup
BUILD_DIR=platform-build
mkdir $BUILD_DIR
cd $BUILD_DIR

# Build static libs
for TARGET in \
        aarch64-apple-ios x86_64-apple-ios aarch64-apple-ios-sim \
        x86_64-apple-darwin aarch64-apple-darwin
do
    rustup target add $TARGET
    cargo build -r --target=$TARGET
done

# Create XCFramework zip
FRAMEWORK="LibraryName.xcframework"
LIBNAME=liblibrary_name.a
mkdir mac-lipo ios-sim-lipo
IOS_SIM_LIPO=ios-sim-lipo/$LIBNAME
MAC_LIPO=mac-lipo/$LIBNAME
lipo -create -output $IOS_SIM_LIPO \
        ../target/aarch64-apple-ios-sim/release/$LIBNAME \
        ../target/x86_64-apple-ios/release/$LIBNAME
lipo -create -output $MAC_LIPO \
        ../target/aarch64-apple-darwin/release/$LIBNAME \
        ../target/x86_64-apple-darwin/release/$LIBNAME
xcodebuild -create-xcframework \
        -library $IOS_SIM_LIPO \
        -library $MAC_LIPO \
        -library ../target/aarch64-apple-ios/release/$LIBNAME \
        -output $FRAMEWORK
zip -r $FRAMEWORK.zip $FRAMEWORK

# Cleanup
rm -rf ios-sim-lipo mac-lipo $FRAMEWORK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="android"><a class="header" href="#android">Android</a></h1>
<p>There are a few different ways to integrate with our Android binaries when building for Android. None are particularly outstanding:</p>
<ul>
<li>An "Ivy Repository"
<ul>
<li>Works great, but impossible to test changes on an emulator locally or in CI :(</li>
</ul>
</li>
<li>Raw Groovy &amp; Gradle
<ul>
<li>Works in theory, but tedious to have to write all needed logic in Groovy/Gradle</li>
</ul>
</li>
<li>Starting an OS Shell
<ul>
<li>Similar to iOS &amp; macOS, see that section for more details on this</li>
<li>Wouldn't work on Windows development machines unfortunately; the started shell would not be <code>bash</code></li>
</ul>
</li>
<li>CMake
<ul>
<li>We call to CMake from Gradle to take care of fetching and processing our Android binaries</li>
<li>A somewhat odd approach, but works cross-platform and has code re-use from Windows/Linux!</li>
</ul>
</li>
</ul>
<p>Due to the above reasoning, we cover how to use CMake on this page. But do note, there are other possibilities out there.</p>
<h2 id="cmake-packagesflutter_library_nameandroidcmakeliststxt"><a class="header" href="#cmake-packagesflutter_library_nameandroidcmakeliststxt">CMake (<code>/packages/flutter_library_name/android/CMakeLists.txt</code>)</a></h2>
<p>Unlike windows and linux CMakeLists.txt, the android equivalent does
<em>not actually build anything</em>, which may come as a surprise.
Instead, its sole purpose is to download &amp; extract our Android binaries
in a cross-platform friendly way. Here is our android <code>CMakeLists.txt</code>:</p>
<pre><code class="language-cmake">set(LibraryVersion "library_name-v0.0.0") # generated; do not edit
set(PROJECT_NAME "project_name")

# Unlike the Windows &amp; Linux CMakeLists.txt, this Android equivalent is just here
# to download the Android binaries into src/main/jniLibs/ and does not build anything.
# The binary download/extraction is difficult to do concisely in Groovy/Gradle,
# at least across host platforms, so we are just reusing our Linux/Windows logic.

# The Flutter tooling requires that developers have CMake 3.10 or later
# installed. You should not increase this version, as doing so will cause
# the plugin to fail to compile for some customers of the plugin.
cmake_minimum_required(VERSION 3.10)

project(PROJECT_NAME)

# Download the binaries if they are not already present.
set(LibRoot "${CMAKE_CURRENT_SOURCE_DIR}/src/main/jniLibs")
set(ArchivePath "${CMAKE_CURRENT_SOURCE_DIR}/${LibraryVersion}.tar.gz")
if(NOT EXISTS ${ArchivePath})
  file(DOWNLOAD
    "https://github.com/YourGitHubAccount/repo_name/releases/download/${LibraryVersion}/android.tar.gz"
    ${ArchivePath}
    TLS_VERIFY ON
  )
endif()

# Extract the binaries, overriding any already present.
file(REMOVE_RECURSE ${LibRoot})
file(MAKE_DIRECTORY ${LibRoot})
execute_process(
  COMMAND ${CMAKE_COMMAND} -E tar xzf ${ArchivePath}
  WORKING_DIRECTORY ${LibRoot}
)
</code></pre>
<p>Replace all instances of <code>library_name</code> above with your library name.
Also, replace other variables (i.e. <code>YourGitHubAccount</code> and <code>repo_name</code>) as needed.</p>
<h2 id="buildgradle-changes"><a class="header" href="#buildgradle-changes"><code>build.gradle</code> Changes</a></h2>
<p>Replace the <code>android {...}</code> section at the bottom of <code>build.gradle</code> with the following:</p>
<pre><code class="language-gradle">android {
    compileSdkVersion 31

    defaultConfig {
        minSdkVersion 16
    }

    // Trigger the binary download/update over in CMakeLists.txt
    externalNativeBuild {
        cmake {
            path "CMakeLists.txt"
        }
    }
}
</code></pre>
<h2 id="gitignore-1"><a class="header" href="#gitignore-1"><code>.gitignore</code></a></h2>
<p>Add the following to <code>android/.gitignore</code></p>
<pre><code class="language-gitignore"># Ignore Rust binaries
src/main/jniLibs/
*.tar.gz
</code></pre>
<h2 id="build-script-scriptsbuild-androidsh"><a class="header" href="#build-script-scriptsbuild-androidsh">Build Script (<code>/scripts/build-android.sh</code>)</a></h2>
<pre><code class="language-bash">#!/bin/bash

# Setup
BUILD_DIR=platform-build
mkdir $BUILD_DIR
cd $BUILD_DIR

# Create the jniLibs build directory
JNI_DIR=jniLibs
mkdir -p $JNI_DIR

# Set up cargo-ndk
cargo install cargo-ndk
rustup target add \
        aarch64-linux-android \
        armv7-linux-androideabi \
        x86_64-linux-android \
        i686-linux-android

# Build the android libraries in the jniLibs directory
cargo ndk -o $JNI_DIR \
        --manifest-path ../Cargo.toml \
        -t armeabi-v7a \
        -t arm64-v8a \
        -t x86 \
        -t x86_64 \
        build --release 

# Archive the dynamic libs
cd $JNI_DIR
tar -czvf ../android.tar.gz *
cd -

# Cleanup
rm -rf $JNI_DIR
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="continuous-integration--deployment-cicd"><a class="header" href="#continuous-integration--deployment-cicd">Continuous Integration &amp; Deployment (CI/CD)</a></h1>
<p>The CI/CD detailed here, using GitHub Actions, automates a lot of the busy work
that you would otherwise need to maintain your library. These workflows include:</p>
<ul>
<li>Automatic dependency updates with dependabot</li>
<li>Continuous Integration (CI)
<ul>
<li>Unit tests and code checks on pushes/PRs to <code>main</code></li>
<li>Integration tests on real &amp; emulated devices on pushes/PRs to <code>main</code></li>
</ul>
</li>
<li>Continuous Deployment (CD)
<ul>
<li>Manual version/release creation with Melos through a workflow dispatch
<ul>
<li>You can set this up to be automated, but in most cases you <em>don't</em> want a new release on every commit to main</li>
</ul>
</li>
<li>Automated publishing of new versions to GitHub releases and pub.dev</li>
</ul>
</li>
</ul>
<h2 id="dependabot-githubdependabotyaml"><a class="header" href="#dependabot-githubdependabotyaml">Dependabot (<code>/.github/dependabot.yaml</code>)</a></h2>
<p>It is highly recommended that you set up dependabot to automatically submit PRs when
your dependencies fall out of date.</p>
<p>Replace <code>library_name</code> below with your library name.</p>
<pre><code class="language-yaml">version: 2
enable-beta-ecosystems: true
updates:
  - package-ecosystem: pub
    directory: "/packages/library_name"
    schedule:
      interval: weekly
  - package-ecosystem: pub
    directory: "/packages/library_name/example"
    schedule:
      interval: weekly
  - package-ecosystem: pub
    directory: "/packages/flutter_library_name"
    schedule:
      interval: weekly
  - package-ecosystem: pub
    directory: "/packages/flutter_library_name/example"
    schedule:
      interval: weekly
  - package-ecosystem: cargo
    directory: "/packages/library_name/native"
    schedule:
      interval: weekly
</code></pre>
<h2 id="continuous-integration-githubworkflowsbuildyml"><a class="header" href="#continuous-integration-githubworkflowsbuildyml">Continuous Integration (<code>/.github/workflows/build.yml</code>)</a></h2>
<p>Replace <code>library_name</code> and <code>LibraryName</code> below with your library name.</p>
<pre><code class="language-yaml">name: Build &amp; Test

on:
  pull_request:
  push:
    branches:
      - main
  schedule:
    # runs the CI everyday at 10AM
    - cron: "0 10 * * *"

jobs:
  # General build, check, and test steps
  build_and_test:
    runs-on: ubuntu-latest

    steps:
      # Setup
      - uses: actions/checkout@v3
      - uses: subosito/flutter-action@v2
      - uses: bluefireteam/melos-action@v2
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          components: rustfmt, clippy

      # Rust
      - name: Check Rust format
        working-directory: ./packages/library_name/native/src
        run: rustfmt --check lib.rs
      - name: Rust code analysis
        run: cargo clippy -- -D warnings
      - name: Run Rust tests
        run: cargo test
      - name: Build Rust code for Dart tests
        run: cargo build -r

      # Dart/Flutter
      - name: Check Dart format
        run: melos run check-format --no-select
      - name: Dart code analysis
        run: melos run analyze --no-select
      - name: Run Dart tests
        run: melos run test

  macos_integration_test:
    runs-on: macos-latest

    steps:
      - uses: actions/checkout@v3
      - uses: subosito/flutter-action@v2
      - uses: bluefireteam/melos-action@v2
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Build the XCFramework
        run: melos run build:apple
      - name: Copy the XCFramework to the needed location
        run: |
          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`
          cp platform-build/LibraryName.xcframework.zip packages/flutter_library_name/macos/Frameworks/$CURR_VERSION.zip
          echo Copied file!

      - name: Run Flutter integration tests
        working-directory: packages/flutter_library_name/example
        run: flutter test -d macos integration_test

  windows_integration_test:
    runs-on: windows-latest

    steps:
      - uses: actions/checkout@v3
      - uses: subosito/flutter-action@v2
      - uses: bluefireteam/melos-action@v2
      - uses: goto-bus-stop/setup-zig@v2
      - uses: KyleMayes/install-llvm-action@v1
        with:
          version: "15"
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Build the binaries
        run: melos run build:other
      - name: Copy the binaries to the needed location
        shell: bash
        run: |
          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`
          cp platform-build/other.tar.gz packages/flutter_library_name/windows/$CURR_VERSION.tar.gz
          echo Copied file!

      - name: Run Flutter integration tests
        working-directory: packages/flutter_library_name/example
        run: flutter test -d windows integration_test

  linux_integration_test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      - name: Install dependencies for flutter integration test
        run: sudo apt update &amp;&amp; sudo apt-get install -y libglu1-mesa ninja-build clang cmake pkg-config libgtk-3-dev liblzma-dev
      - uses: pyvista/setup-headless-display-action@v1
      - uses: subosito/flutter-action@v2
      - uses: bluefireteam/melos-action@v2
      - uses: goto-bus-stop/setup-zig@v2
      - uses: KyleMayes/install-llvm-action@v1
        with:
          version: "15"
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Build the binaries
        run: melos run build:other
      - name: Copy the binaries to the needed location
        run: |
          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`
          cp platform-build/other.tar.gz packages/flutter_library_name/linux/$CURR_VERSION.tar.gz
          echo Copied file!

      - name: Run Flutter integration tests
        working-directory: packages/flutter_library_name/example
        run: flutter test -d linux integration_test

  ios_integration_test:
    runs-on: macos-latest

    steps:
      - uses: actions/checkout@v3
      - uses: subosito/flutter-action@v2
      - uses: bluefireteam/melos-action@v2
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Start iOS Simulator
        run: |
          DEVICE_ID=$(xcrun xctrace list devices | grep iPhone | head -1 | awk '{print $NF}' | tr -d '()')
          echo "DEVICE_ID=$DEVICE_ID" &gt;&gt; $GITHUB_ENV
          xcrun simctl boot $DEVICE_ID

      - name: Build the XCFramework
        run: melos run build:apple
      - name: Copy the XCFramework to the needed location
        run: |
          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`
          cp platform-build/LibraryName.xcframework.zip packages/flutter_library_name/ios/Frameworks/$CURR_VERSION.zip
          echo Copied file!

      - name: Run Flutter integration tests
        working-directory: packages/flutter_library_name/example
        run: flutter test -d ${{ env.DEVICE_ID }} integration_test

  android_integration_test:
    runs-on: macos-latest

    steps:
      - uses: actions/checkout@v3
      - uses: subosito/flutter-action@v2
      - uses: bluefireteam/melos-action@v2
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
      - uses: nttld/setup-ndk@v1
        with:
          ndk-version: r25b
      - uses: actions/setup-java@v3
        with:
          distribution: zulu
          java-version: "11.x"

      - name: Build the binaries
        run: melos run build:android
      - name: Copy the binaries to the needed location
        run: |
          CURR_VERSION=library_name-v`awk '/^version: /{print $2}' packages/library_name/pubspec.yaml`
          cp platform-build/android.tar.gz packages/flutter_library_name/android/$CURR_VERSION.tar.gz
          echo Copied file!

      - name: Run Flutter integration tests
        uses: Wandalen/wretry.action@master # sometimes android tests are flaky
        with:
          attempt_limit: 5
          action: reactivecircus/android-emulator-runner@v2
          with: |
            api-level: 33
            target: google_apis
            arch: x86_64
            ram-size: 1024M
            disk-size: 2048M
            script: cd packages/flutter_library_name/example &amp;&amp; flutter test -d `flutter devices | grep android | tr ' ' '\n' | grep emulator-` integration_test
</code></pre>
<h2 id="continuous-deployment"><a class="header" href="#continuous-deployment">Continuous Deployment</a></h2>
<p>There are two files you need for CD:</p>
<ol>
<li>Create new versions/releases with Melos</li>
<li>Publish new releases to GitHub releases and pub.dev</li>
</ol>
<h3 id="create-new-versions-with-melos-githubworkflowscreate-releaseyml"><a class="header" href="#create-new-versions-with-melos-githubworkflowscreate-releaseyml">Create new versions with Melos (<code>/.github/workflows/create-release.yml</code>)</a></h3>
<p>You can create new releases of your library with this workflow by going to the
"Actions" tab in your GitHub repo and manually starting this workflow with an
appropriate option. The options are:</p>
<ul>
<li><code>--</code> -&gt; call <code>melos version</code> with no additional parameters</li>
<li><code>--prerelease</code> -&gt; create a prerelease version instead of normal release (e.g., <code>1.0.0-dev.0</code>)</li>
<li><code>--graduate</code> -&gt; graduate a prerelease version to a normal release (e.g., <code>1.0.0-dev.0</code> becomes <code>1.0.0</code>)</li>
</ul>
<p>You will need to set a repository secret of <code>BOT_ACCESS_TOKEN</code> to your GitHub personal access token (PAT)
to allow for pushes to main from this Action.</p>
<p>Change <code>YourName</code> and <code>your-email@example.com</code> below as appropriate.</p>
<pre><code class="language-yaml">name: Create Release(s)

on:
  workflow_dispatch:
    inputs:
      version_parameters:
        description: 'Parameters to pass to "melos version"'
        required: true
        default: " "
        type: choice
        options:
          - "--"
          - "--prerelease"
          - "--graduate"

jobs:
  create_release:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
        with:
          token: ${{ secrets.BOT_ACCESS_TOKEN }}
          fetch-depth: 0
      - name: Setup git
        run: |
          git config user.name "YourName"
          git config user.email "your-email@example.com"
      - uses: subosito/flutter-action@v2
      - uses: bluefireteam/melos-action@v2

      - name: Create the new version(s)
        run: melos version --yes ${{ inputs.version_parameters }}

      - name: Push created version commit
        run: git push
      - name: Push modified tags
        run: git push --tags
</code></pre>
<h3 id="publish-new-releases-to-github-releases-and-pubdev-githubworkflowspublish-releaseyml"><a class="header" href="#publish-new-releases-to-github-releases-and-pubdev-githubworkflowspublish-releaseyml">Publish new releases to GitHub releases and pub.dev (<code>/.github/workflows/publish-release.yml</code>)</a></h3>
<p>In order for this workflow to execute correctly and publish packages to pub.dev,
you need to have the contents of your pub credentials JSON file in a GitHub repo secret.</p>
<p>First you need to sign-in into your pub account locally by
running the following command: <code>dart pub login</code>.</p>
<p>After the authorization is completed, open the credentials file, which can be found:</p>
<ul>
<li>On Linux, at <code>~/.config/dart/pub-credentials.json</code></li>
<li>On macOS, at <code>~/Library/Application Support/dart/pub-credentials.json</code></li>
<li>On Windows, at <code>C:\Users\YourUsername\AppData\Roaming\dart\pub-credentials.json</code></li>
</ul>
<p>And copy the contents of this <code>pub-credentials.json</code> file to a new GitHub repo secret named <code>PUB_CRED_JSON</code>.</p>
<p>This workflow is set to execute whenever new version tags are pushed up to GitHub.</p>
<pre><code class="language-yaml">name: Publish Release(s)

on:
  push:
    tags:
      - "*"

jobs:
  publish_github_release:
    # macOS because we can cross-compile to all other platforms from it
    runs-on: macos-latest

    steps:
      - uses: actions/checkout@v3
      - uses: subosito/flutter-action@v2
      - uses: bluefireteam/melos-action@v2
      - uses: goto-bus-stop/setup-zig@v2
      - uses: KyleMayes/install-llvm-action@v1
        with:
          version: "15"
      - uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
      - uses: nttld/setup-ndk@v1
        with:
          ndk-version: r25b

      - name: Build all library binaries
        run: melos run build

      - name: Create GitHub release
        uses: softprops/action-gh-release@v1
        with:
          files: platform-build/*

  publish_pub_release:
    needs: publish_github_release
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      - uses: subosito/flutter-action@v2
      - uses: bluefireteam/melos-action@v2
      - name: Setup pub.dev credentials
        run: |
          mkdir -p $HOME/.config/dart
          cat &lt;&lt; EOF &gt; $HOME/.config/dart/pub-credentials.json
          ${{ secrets.PUB_CRED_JSON }}
          EOF
      - name: Dry-run publish to pub.dev
        run: melos publish -y --dry-run
      - name: Publish to pub.dev
        run: melos publish -y --no-dry-run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<h2 id="prelude"><a class="header" href="#prelude">Prelude</a></h2>
<p>Firstly, welcome, and thanks for your contributions!</p>
<p>If you want to contribute, feel free to create a <a href="https://github.com/fzyzcjy/flutter_rust_bridge/pulls">Pull Request</a>. If you need some ideas of what to contribute, have a look at the <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues">Issues section</a> of this repository.</p>
<p>For a checklist, have a look at the <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/PULL_REQUEST_TEMPLATE.md">PR template</a>.</p>
<h2 id="overall-design"><a class="header" href="#overall-design">Overall design</a></h2>
<p>To get a high-level idea how this library is implemented, here is the overall design: <a href="contributing/design.html">link</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overall-design-1"><a class="header" href="#overall-design-1">Overall design</a></h1>
<blockquote>
<p>This doc is still WIP. Tracking issue: https://github.com/fzyzcjy/flutter_rust_bridge/issues/593</p>
</blockquote>
<h2 id="folder-structure"><a class="header" href="#folder-structure">Folder structure</a></h2>
<ul>
<li><code>frb_codegen</code>: Code generator. It inputs <code>api.rs</code> and outputs Rust and Dart code files.</li>
<li><code>frb_example</code>: Examples.
<ul>
<li><code>pure_dart</code>: Not only an example, but, more importantly, serves as end-to-end tests.</li>
<li><code>with_flutter</code>: Example with integration into Flutter.</li>
<li><code>pure_dart_multi</code>: Demonstrate multi-file usage.</li>
</ul>
</li>
<li><code>frb_dart</code>: Support library for Dart - to be imported by users.</li>
<li><code>frb_rust</code>: Support library for Rust - to be imported by users.</li>
<li><code>frb_macros</code>: Indeed part of <code>frb_rust</code>. <small>It is a separate package simply because limitation of proc macros.</small></li>
<li><code>book</code>: The documentation.</li>
<li><code>.github</code>: GitHub-related.
<ul>
<li><code>workflows/ci.yaml</code>: Definition of CI workflows.</li>
</ul>
</li>
</ul>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p><strong>Rust IO Wire</strong> types refers to the C types the Dart VM uses to communicate with the Rust library.</p>
<p><strong>Dart IO Wire</strong> types are the Dart counterpart of Rust IO wire types, but in
the <code>*.io.dart</code> files. Both Rust and Dart wire types communicate using the
vocabulary of C types, aka primitives, structs, unions and pointers.</p>
<p><strong>Rust JS Wire</strong> types are the WASM equivalent of Rust IO
wire types, many of which are distinct from their C siblings.
In addition, these types may also take the form of the catch-all <code>JsValue</code>.</p>
<p><strong>Dart JS Wire</strong> types are the WASM equivalent of Dart IO wire types, but
unlike Rust JS wire types, most of these types remain identical to their real API counterparts.
Similar to the the relationship between Rust IO and Dart IO wire types, Rust JS and Dart JS wire types
use the vocabulary of JavaScript types, aka primitives, arrays, typed arrays and objects.</p>
<h2 id="code-generator-structure"><a class="header" href="#code-generator-structure">Code-generator structure</a></h2>
<p>The pipeline is as follows:</p>
<pre class="mermaid">flowchart LR
api.rs -- src/parser --&gt; src/ir
src/ir -- src/generator --&gt; rd[Rust &amp; Dart]
</pre>
<ul>
<li>The input, <code>api.rs</code> in the figure, is the user-provided handwritten Rust code.</li>
<li>The parser (<code>src/parser</code>) converts the input code (indeed <a href="https://crates.io/crates/syn">syn</a> tree) into IR.</li>
<li>IR (<code>src/ir</code>), or internal representation, is a data structure that represents the information of the code that we are interested in.</li>
<li>The generator (<code>src/generator</code>) converts the IR into final outputs. More specifcially, as you can probably guess, <code>src/generator/dart</code> generates Dart code, <code>src/generator/rust</code> is for Rust code, and <code>src/generator/c</code> is for (a bit of) C code.</li>
<li>The outputs (<code>Rust &amp; Dart</code> in the figure) are written to corresponding files.</li>
</ul>
<h2 id="data-flow"><a class="header" href="#data-flow">Data flow</a></h2>
<p>Let us see what happens when a function is called.</p>
<p>Suppose a user calls a (generated) Dart function <code>func({required String str})</code>. Then, the following happens:</p>
<ol>
<li>The generated Dart function, <code>func({required String str})</code>, convert "<em>Dart api data</em>" (i.e. the data that user really provides) into "<em>Dart wire data</em>" (i.e. the data that will really pass between Dart and Rust). More specifically, it calls <code>_api2wire_String(str)</code> and get a <code>ffi.Pointer&lt;wire_uint_8_list&gt;</code> (because <code>String</code>s use <code>pub struct wire_uint_8_list { ptr: *mut u8, len: i32 }</code> under the hood).</li>
<li>Now we call the Dart version of <code>wire_func</code>, with low-level data like <code>wire_uint_8_list</code>. We have used our codegen to create a Rust <code>wire_func</code> function, and use <code>cbindgen</code> to generate the corresponding C function, and use <code>ffigen</code> to get the corresponding Dart function. Here, we call the Dart version of <code>wire_func</code>. Since Dart FFI and Rust FFI is C-compatible, it seamlessly calls the Rust version of <code>wire_func</code>. Notice that, since we are utilizing C-compatible functions (and it is the only feasible way), we can only pass around low-level things like pointers, instead of high-level and safe things.</li>
<li>Surely, the Rust <code>wire_func</code> is called. The function uses <code>.wire2api()</code> to convert "<em>Rust wire data</em>" (<code>wire_uint_8_list</code> here) into "<em>Rust api data</em>" (<code>String</code> here, i.e. data that users really use).</li>
<li>The <code>FLUTTER_RUST_BRIDGE_HANDLER</code> is called with "<em>Rust api data</em>". That handler is user-customizable, so users may provide their own implementation other than the default thread-pool, etc. By default, we use a thread pool, and we call the user-written <code>func</code> Rust function in <code>api.rs</code>.</li>
<li>The user-written <code>fn func(str: String) -&gt; String { ... }</code> is called, and we get a return value.</li>
<li>The return value, a <code>String</code>, is posted to the Dart side. It is done by the Dart-provided API, <a href="https://github.com/dart-lang/sdk/blob/fd0d3b254690007d0ebc84175f30fa7d7491ec3e/runtime/include/dart_native_api.h#L124"><code>Dart_PostCObject</code></a>, which let us provide C structs and it will automatically become Dart data on the other side. We use the Rust-safe wrapper <code>allo-isolate</code> for it. We deliberately choose this, because this enables Dart code to be <em>async</em> instead of sync.</li>
<li>On the Dart side, we now see some Dart objects (indeed "<em>Dart wire data</em>"). We use functions like <code>_wire2api_SomeType</code> to convert it to the final "<em>Dart api data</em>". Notice this "wire2api" is on <em>Dart</em> side, so it means "<em>Dart</em> wire data to <em>Dart</em> api data", and is different from the one above which is for Rust. For example, since <code>Dart_PostCObject</code> does not provide a way to construct arbitrary structs(classes), we have to pass Rust structs as lists, and use the <code>wire2api</code> to convert them to corresponding Dart classes.</li>
<li>The final result value is provided as return value of the Dart function, <code>func</code>, that the user called just now. A function call finishes!</li>
</ol>
<h2 id="type-mappings"><a class="header" href="#type-mappings">Type Mappings</a></h2>
<p>Unless otherwise noted, <code>T</code> refers to a type from the same column or the generic type.
Does not include delegated types.</p>
<div class="table-wrapper"><table><thead><tr><th>Rust</th><th>Rust IO Wire</th><th>Dart IO Wire</th><th>Rust JS Wire</th><th>Dart JS Wire</th><th>Dart</th></tr></thead><tbody>
<tr><td><code>i{8..32}</code></td><td><code>i{8..32}</code></td><td><code>int</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td><code>i{8..32}</code></td><td><code>int</code></td><td><code>int</code></td></tr>
<tr><td><code>u{8..32}</code></td><td><code>u{8..32}</code></td><td><code>int</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td><code>u{8..32}</code></td><td><code>int</code></td><td><code>int</code></td></tr>
<tr><td><code>i64</code></td><td><code>i64</code></td><td><code>int</code></td><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a></td><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a></td><td><code>int</code></td></tr>
<tr><td><code>u64</code></td><td><code>u64</code></td><td><code>int</code></td><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a></td><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a></td><td><code>int</code></td></tr>
<tr><td><code>usize</code></td><td><code>usize</code></td><td><code>int</code></td><td><code>usize</code></td><td><code>int</code></td><td><code>int</code></td></tr>
<tr><td><code>bool</code></td><td><code>bool</code></td><td><code>bool</code></td><td><code>bool</code></td><td><code>bool</code></td><td><code>bool</code></td></tr>
<tr><td><code>Vec&lt;i{8..32}&gt;</code></td><td><code>wire_int_{8..32}_list</code></td><td><code>wire_int_{8..32}_list</code></td><td><code>Box&lt;[i{8..32}]&gt;</code></td><td><code>Int{8..32}Array</code></td><td><code>Int{8..32}List</code></td></tr>
<tr><td><code>Vec&lt;u{8..32}&gt;</code></td><td><code>wire_uint_{8..32}_list</code></td><td><code>wire_uint_{8..32}_list</code></td><td><code>Box&lt;[u{8..32}]&gt;</code></td><td><code>Uint{8..32}Array</code></td><td><code>Uint{8..32}List</code></td></tr>
<tr><td><code>Vec&lt;i64&gt;</code></td><td><code>wire_int_64_list</code></td><td><code>wire_int_64_list</code></td><td><code>Box&lt;[i64]&gt;</code></td><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt64Array"><code>BigInt64Array</code></a></td><td><code>Int64List</code><sup class="footnote-reference"><a href="#2">2</a></sup></td></tr>
<tr><td><code>Vec&lt;u64&gt;</code></td><td><code>wire_uint_64_list</code></td><td><code>wire_uint_64_list</code></td><td><code>Box&lt;[u64]&gt;</code></td><td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigUint64Array"><code>BigUint64Array</code></a></td><td><code>Uint64List</code><sup class="footnote-reference"><a href="#2">2</a></sup></td></tr>
<tr><td><code>String</code></td><td><code>wire_uint_8_list</code></td><td><code>wire_uint_8_list</code></td><td><code>String</code></td><td><code>String</code></td><td><code>String</code></td></tr>
<tr><td><code>Vec&lt;String&gt;</code></td><td><code>wire_StringList</code></td><td><code>wire_StringList</code></td><td><code>Box&lt;[String]&gt;</code></td><td><code>List</code></td><td><code>List&lt;String&gt;</code></td></tr>
<tr><td><code>Vec&lt;T&gt;</code></td><td><code>wire_list_t</code></td><td><code>wire_list_t</code></td><td><code>Box&lt;[JsValue]&gt;</code></td><td><code>List</code></td><td><code>List&lt;T&gt;</code></td></tr>
<tr><td><code>Box&lt;T&gt;</code></td><td><code>*mut T</code></td><td><code>ffi.Pointer&lt;T&gt;</code></td><td><code>T</code></td><td><code>T</code></td><td><code>T</code></td></tr>
<tr><td><code>Option&lt;T&gt;</code></td><td><code>*mut T</code></td><td><code>ffi.Pointer&lt;T&gt;</code></td><td><code>Option&lt;T&gt;</code></td><td><code>T?</code></td><td><code>T?</code></td></tr>
<tr><td><code>Option&lt;Box&lt;T&gt;&gt;</code></td><td><code>*mut T</code></td><td><code>ffi.Pointer&lt;T&gt;</code></td><td><code>Option&lt;T&gt;</code></td><td><code>T?</code></td><td><code>T?</code></td></tr>
<tr><td>enum/struct <code>T</code></td><td><code>*mut wire_t</code></td><td><code>ffi.Pointer&lt;T&gt;</code></td><td><code>Array</code></td><td><code>List</code></td><td>class <code>T</code></td></tr>
<tr><td>enum <code>T</code><sup class="footnote-reference"><a href="#3">3</a></sup></td><td><code>i32</code><sup class="footnote-reference"><a href="#5">4</a></sup></td><td><code>int</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td><code>i32</code><sup class="footnote-reference"><a href="#5">4</a></sup></td><td><code>int</code></td><td>enum <code>T</code></td></tr>
<tr><td><a href="https://docs.rs/flutter_rust_bridge/latest/flutter_rust_bridge/ffi/type.DartAbi.html"><code>DartAbi</code></a></td><td><a href="https://docs.rs/flutter_rust_bridge/latest/flutter_rust_bridge/ffi/io/ffi/struct.DartCObject.html"><code>DartCObject</code></a></td><td><code>dynamic</code></td><td><a href="https://rustwasm.github.io/wasm-bindgen/reference/types/jsvalue.html"><code>JsValue</code></a></td><td><code>dynamic</code></td><td><code>dynamic</code></td></tr>
</tbody></table>
</div>
<h2 id="memory-safety"><a class="header" href="#memory-safety">Memory safety</a></h2>
<p>How is memory safety implemented? This is a case-by-case problem. For example, suppose we want to see how a <code>String</code> is safely passed from Dart to Rust. Then, we need to examine the Dart <code>_api2wire_String</code> and the Rust <code>.wire2api()</code> for it.</p>
<p>Indeed <code>String</code> is implemented by delegating to <code>Vec&lt;u8&gt;</code>, so we need to see code related to String as well as <code>Vec&lt;u8&gt;</code>. By simply clicking a few times and jump around code, we will see that:</p>
<pre><code class="language-dart">ffi.Pointer&lt;wire_uint_8_list&gt; _api2wire_String(String raw) {
  return _api2wire_uint_8_list(utf8.encoder.convert(raw));
}

ffi.Pointer&lt;wire_uint_8_list&gt; _api2wire_uint_8_list(Uint8List raw) {
  final ans = inner.new_uint_8_list_0(raw.length);
  ans.ref.ptr.asTypedList(raw.length).setAll(0, raw);
  return ans;
}
</code></pre>
<p>and</p>
<pre><code class="language-rust noplayground">impl Wire2Api&lt;Vec&lt;u8&gt;&gt; for *mut wire_uint_8_list {
    fn wire2api(self) -&gt; Vec&lt;u8&gt; {
        unsafe {
            let wrap = support::box_from_leak_ptr(self);
            support::vec_from_leak_ptr(wrap.ptr, wrap.len)
        }
    }
}

impl Wire2Api&lt;String&gt; for *mut wire_uint_8_list {
    fn wire2api(self) -&gt; String {
        let vec: Vec&lt;u8&gt; = self.wire2api();
        String::from_utf8_lossy(&amp;vec).into_owned()
    }
}

pub struct wire_uint_8_list {
    ptr: *mut u8,
    len: i32,
}</code></pre>
<p>In other words, String (or <code>Vec&lt;u8&gt;</code>) is converted to a raw struct with pointer and length field. The memory is manipulated carefully so there is no leak or double free.</p>
<p>We use Valgrind to check as well, and I use it in production environment without problems, so no worries about memory problems :)</p>
<h2 id="dart-bridge-hierarchy"><a class="header" href="#dart-bridge-hierarchy">Dart bridge hierarchy</a></h2>
<p>A bridge module consists of several classes:</p>
<ul>
<li>One <code>_Impl</code> class implementing the wire functions and common helpers; and</li>
<li>One or more <code>_Platform</code> classes implementing the platform-specific helpers.</li>
</ul>
<p>The implementor class takes a platform class as a private attribute, and the platform
class exposes all of its members decorated with <code>@protected</code>. The specific platform class
to be used is gated by conditional imports.</p>
<h2 id="cross-scope-communication-in-the-browser"><a class="header" href="#cross-scope-communication-in-the-browser">Cross-scope communication in the browser</a></h2>
<p>On Web platforms, for lack of a proper <code>SendPort</code> there exists replacements from <code>dart:html</code>.</p>
<p><strong>MessagePort</strong> replaces <code>dart:ffi</code>'s <code>SendPort</code> and is created from <code>MessageChannel</code>. The Dart
thread creates a channel, keeps the receive port and transfers the send port to the workers.</p>
<pre class="mermaid">sequenceDiagram
Dart -&gt;&gt; Rust: port2
Rust -&gt;&gt; Rust Worker: port2
Rust Worker -&gt;&gt; Dart: port2.postMessage
</pre>
<p><strong>BroadcastChannel</strong> replaces <code>dart:ffi</code>'s <code>SendPort</code> for <code>StreamSink</code>s, due to the fact that wasm_bindgen
keeps the ports in a JS-local scope that cannot be shared with other threads. A broadcast channel
is created by Dart, then passed to the main Rust thread. Rust then transfers its name to the workers.
When other workers refer to a <code>StreamSink</code> from another worker, e.g. if the sink was put in a static variable,
a new <code>BroadcastChannel</code> will be created from its name.</p>
<p><code>BroadcastChannel</code>s are guaranteed to be unique for each invocation.<sup class="footnote-reference"><a href="#4">5</a></sup></p>
<pre class="mermaid">sequenceDiagram
Dart -&gt;&gt; Rust: channel
Rust -&gt;&gt; Rust Worker 1: channel.name
Rust Worker 1 -&gt;&gt; Dart: channel.postMessage
Rust -&gt;&gt; Rust Worker 2: channel.name
Rust Worker 2 -&gt;&gt; Dart: channel.postMessage
</pre>
<p>It is theoretically possible to have a one-to-one implementation of Isolate using only web primitives,
<code>BroadcastChannel</code>s and <code>Worker</code>s, but it remains to be seen how practical such an approach would be.</p>
<h2 id="optionallist"><a class="header" href="#optionallist">OptionalList</a></h2>
<p>Per the implementation, most IRs are also accompanied by a List type (GeneralList, PrimitiveList, StringList etc.)
each of which handles lists in different ways. When Optional was first implemented, it relied on GeneralList since the
underlying assumption that Optional already boxed stack values should allow for seamless interaction. Howver, this became an issue
later because other IRs would have to accommodate for Optionals instead of being perfectly encapsulated, leading to
ugly hacks. <a href="https://github.com/fzyzcjy/flutter_rust_bridge/pull/1388">#1388</a> introduced OptionalList to bring
Optional in line with other IRs, and is implemented as a list of maybe-null pointers. It does highlight several drawbacks
to this approach to IRs where specializations shine compared to GeneralList.</p>
<ol>
<li>GeneralList requires a fully-allocated list and asks the Dart side to <em>fill</em> in the blanks via <code>api_fill</code> functions, but these
are not implemented by any delegates since they all have their own special lists (StringList, TimeList, Uuids). This renders
types like <code>List&lt;String?&gt;</code> difficult to implement without hacks.</li>
<li>OptionalList's inner pointer is a <code>*mut *mut T</code>, which without significant refactoring would be difficult to represent with
GeneralList, and whose typical usage doesn't really require double indirection often enough to justify it.</li>
<li>OptionalList enables future optimizations, for example the case when <code>sizeof(T) &lt;= sizeof(usize)</code>, which would certainly be difficult
to accomplish with GeneralList.</li>
</ol>
<h2 id="want-to-know-more-tell-me"><a class="header" href="#want-to-know-more-tell-me">Want to know more? Tell me</a></h2>
<p>What do you want to know? Feel free to create an issue in GitHub, and I will tell more :)</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>When behind a <code>ffi.Pointer</code>, they are their respective types from <code>dart:ffi</code>: <code>ffi.Int8</code>, <code>ffi.Int16</code>, etc.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>These types are unsupported on Web by <code>dart:typed_list</code>, so this library provides a barebores shim over the JS native types.
If you wish to use these types, replace all <code>dart:typed_list</code> imports with this library.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Refers to C-style enums only (no fields).</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">5</sup>
<p>This is currently implemented as a monotonically-increasing index.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">4</sup>
<p>Enums may also specify a <code>#[repr]</code>, which is planned to be implemented.</p>
</div>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
let mdbookTheme = localStorage.getItem("mdbook-theme") || default_theme;
mermaid.initialize({
    startOnLoad: true,
    theme: mdbookTheme == 'light' || mdbookTheme == 'rust' ? 'light' : 'dark',
});
</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="submodule-implementations"><a class="header" href="#submodule-implementations">Submodule implementations</a></h1>
<p>In this chapter, we will present implementations and discussions for various submodules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-opaque-type-safety"><a class="header" href="#rust-opaque-type-safety">Rust opaque type safety</a></h1>
<h2 id="restrictions"><a class="header" href="#restrictions">Restrictions</a></h2>
<p>A <code>RustOpaque type</code> can be created from any Rust structure.
The <code>flutter_rust_bridge</code> async dart api requires the Rust type to be <code>Send</code> and <code>Sync</code>, due to the possible sharing of <code>RustOpaque type</code> by multiple <code>flutter_rust_bridge</code> executor threads.</p>
<h2 id="ownership-and-gc"><a class="header" href="#ownership-and-gc">Ownership and GC</a></h2>
<p>From the moment an opaque type is passed to Dart, it has full ownership of it.
Dart implements a finalizer for opaque types, but the memory usage of opaque types is not monitored by Dart and can accumulate, so in order to prevent memory leaks, opaque pointers must be <code>dispose</code>d.</p>
<h2 id="rust-opaque-type-like-function-args"><a class="header" href="#rust-opaque-type-like-function-args">Rust opaque type like function args</a></h2>
<p>When calling a function with an opaque type argument, the Dart thread safely shares ownership of the opaque type with Rust. This is safe because <code>RustOpaque&lt;T&gt;</code> requires that T be <code>Send</code> and <code>Sync</code>, furthermore Rust's <code>RustOpaque&lt;T&gt;</code> hand out immutable references through <code>Deref</code> or get an internal property if only Rust owns the opaque type. If dispose is called on the Dart side before the function call completes, Rust takes full ownership.</p>
<h2 id="example-12"><a class="header" href="#example-12">Example</a></h2>
<h3 id="case-1-simple-call"><a class="header" href="#case-1-simple-call">Case 1: Simple call.</a></h3>
<p>Rust <code>api.rs</code>:</p>
<pre><code class="language-rust noplayground">pub use crate::data::HideData; // `pub` for bridge_generated.rs

pub fn create_opaque() -&gt; RustOpaque&lt;HideData&gt; {
    // [`HideData`] has private fields.
    RustOpaque::new(HideData::new())
}

pub fn run_opaque(opaque: RustOpaque&lt;HideData&gt;) -&gt; String {
    // RustOpaque impl Deref trait.
    opaque.hide_data()
}</code></pre>
<p>Dart: (test:'Simple call' frb_example/pure_dart/dart/lib/main.dart)</p>
<pre><code class="language-dart">// (Arc counter = 1) Dart has full ownership.
var opaque = await api.createOpaque();

// (Arc counter = 2) for the duration of the function 
// and after (Arc counter = 1).
// 
// Dart and Rust share the opaque type.
String hideData = await api.runOpaque(opaque);

// (Arc counter = 0) opaque type is dropped (deallocated).
opaque.dispose();
</code></pre>
<h3 id="case-2-call-after-dispose"><a class="header" href="#case-2-call-after-dispose">Case 2: Call after dispose.</a></h3>
<p>Rust <code>api.rs</code>:</p>
<pre><code class="language-rust noplayground">pub use crate::data::HideData; // `pub` for bridge_generated.rs

pub fn create_opaque() -&gt; RustOpaque&lt;HideData&gt; {
    // [`HideData`] has private fields.
    RustOpaque::new(HideData::new())
}

pub fn run_opaque(opaque: RustOpaque&lt;HideData&gt;) -&gt; String {
    // RustOpaque impl Deref trait.
    opaque.hide_data()
}</code></pre>
<p>Dart: (test:'Call after dispose' frb_example/pure_dart/dart/lib/main.dart)</p>
<pre><code class="language-dart">// (Arc counter = 1) Dart has full ownership.
var opaque = await api.createOpaque();

// (Arc counter = 0) opaque type dropped (deallocated)
opaque.dispose();

// (Arc counter = 0) Dart throws StateError('Use after dispose.')
try {
    await api.runOpaque(opaque: opaque);
} on StateError catch (e) {
    expect(e.toString(), 'Bad state: Use after dispose.');
}
</code></pre>
<h3 id="case-3-dispose-before-complete"><a class="header" href="#case-3-dispose-before-complete">Case 3: Dispose before complete.</a></h3>
<p>Rust <code>api.rs</code>:</p>
<pre><code class="language-rust noplayground">pub use crate::data::HideData; // `pub` for bridge_generated.rs

pub fn create_opaque() -&gt; RustOpaque&lt;HideData&gt; {
    // [`HideData`] has private fields.
    RustOpaque::new(HideData::new())
}

pub fn run_opaque(opaque: RustOpaque&lt;HideData&gt;) -&gt; String {
    // RustOpaque impl Deref trait.
    opaque.hide_data()
}

pub fn run_opaque_with_delay(opaque: RustOpaque&lt;HideData&gt;) -&gt; String {
    sleep(Duration::from_millis(1000));
    opaque.hide_data()
}</code></pre>
<p>Dart:</p>
<pre><code class="language-dart">// (Arc counter = 1) Dart has full ownership.
var opaque = await api.createOpaque();

// (Arc counter = 2) increases immediately. 
// Dart and Rust share the opaque type.
// Safely because opaque type has `Send` `Sync` Rust trait.
var unawait_task = api.runOpaqueWithDelay(opaque: opaque);

// (Arc counter = 1) Rust has full ownership.
// Dart stops owning the opaque type. 
// Trying to use an opaque type will throw StateError('Use after dispose.')
opaque.dispose();

// Successfully completed.
//
// Rust:
// `executes run_opaque_with_delay.`
// after complete (Arc counter = 0) 
// opaque type is dropped (deallocated)
await unawait_task;
</code></pre>
<h3 id="case-4-multi-call"><a class="header" href="#case-4-multi-call">Case 4: Multi call.</a></h3>
<p>Rust <code>api.rs</code>:</p>
<pre><code class="language-rust noplayground">pub use crate::data::HideData; // `pub` for bridge_generated.rs

pub fn create_opaque() -&gt; RustOpaque&lt;HideData&gt; {
    // [`HideData`] has private fields.
    RustOpaque::new(HideData::new())
}

pub fn run_opaque(opaque: RustOpaque&lt;HideData&gt;) -&gt; String {
    // RustOpaque impl Deref trait.
    opaque.hide_data()
}</code></pre>
<p>Dart: (test:'Double Call' frb_example/pure_dart/dart/lib/main.dart)</p>
<pre><code class="language-dart">
// (Arc counter = 1) Dart has full ownership.
var opaque = await api.createOpaque();

// (Arc counter = 2) increases immediately.
// (Arc counter = 1) after complete
String hideData1 = await api.runOpaque(opaque: opaque);

// (Arc counter = 2) increases immediately.
// (Arc counter = 1) after complete
String hideData2 = await api.runOpaque(opaque: opaque);

// (Arc counter = 0) opaque type is dropped (deallocated)
opaque.dispose();
</code></pre>
<h3 id="case-5-double-call-with-dispose-before-complete"><a class="header" href="#case-5-double-call-with-dispose-before-complete">Case 5: Double call with dispose before complete.</a></h3>
<p>Rust <code>api.rs</code>:</p>
<pre><code class="language-rust noplayground">pub use crate::data::HideData; // `pub` for bridge_generated.rs

pub fn create_opaque() -&gt; RustOpaque&lt;HideData&gt; {
    // [`HideData`] has private fields.
    RustOpaque::new(HideData::new())
}

pub fn run_opaque(opaque: RustOpaque&lt;HideData&gt;) -&gt; String {
    // RustOpaque impl Deref trait.
    opaque.hide_data()
}</code></pre>
<p>Dart:</p>
<pre><code class="language-dart">
// (Arc counter = 1) Dart has full ownership.
var opaque = await api.createOpaque();

// (Arc counter = 2) increases immediately. 
var unawait_task1 = api.runOpaque(opaque); *1

// (Arc counter = 3) increases immediately. 
var unawait_task2 = api.runOpaque(opaque); *2

// (Arc counter = 2) Rust has full ownership
opaque.dispose();

// (*1 is complete) (Arc counter = 1)
//
// Rust:
//
//`executes rust_call_example and counter decreases.`

// (*2 is complete) (Arc counter = 0) 
// opaque type is dropped (deallocated)
//
// Rust:
//
//`executes rust_call_example and drop opaque type.`
</code></pre>
<h3 id="case-6-dispose-was-not-called-native"><a class="header" href="#case-6-dispose-was-not-called-native">Case 6: Dispose was not called (native).</a></h3>
<p>Rust <code>api.rs</code>:</p>
<pre><code class="language-rust noplayground">pub use crate::data::HideData; // `pub` for bridge_generated.rs

pub fn create_opaque() -&gt; RustOpaque&lt;HideData&gt; {
    // [`HideData`] has private fields.
    RustOpaque::new(HideData::new())
}

pub fn run_opaque(opaque: RustOpaque&lt;HideData&gt;) -&gt; String {
    // RustOpaque impl Deref trait.
    opaque.hide_data()
}</code></pre>
<p>Dart:</p>
<pre><code class="language-dart">
// (Arc counter = 1) Dart has full ownership.
var opaque = await api.createOpaque();

// (Arc counter = 2) increases immediately. 
String hideData = await api.runOpaque(opaque);

// (Arc counter = 1)
//
// Rust:
//
// `executes rust_call_example and counter decreases.`

// memory of opaque types is not monitoring by dart and can accumulate.
// (Arc counter = 0) 
// opaque type is dropped (deallocated)
// 
// Dart:
//
// `the finalizer is guaranteed to be called before the program terminates.`
</code></pre>
<h3 id="case-7-dispose-was-not-called-web"><a class="header" href="#case-7-dispose-was-not-called-web">Case 7: Dispose was not called (web).</a></h3>
<p>Rust <code>api.rs</code>:</p>
<pre><code class="language-rust noplayground">pub use crate::data::HideData; // `pub` for bridge_generated.rs

pub fn create_opaque() -&gt; RustOpaque&lt;HideData&gt; {
    // [`HideData`] has private fields.
    RustOpaque::new(HideData::new())
}

pub fn run_opaque(opaque: RustOpaque&lt;HideData&gt;) -&gt; String {
    // RustOpaque impl Deref trait.
    opaque.hide_data()
}</code></pre>
<p>Dart:</p>
<pre><code class="language-dart">
// (Arc counter = 1) Dart has full ownership.
var opaque = await api.createOpaque(); 

// (Arc counter = 2) increases immediately. 
String hideData = await api.rustOpaque(opaque);

// (Arc counter = 1)
//
// Rust:
//
//`executes rust_call_example and counter decreases.`

// memory of opaque types is not monitoring by Dart and can accumulate.
// (Arc count can be 0 or 1) don't count on automatic clearing.
//
// Dart:
//
//`the finalizer is NOT guaranteed to be called before the program terminates.`
</code></pre>
<h3 id="case-8-unwrap"><a class="header" href="#case-8-unwrap">Case 8: Unwrap.</a></h3>
<p>Rust <code>api.rs</code>:</p>
<pre><code class="language-rust noplayground">pub use crate::data::HideData; // `pub` for bridge_generated.rs

pub fn unwrap_rust_opaque(opaque: Opaque&lt;HideData&gt;) -&gt; Result&lt;String&gt; {
    let res: Result&lt;HideData, Opaque&lt;HideData&gt;&gt; = opaque.try_unwrap();
    let data: HideData = res.map_err(|_| anyhow::anyhow!("opaque type is shared"))?;
    Ok(data.hide_data())
}
</code></pre>
<p>Dart:</p>
<pre><code class="language-dart">
// (Arc counter = 1) Dart has full ownership.
var opaque = await api.createOpaque();

// When passed as an argument, dart will relinquish ownership.
opaque.move = true;

// (Arc counter = 1) Rust has full ownership.
// On the Rust side, the Arc unwrap safely 
// as the Rust has full ownership of the opaque type. 
// Memory is cleared in the usual way Rust.
await api.unwrapRustOpaque(opaque: data);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dart-opaque-type-safety"><a class="header" href="#dart-opaque-type-safety">Dart opaque type safety</a></h1>
<h2 id="ownership-and-gc-1"><a class="header" href="#ownership-and-gc-1">Ownership and GC</a></h2>
<p>From the moment the opaque type is passed, Rust will own a persistent representation of the dart object (<code>Dart_PersistentHandle</code> or <code>JsValue</code>).
This means that while Rust owns <code>DartOpaque</code> the object will not be cleared by GC.
Also flutter_rust_bridge provides a thread-safe drop for <code>DartOpaque</code>: Rust delegates the drop to the Dart side using the Dart port.</p>
<h2 id="dispose-flutter_rust_bridge-api-before-all-dartopaques-are-cleaned"><a class="header" href="#dispose-flutter_rust_bridge-api-before-all-dartopaques-are-cleaned">Dispose flutter_rust_bridge Api before all <code>DartOpaques</code> are cleaned.</a></h2>
<p>If there is an attempt to delegate the drop to the Dart side after the drop port (Api.dispose()) has been closed. flutter_rust_bridge will issue a warning in the logs, the memory behind the object will leak.</p>
<h2 id="example-13"><a class="header" href="#example-13">Example</a></h2>
<h3 id="case-1-loopback"><a class="header" href="#case-1-loopback">Case 1: loopBack.</a></h3>
<p>Rust <code>api.rs</code>:</p>
<pre><code class="language-rust noplayground">pub fn loop_back(opaque: DartOpaque) -&gt; DartOpaque {
    opaque
}</code></pre>
<p>Dart:</p>
<pre><code class="language-dart">
String f() =&gt; 'Test_String';

var fn = await api.loopBack(opaque: f) as String Function();

expect(fn(), 'Test_String');
</code></pre>
<h3 id="case-2-drop"><a class="header" href="#case-2-drop">Case 2: drop.</a></h3>
<p>Rust <code>api.rs</code>:</p>
<pre><code class="language-rust noplayground">pub fn sync_accept_dart_opaque(opaque: DartOpaque) -&gt; SyncReturn&lt;String&gt; {
    drop(opaque);
    SyncReturn("test".to_owned())
}

pub fn async_accept_dart_opaque(opaque: DartOpaque) {
    drop(opaque);
}</code></pre>
<p>Dart:</p>
<pre><code class="language-dart">// the closure is safely removed on the Rust side (on another thread)
await api.asyncAcceptDartOpaque(opaque: () =&gt; 'Test_String');
// the closure is safely removed on the Rust side (on current thread)
api.syncAcceptDartOpaque(opaque: () =&gt; 'Test_String');
</code></pre>
<h3 id="case-3-unwrap"><a class="header" href="#case-3-unwrap">Case 3: Unwrap.</a></h3>
<p>Rust <code>api.rs</code>:</p>
<pre><code class="language-rust noplayground">/// [DartWrapObject] can be safely retrieved on a dart thread.
pub fn unwrap_dart_opaque(opaque: DartOpaque) -&gt; SyncReturn&lt;String&gt; {
    let handle = opaque.try_unwrap().unwrap();
    SyncReturn("Test".to_owned())
}

/// [DartWrapObject] cannot be obtained 
/// on a thread other than the thread it was created on.
pub fn panic_unwrap_dart_opaque(opaque: DartOpaque) {
    let handle = opaque.try_unwrap().unwrap();
}</code></pre>
<p>Dart:</p>
<pre><code class="language-dart">
// Rust gets (drop safely) wrap Dart_PersistentHandler (or JsValue).
api.unwrapDartOpaque(opaque: () =&gt; 'Test_String');

// We get an error because DartOpaque was passed to another thread.
await expectLater(() =&gt; api.panicUnwrapDartOpaque(opaque: () =&gt; 'Test_String'), throwsA(isA&lt;FfiException&gt;()));
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<blockquote>
<p>Remark: Some docs here seem to be outdated. Refer to ci.yaml, main doc, justfile, etc to see an up-to-date version. This appendix will be overhauled.</p>
</blockquote>
<h2 id="releasing-a-new-version"><a class="header" href="#releasing-a-new-version">Releasing a new version</a></h2>
<p>Usually this is done by the owner (@fzyzcjy), so you do not need to do the following. If you need to release a new version, the following steps are needed. Bump several versions, change the version number in changelog, and use <code>cargo check</code> to automatically update the examples' dependency versions:</p>
<pre><code>just release
</code></pre>
<h2 id="sample-commands-to-run-code-generator"><a class="header" href="#sample-commands-to-run-code-generator">Sample commands to run code generator</a></h2>
<p>Just copied from <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/workflows/codegen.yml">CI codegen.yml</a>.</p>
<pre><code>(cd frb_codegen &amp;&amp; cargo run --package flutter_rust_bridge_codegen --bin flutter_rust_bridge_codegen -- --rust-input ../frb_example/pure_dart/rust/src/api.rs --dart-output ../frb_example/pure_dart/dart/lib/bridge_generated.dart --dart-format-line-length 120 &amp;&amp; cargo run --package flutter_rust_bridge_codegen --bin flutter_rust_bridge_codegen -- --rust-input ../frb_example/with_flutter/rust/src/api.rs --dart-output ../frb_example/with_flutter/lib/bridge_generated.dart --c-output ../frb_example/with_flutter/ios/Runner/bridge_generated.h --dart-format-line-length 120)
</code></pre>
<h2 id="format-and-lint-everything"><a class="header" href="#format-and-lint-everything">Format and lint everything</a></h2>
<pre><code>(cd frb_codegen &amp;&amp; cargo fmt --all); (cd frb_rust &amp;&amp; cargo fmt --all); (cd frb_macros &amp;&amp; cargo fmt --all); (cd frb_example/pure_dart/rust &amp;&amp; cargo fmt --all); (cd frb_example/with_flutter/rust &amp;&amp; cargo fmt --all);
(cd frb_codegen &amp;&amp; cargo clippy); (cd frb_rust &amp;&amp; cargo clippy); (cd frb_macros &amp;&amp; cargo clippy); (cd frb_example/pure_dart/rust &amp;&amp; cargo clippy); (cd frb_example/with_flutter/rust &amp;&amp; cargo clippy);                                                                                                                                          
(cd frb_dart &amp;&amp; dart format . --line-length 80); (cd frb_example/pure_dart/dart &amp;&amp; dart format . --line-length 120); (cd frb_example/with_flutter &amp;&amp; dart format . --line-length 120);
(cd frb_dart &amp;&amp; dart analyze --fatal-infos); (cd frb_example/pure_dart/dart &amp;&amp; dart analyze --fatal-infos); (cd frb_example/with_flutter &amp;&amp; dart analyze --fatal-infos);
</code></pre>
<h2 id="upgrade-dependency-in-your-dependent-project"><a class="header" href="#upgrade-dependency-in-your-dependent-project">Upgrade dependency in your dependent project</a></h2>
<pre><code>flutter pub upgrade flutter_rust_bridge
cargo update -p flutter_rust_bridge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-tests-in-dart"><a class="header" href="#unit-tests-in-dart">Unit tests in dart</a></h1>
<p>To run <code>flutter</code> or <code>dart test</code> with the bridge you need to load the library on your own development machine (Windows/MacOS/Linux/CI). For that use <code>loadLibForFlutter</code> or <code>loadLibForDart</code>, for example:</p>
<pre><code class="language-dart">BridgeImpl initializeExternalLibrary(String path) =&gt; BridgeImpl(loadLibForDart(path));
</code></pre>
<p>Note however, that you need to build the library for your IDE's Operating System. <code>cargo build</code> should normally handle that.</p>
<p><strong>Do not change the target to your OS only</strong>, as otherwise you will not be able to build for your target platform anymore.</p>
<h2 id="example-setup-verified-on-macos"><a class="header" href="#example-setup-verified-on-macos">Example setup (verified on MacOS)</a></h2>
<pre><code>project
|- lib
|- test
|-- ffi.test.dart
|-- bridge_test.dart
|- rust
|-- src
|--- api.rs
|-- target
</code></pre>
<p>Where <code>ffi.test.dart</code> has the following content:</p>
<pre><code class="language-dart">import 'package:basis_hybrid/bridge_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';

BridgeImpl initializeExternalLibrary(String path) {
  return BridgeImpl(
    loadLibForFlutter(path)
  );
}
</code></pre>
<p>and then <code>bridge_test.dart</code> has the following content:</p>
<pre><code class="language-dart">import 'package:basis_hybrid/bridge_definitions.dart';
import 'package:flutter_test/flutter_test.dart';

import 'ffi.test.dart';

Future&lt;void&gt; main() async {
  final api = initializeExternalLibrary('rust/target/debug/librustbridge.dylib');
  await api.init(sqlPath: 'test.db', kvPath: 'test.kv');

  test('User save/load', () async {
     await api.saveUser();
     var user = await api.readUser();
     expect(user, isNotNull);
   });
}
</code></pre>
<p>Ensure that you have your IDE's system target installed (<code>rustup</code>) according to <a href="https://cjycode.com/flutter_rust_bridge/template/setup.html">Creating a new project</a>, after running <code>cargo build</code>  you should've a library in <code>rust/target/debug/</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial-pure-dart"><a class="header" href="#tutorial-pure-dart">Tutorial: Pure Dart</a></h1>
<p><strong>Remark</strong>: The <code>valgrind_test</code> section of the <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/workflows/test.yaml">CI workflow</a> can also be useful, if you want details of each command and want to see Valgrind configuration.</p>
<p>Unlike the previous tutorial, this one integrates Rust with pure Dart instead of Flutter.</p>
<h2 id="get-example-code"><a class="header" href="#get-example-code">Get example code</a></h2>
<p>Please <a href="https://dart.dev/get-dart">install Dart</a>, <a href="https://www.rust-lang.org/learn/get-started">install Rust</a>, and have some familiarity with them. Then run <code>git clone https://github.com/fzyzcjy/flutter_rust_bridge</code>, and my example is in <code>frb_example/pure_dart</code>.</p>
<h2 id="optional-manually-run-code-generator"><a class="header" href="#optional-manually-run-code-generator">(Optional) Manually run code generator</a></h2>
<p>Remark: Bridge is automatically generated upon running <code>cargo build</code> using build-script in build.rs file, so this step is optional. Even if you do it, you should not see anything changed.</p>
<p>Install it: <code>cargo install flutter_rust_bridge_codegen</code>.</p>
<p>Run it: <code>flutter_rust_bridge_codegen --rust-input frb_example/pure_dart/rust/src/api.rs --dart-output frb_example/pure_dart/dart/lib/bridge_generated.dart</code> (See <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/.github/workflows/codegen.yml">CI workflow</a> as a reference.) (For Windows, you may need <code>\\</code> instead of <code>/</code> for paths.)</p>
<h2 id="run-dartrust-app"><a class="header" href="#run-dartrust-app">Run "Dart+Rust" app</a></h2>
<p>You may run <code>frb_example/pure_dart/dart/lib/main.dart</code> as a normal Dart program, except that you should provide the dynamic linked library of the Rust code (for simplicity, here I only demonstrate the approach for dynamic linked library, but you can for sure use other methods). The detailed steps are as follows.</p>
<p>Run <code>cargo build</code> in <code>frb_example/pure_dart/rust</code> to build the Rust code into a <code>.so</code> file. Then run <code>dart frb_example/pure_dart/dart/lib/main.dart frb_example/pure_dart/rust/target/debug/libflutter_rust_bridge_example_pure_dart.so</code> to run the Dart program with Rust <code>.so</code> file. (If you have problems, see "Troubleshooting" section.)  (If on MacOS, Rust may indeed generate <code>.dylib</code>, so change the last command to use <code>...dylib</code> instead of <code>...so</code>,)</p>
<p>P.S. You will only see some tests passing - no fancy UI or functionality in this example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="safety-concerns"><a class="header" href="#safety-concerns">Safety concerns</a></h1>
<p>This library has CI that runs <a href="https://www.valgrind.org/">Valgrind</a> automatically on the setup that a Dart program calls a Rust program using this package, so memory problems should be found by Valgrind. <sub>(Notice that, even when running a simple hello-world Dart program, Valgrind will report hundreds of errors. See <a href="https://github.com/dart-lang/sdk/issues/47346">this Dart lang issue</a> for more details. Therefore, I both look at "definitely lost" in Valgrind, and manually search things related to this library - if all reported errors are unrelated to this library then we are safe.)</sub></p>
<p>In addition, Flutter integration tests are also done in CI. This ensures a real Flutter application using this library does not suffer from problems.</p>
<p>Most of the code are written in safe Rust. The <code>unsafe</code> code mainly comes from <code>support::box_from_leak_ptr</code> and <code>support::vec_from_leak_ptr</code>. They are used for pointers and arrays, and I follow the high-upvoted answers and official doc when writing down that few lines of code.</p>
<p>I use this library heavily in my own Flutter project (<code>yplusplus</code>, or <code>why++</code>). That app is in production and it works quite well. If I observe any problems, I will fix it in this library.</p>
<p>The CI also runs the <code>run_codegen</code> workflow, which ensure that the code generator can compile and generate desired results. Lastly, the CI also runs formatters and linters (<code>fmt</code>, <code>clippy</code>, <code>dart analyze</code>, <code>dart format</code>), and linters can also catch some common problems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<h2 id="the-generated-store_dart_post_cobject-has-the-wrong-signature--stdargh-file-not-found-in-linux--stdboolh--"><a class="header" href="#the-generated-store_dart_post_cobject-has-the-wrong-signature--stdargh-file-not-found-in-linux--stdboolh--">The generated store_dart_post_cobject() has the wrong signature / <code>'stdarg.h' file not found</code> in Linux / <code>stdbool.h</code> / ...</a></h2>
<p>Try to run code generator with working directory at <code>/</code>, or set the environment variable:</p>
<pre><code class="language-bash">export CPATH="$(clang -v 2&gt;&amp;1 | grep "Selected GCC installation" | rev | cut -d' ' -f1 | rev)/include"
</code></pre>
<p>as described in <a href="https://github.com/dart-lang/ffigen/issues/257">ffigen #257</a>, or add include path as is described in <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/108">#108</a>. This is a problem with Rust's builtin <code>Command</code>. See also: <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/472">#472</a> &amp; <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/494">#494</a>.</p>
<h2 id="issue-with-store_dart_post_cobject"><a class="header" href="#issue-with-store_dart_post_cobject">Issue with <code>store_dart_post_cobject</code></a></h2>
<p>If calling rust function gives the error below, please consider running <strong>cargo build</strong> again. This can happen when the generated rs file is not included when building is being done.</p>
<pre><code class="language-sh">[ERROR:flutter/lib/ui/ui_dart_state.cc(209)] Unhandled Exception: Invalid argument(s): Failed to lookup symbol 'store_dart_post_cobject': target/debug/libadder.so: undefined symbol: store_dart_post_cobject
</code></pre>
<h2 id="error-running-cargo-ndk-ld-error-unable-to-find-library--lgcc"><a class="header" href="#error-running-cargo-ndk-ld-error-unable-to-find-library--lgcc">Error running <code>cargo ndk</code>: <code>ld: error: unable to find library -lgcc</code></a></h2>
<p>Downgrade Android NDK to version 22. This is an <a href="https://github.com/bbqsrc/cargo-ndk/issues/22">ongoing issue</a> with <code>cargo-ndk</code>, a library unrelated to flutter_rust_bridge but solely used to build the examples, when using Android NDK version 23. (See <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/149">#149</a>)</p>
<h2 id="fail-to-run-flutter_rust_bridge_codegen-on-macos-please-supply-one-or-more-pathtollvm"><a class="header" href="#fail-to-run-flutter_rust_bridge_codegen-on-macos-please-supply-one-or-more-pathtollvm">Fail to run <code>flutter_rust_bridge_codegen</code> on MacOS, "Please supply one or more path/to/llvm..."</a></h2>
<p>If you are running macOS, you will need to specify a path to your llvm:</p>
<pre><code class="language-shell">flutter_rust_bridge_codegen --rust-input path/to/your/api.rs --dart-output path/to/file/being/bridge_generated.dart --llvm-path /usr/local/homebrew/opt/llvm/
</code></pre>
<p>You can install llvm using <code>brew install llvm</code> and it will be installed at <code>/usr/local/homebrew/opt/llvm/</code> by default.</p>
<h2 id="freezed-file-is-sometimes-not-generated-when-it-should-be"><a class="header" href="#freezed-file-is-sometimes-not-generated-when-it-should-be">Freezed file is sometimes not generated when it should be</a></h2>
<p>If your <code>.freezed.dart</code> or <code>.g.dart</code> seems outdated, ensure you have run the <code>build_runner</code>.</p>
<p>Related: https://github.com/fzyzcjy/flutter_rust_bridge/issues/330</p>
<h2 id="cant-create-typedef-from-non-function-type"><a class="header" href="#cant-create-typedef-from-non-function-type"><code>Can't create typedef from non-function type.</code></a></h2>
<p>Ensure min sdk version of Flutter <code>pubspec.yaml</code> is at least 2.17.0 to let <code>ffigen</code> happy.</p>
<p>https://github.com/fzyzcjy/flutter_rust_bridge/issues/334</p>
<h2 id="imported-from-both-bridge_definitionsdart-and-bridge_generatediodart"><a class="header" href="#imported-from-both-bridge_definitionsdart-and-bridge_generatediodart">Imported from both <code>bridge_definitions.dart</code> and <code>bridge_generated.io.dart</code></a></h2>
<p>If you use a Rust type with <code>Kind</code> in it's name it may conflict with some generated types which can cause a duplicate import error. The workaround is to avoid using <code>Kind</code> as a suffix for a type name in Rust. See issue #757 for more details.</p>
<h2 id="error-on-ios-testflight-only-store_dart_post_cobject"><a class="header" href="#error-on-ios-testflight-only-store_dart_post_cobject">Error on iOS TestFlight only (<code>store_dart_post_cobject</code>)</a></h2>
<p>You may have an iOS app that works fine in Debug and Release modes locally but when deployed to TestFlight an error occurs trying to locate the <code>store_dart_post_cobject</code> - this is because the nested XCode project for the native bindings maybe be stripping symbols from the linked product.</p>
<p>Select the scheme (eg: <code>Product &gt; Scheme &gt; native-staticlib</code>) and go to <em>Build Settings</em> then under the <code>Deployment</code> section change <code>Strip Linked Product</code> to <code>No</code>; you may also need to change <code>Strip Style</code> to <code>Debugging Symbols</code>.</p>
<h2 id="generated-code-is-so-long"><a class="header" href="#generated-code-is-so-long">Generated code is so long</a></h2>
<p>Indeed all generated code are necessary (if you find something that can be simplified, file an issue). Moreover, other code generation tools also generate long code - for example, when using Google protobuf, a very popular serialization library, I see &gt;10k lines of Java code generated for a quite simple source proto file.</p>
<h2 id="why-need-dart-2170"><a class="header" href="#why-need-dart-2170">Why need Dart <code>2.17.0</code></a></h2>
<p>Dart SDK <code>&gt;=2.15.0</code> is supported by this library, but by the latest version of the <code>ffigen</code> tool requires <code>&gt;=2.17.0</code>. Therefore, write <code>sdk: "&gt;=2.17.0 &lt;3.0.0"</code> in the <code>environment</code> section of <code>pubspec.yaml</code>. If you do not want that, consider installing a older version of the <code>ffigen</code> tool.</p>
<h2 id="why-doesnt-flutter_rust_bridge_serve-work-on-firefox"><a class="header" href="#why-doesnt-flutter_rust_bridge_serve-work-on-firefox">Why doesn't <code>flutter_rust_bridge_serve</code> work on Firefox?</a></h2>
<p>This is a known issue stemming from Firefox's stricter rules regarding cross-origin requests. Use Chromium for testing, and check out
<a href="https://web.dev/cross-origin-isolation-guide/">this guide on enabling <code>crossOriginIsolated</code></a> for your production servers.</p>
<h2 id="android-context-was-not-initialized-or-ndk_context-initialization"><a class="header" href="#android-context-was-not-initialized-or-ndk_context-initialization">"android context was not initialized", or <code>ndk_context</code> initialization.</a></h2>
<p>Related issue: <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/1323">#1323</a>.</p>
<p>On android, when attempting to use crates that interact with the JavaVM through the JNI (like oboe-rs via cpal), you may get panics that typically have this message:</p>
<pre><code>[ERROR:flutter/runtime/dart_vm_initializer.cc(41)] Unhandled Exception: FfiException(PANIC_ERROR, android context was not initialized, null)
</code></pre>
<p>This is due to a interesting quirk of Rust NDK interaction, where the <a href="https://github.com/rust-mobile/ndk-context"><code>ndk_context</code></a> crate does not have it's JVM and Android context initialized. Typically, in a normal application, the Android JVM would <code>System.loadLibrary()</code> the library through the Activity inside the JVM. It looks for symbols related to the JNI and executes them in accordance with the JNI standard. This would initialize the <code>ndk_context</code> normally via <code>JNI_OnLoad</code>. However, using the DartVM this step is skipped while loading the library, as the DartVM is not the JVM. So, the Android specific variables are not initialized, and therefore you cannot interact with the system via the Java interface.</p>
<h3 id="mainactivitykt"><a class="header" href="#mainactivitykt">MainActivity.kt</a></h3>
<p>Add these lines to your FlutterActivity subclass:</p>
<pre><code class="language-kotlin">package com.example.frontend

import io.flutter.embedding.android.FlutterActivity

// https://github.com/dart-lang/sdk/issues/46027
class MainActivity : FlutterActivity() {
    // this `init` block, where "foo" is the name of your library
    // ex: if it's libfoo.so, then use "foo"
    init {
        System.loadLibrary("foo")
    }
}
</code></pre>
<p>This handles loading the library before Dart does, and also executes the JNI related initialization.</p>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<h4 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h4>
<pre><code class="language-toml">[target.'cfg(target_os = "android")'.dependencies]
jni = "0.21"
ndk-context = "0.1"
</code></pre>
<h4 id="librs"><a class="header" href="#librs">lib.rs</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_os = "android")]
#[no_mangle]
pub extern "C" fn JNI_OnLoad(vm: jni::JavaVM, res: *mut std::os::raw::c_void) -&gt; jni::sys::jint {
    use std::ffi::c_void;

    let vm = vm.get_java_vm_pointer() as *mut c_void;
    unsafe {
        ndk_context::initialize_android_context(vm, res);
    }
    jni::JNIVersion::V6.into()
}
<span class="boring">}</span></code></pre></pre>
<p>This is the bit of JNI glue that allows for <code>ndk_context</code> to be initialized.</p>
<h2 id="could-not-resolve-symbol-__cxa_pure_virtual-or-libc_shared-issues"><a class="header" href="#could-not-resolve-symbol-__cxa_pure_virtual-or-libc_shared-issues">"Could not resolve symbol __cxa_pure_virtual", or libc++_shared issues.</a></h2>
<p>At the time of writing this, linking with <code>libc++_static</code> or not linking at all may lead to symbol resolution errors when launching the flutter application, after loading your dynamic library. Adding a fix is quite easy, create a build.rs script in the root of your Rust code:</p>
<h3 id="buildrs"><a class="header" href="#buildrs">build.rs</a></h3>
<pre><pre class="playground"><code class="language-rust">fn main() {
    #[cfg(target_os = "android")]
    println!("cargo:rustc-link-lib=c++_shared");
}</code></pre></pre>
<p>Then, in each <code>jniLibs</code> architecture directory, put the corresponding <code>libc++_shared.so</code> from the Android NDK. <code>libc++_shared.so</code> is typically located in <code>$ANDROID_NDK/toolchains/llvm/prebuilt/</code>. You will have to search for it, as it's different for each operating system.</p>
<ul>
<li>arm-linux-androideabi -&gt; armeabi-v7a</li>
<li>aarch64-linux-android -&gt; arm64-v8a</li>
<li>i686-linux-android -&gt; x86</li>
<li>x86_64-linux-android -&gt; x86_64</li>
</ul>
<h2 id="issues-on-web"><a class="header" href="#issues-on-web">Issues on Web?</a></h2>
<p>Check out <a href="./wasm_limitations.html">Limitations on WASM</a> for some common problems and solutions
to adapt existing code to WASM.</p>
<h2 id="other-problems"><a class="header" href="#other-problems">Other problems?</a></h2>
<p>Don't hesitate to <a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/new/choose">open an issue</a>! I usually reply within minutes or hours (except when sleeping, of course).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-arguments"><a class="header" href="#command-line-arguments">Command line arguments</a></h1>
<p>Simply add <code>--help</code> to see full documentation. The following is a snapshot when running the command with <code>--help</code>:</p>
<pre><code class="language-shell">$ flutter_rust_bridge_codegen --help
Usage: flutter_rust_bridge_codegen [OPTIONS] --rust-input &lt;RUST_INPUT&gt;... --dart-output &lt;DART_OUTPUT&gt;...
       flutter_rust_bridge_codegen [CONFIG_FILE]

Arguments:
  [CONFIG_FILE]
          Path to a YAML config file.

          If present, other options and flags will be ignored. Accepts the same options as the CLI, but uses snake_case keys.

Options:
  -r, --rust-input &lt;RUST_INPUT&gt;...
          Path of input Rust code

  -d, --dart-output &lt;DART_OUTPUT&gt;...
          Path of output generated Dart code

      --dart-decl-output &lt;DART_DECL_OUTPUT&gt;
          If provided, generated Dart declaration code to this separate file

  -c, --c-output &lt;C_OUTPUT&gt;
          Output path (including file name) of generated C header, each field corresponding to that of --rust-input

  -e, --extra-c-output-path &lt;EXTRA_C_OUTPUT_PATH&gt;
          Extra output path (excluding file name) of generated C header

      --rust-crate-dir &lt;RUST_CRATE_DIR&gt;...
          Crate directory for your Rust project

      --rust-output &lt;RUST_OUTPUT&gt;...
          Output path of generated Rust code

      --class-name &lt;CLASS_NAME&gt;...
          Generated class name

      --dart-format-line-length &lt;DART_FORMAT_LINE_LENGTH&gt;
          Line length for Dart formatting

          [default: 80]

      --dart-enums-style
          The generated Dart enums will have their variant names camelCased

      --skip-add-mod-to-lib
          Skip automatically adding `mod bridge_generated;` to `lib.rs`

      --llvm-path &lt;LLVM_PATH&gt;...
          Path to the installed LLVM

      --llvm-compiler-opts &lt;LLVM_COMPILER_OPTS&gt;
          LLVM compiler opts

      --dart-root &lt;DART_ROOT&gt;...
          Path to root of Dart project, otherwise inferred from --dart-output

      --no-build-runner
          Skip running build_runner even when codegen-required code is detected

      --no-use-bridge-in-method
          No use bridge in Model

      --extra-headers &lt;EXTRA_HEADERS&gt;
          extra_headers is used to add dependencies header

          Note that when no_use_bridge_in_method=true and extra_headers is not set, the default is `import 'ffi.io.dart' if (dart.library.js_interop) 'ffi.web.dart'`.

  -v, --verbose
          Show debug messages

      --wasm
          Enable WASM module generation. Requires: --dart-decl-output

      --inline-rust
          Inline declaration of Rust bridge modules

      --skip-deps-check
          Skip dependencies check

      --dump [&lt;DUMP&gt;...]
          A list of data to be dumped. If specified without a value, defaults to all

          [possible values: config, ir]

      --no-dart3
          Disable language features introduced in Dart 3

      --keep-going
          If set, the program will delay error reporting until all codegen operations have completed

  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version
</code></pre>
<h2 id="flutter_rust_bridge_serve"><a class="header" href="#flutter_rust_bridge_serve"><code>flutter_rust_bridge_serve</code></a></h2>
<pre><code class="language-shell">$ dart run flutter_rust_bridge_serve --help
flutter_rust_bridge_serve 1.82.6
Develop Rust WASM modules with cross-origin isolation.

USAGE:
	flutter_rust_bridge_serve [OPTIONS] [..REST]
	flutter_rust_bridge_serve --dart-input &lt;ENTRY&gt; --root &lt;ROOT&gt; [OPTIONS] [..REST]

OPTIONS:
-p, --port=&lt;PORT&gt;             HTTP port to listen to
                              (defaults to "8080")
-r, --root=&lt;ROOT&gt;             Root of the Flutter/Dart output
-c, --crate=&lt;CRATE&gt;           Directory of the crate
                              (defaults to "native")
-d, --dart-input=&lt;ENTRY&gt;      Run "dart compile" with the specified input instead of "flutter build"
-w, --wasm-output=&lt;PKG&gt;       WASM output path
-v, --[no-]verbose            Display more verbose information
    --[no-]relax-coep         Set COEP to credentialless
                              Defaults to true for Flutter
    --[no-]open               Open the webpage in a browser
                              (defaults to on)
    --run-tests               Run tests in headless Chromium
    --release                 Compile in release mode
    --[no-]weak-refs          Enable the weak references proposal
                              Requires wasm-bindgen in path
    --[no-]reference-types    Enable the reference types proposal
                              Requires wasm-bindgen in path
-h, --help                    Print this help message
    --[no-]build              Whether to build the library.
                              (defaults to on)
    --features                A comma-separated list of features to pass to `cargo build`.
    --no-default-features     Whether to disable all features, useful with --features
</code></pre>
<h2 id="configuration-files"><a class="header" href="#configuration-files">Configuration files</a></h2>
<p>You can run <code>flutter_rust_bridge_codegen</code> with no arguments, provided any of these files exists in the working directory (in order of priority):</p>
<ul>
<li><code>.flutter_rust_bridge.yml</code></li>
<li><code>.flutter_rust_bridge.yaml</code></li>
<li><code>.flutter_rust_bridge.json</code></li>
</ul>
<p>The codegen will try to read a configuration from these files. Otherwise, you can pass to the CLI any YAML file that contains the config.
The same arguments from the CLI are accepted, but they will be in snake_case.</p>
<pre><code class="language-yaml"># in .flutter_rust_bridge.yml
rust_input:
  - path/to/api.rs
dart_output:
  - path/to/bridge_generated.dart
</code></pre>
<p>Similarly, if you're calling <code>flutter_rust_bridge_codegen</code> from the root of your Dart project, you can also fill in your config
under the <code>flutter_rust_bridge</code> entry in <code>pubspec.yaml</code>:</p>
<pre><code class="language-yaml"># put this somewhere in your pubspec.yaml
flutter_rust_bridge:
  rust_input:
    - path/to/api.rs
  dart_output:
    - lib/src/bridge_generated.dart
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set-up-flutterdartrust-support-from-scratch"><a class="header" href="#set-up-flutterdartrust-support-from-scratch">Set up Flutter/Dart+Rust support from scratch</a></h1>
<blockquote>
<p>This documentation is archived, though technically still correct. Have a look at <a href="integrate.html">integrating with existing projects</a> chapters for a more detailed demonstration.</p>
</blockquote>
<p>I suggest that you can start with the <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/with_flutter">Flutter example</a> first, and modify it to satisfy your needs. It can serve as a template for new projects. It is run against CI so we are sure it works.</p>
<p>Indeed, this library is nothing but a code generator that helps your Flutter/Dart functions call Rust functions. Therefore, "how to create a Flutter app that can run Rust code" is actually out of the scope of this library, and there are already several tutorials on the Internet.</p>
<p>However, I can sketch the outline of what to do if you want to set up a new Flutter+Rust project as follows.</p>
<h2 id="step-1"><a class="header" href="#step-1">Step 1</a></h2>
<p>Create a new Flutter project (or use an existing one). The Dart SDK should be <code>&gt;=2.17.0</code> if you want to use the latest <code>ffigen</code> tool.</p>
<h2 id="step-2"><a class="header" href="#step-2">Step 2</a></h2>
<p>Create a new Rust project, say, at directory <code>rust</code> under the Flutter project.</p>
<h2 id="step-3"><a class="header" href="#step-3">Step 3</a></h2>
<p>Edit <code>Cargo.toml</code> and add:</p>
<pre><code class="language-diff">[lib]
name = "flutter_rust_bridge_example" # whatever you like
# notice this type. `cdylib` for android, and `staticlib` for iOS. I write down a script to change it before build.
+ crate-type = ["cdylib"]
</code></pre>
<h2 id="step-4"><a class="header" href="#step-4">Step 4</a></h2>
<p>Follow the standard steps of "how iOS uses static libraries".</p>
<ol>
<li>In XCode, edit <code>Strip Style</code> in <code>Build Settings</code> to <code>Debugging Symbols</code>.</li>
<li>Add your <code>lib{crate}.a</code> to <code>Link Binary With Libraries</code> in <code>Build Phases</code>.</li>
<li>Add <code>binding.h</code> to <code>Copy Bundle Resources</code>.</li>
<li>Add <code>#import "binding.h"</code> to <code>Runner-Bridging-Header</code>.</li>
<li>Last but not least, add a never-to-be-executed dummy function in Swift that calls any of the generated C bindings. This lib has already generated a dummy method for you, so you simply need to add <code>print("dummy_value=\(dummy_method_to_enforce_bundling())");</code> to swift file's <code>override func application(...) {}</code>, and this will prevent symbol stripping - especially in the release build for iOS (i.e. when building ipa file or releasing to App Store). Notice that, we have to use that <code>dummy_method_to_enforce_bundling()</code>, otherwise the symbols will not maintain in the release build, and Flutter will complain it cannot find the symbols.</li>
</ol>
<h2 id="step-5"><a class="header" href="#step-5">Step 5</a></h2>
<p>Lastly, in order to build the Rust library automatically when you are building Flutter, follow <a href="https://stackoverflow.com/q/69515032/4619958">this tutorial</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-wasm-binary-manually"><a class="header" href="#building-a-wasm-binary-manually">Building a WASM binary manually</a></h1>
<p>Here are the complete commands for building a WASM binary with this library:</p>
<pre><code class="language-bash">export RUSTUP_TOOLCHAIN=nightly
export RUSTFLAGS="-C target-feature=+atomics,+bulk-memory,+mutable-globals"
wasm-pack build \
    -t no-modules \
    -d &lt;WASM_OUTPUT_PATH&gt; \
    --no-typescript -- \
    -Z build-std=std,panic_abort
</code></pre>
<p>Continue reading for more details.</p>
<hr />
<p><code>flutter_rust_bridge_codegen</code> expects a certain setup that is modeled after the
<a href="https://github.com/rustwasm/wasm-bindgen/tree/main/examples/raytrace-parallel">wasm_bindgen raytracing example</a>
and by extension consumes the <a href="https://rustwasm.github.io/docs/wasm-bindgen"><code>wasm_bindgen</code></a> library and its ecosystem.
The requirements are:</p>
<ul>
<li>The standard library being built with the <code>panic_abort</code> feature</li>
<li>The library and standard library being built with the target
features <code>atomics</code>, <code>bulk_memory</code> and <code>mutable_globals</code></li>
<li><code>wasm-pack</code> called with <code>-t no-modules</code> (to be relaxed in the future)</li>
</ul>
<p>Note that these features also represent a hard requirement on your
users' browser versions.</p>
<p>Furthermore, this library does not support JavaScript
runtimes as of writing.</p>
<p><strong>WASM_OUTPUT_PATH</strong> refers to the output directory of the WASM module.
If running Flutter, this is usually <code>web/pkg</code>.</p>
<h2 id="setting-up-the-web-server"><a class="header" href="#setting-up-the-web-server">Setting up the web server</a></h2>
<p>Once you have built your binary and are ready to deploy, you will also need
to configure your web server to respond with these two headers:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cross-Origin_Resource_Policy_(CORP)"><code>Cross-Origin-Resource-Policy</code></a> set to <code>same-origin</code></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy"><code>Cross-Origin-Embedder-Policy</code></a> set to <code>require-corp</code><sup class="footnote-reference"><a href="#1">1</a></sup></li>
</ul>
<p>Here is a sample web server that accomplishes this task (excerpt from <code>flutter_rust_bridge_serve</code>):</p>
<pre><code class="language-dart">import 'package:shelf/shelf.dart';
import 'package:shelf/shelf_io.dart';
import 'package:shelf_static/shelf_static.dart';

void main() async {
    final root = "/* directory containing index.html */";
    final staticFilesHandler = createStaticHandler(root, defaultDocument: 'index.html');
    final handler = const Pipeline().addMiddleware((handler) {
        return (req) async {
            final res = await handler(req);
            return res.change(headers: const {
                'Cross-Origin-Opener-Policy': 'same-origin',
                'Cross-Origin-Embedder-Policy': 'require-corp',
            });
        };
    }).addHandler(staticFilesHandler);
    await serve(handler, 'localhost', 8080);
}
</code></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>When running Flutter Web, you may encounter issues with downloading Flutter
support scripts which have not been marked as <code>crossorigin="anonymous"</code> and
therefore cannot be loaded. For local testing, you can specify <code>credentialless</code>
instead.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limitations-of-wasm-1"><a class="header" href="#limitations-of-wasm-1">Limitations of WASM</a></h1>
<ul>
<li>Safari cannot spawn nested <code>Worker</code>s. A workaround is to build two variants of the library,
one with multithreading and one without, and serve Safari users the single-threaded variant.
For a more general solution, check out <a href="https://github.com/GoogleChromeLabs/wasm-feature-detect">wasm-feature-detect</a>
or <a href="https://github.com/johanholmerin/nested-worker">nested-worker</a>.</li>
<li><code>std::thread::spawn</code> is unimplemented and replacements (e.g. <code>wasm_thread</code>) are not fully supported.
If you must use them, consider wrapping your return type in a <code>SyncReturn&lt;_&gt;</code> to
avoid the internal thread pool interfering with your threads.
This library includes a <code>spawn!</code> macro which spawns a new thread using the internal thread pool.</li>
<li>When a Rust thread panics, it aborts and throws a JavaScript <code>RuntimeError</code> that cannot be caught by name in
Dart. This is expected to change as the exception handling story for WASM improves, but a rule of thumb
is to replace <code>.unwrap</code> with <code>.expect</code> or <code>Err</code>s.</li>
<li>As a consequence, <code>panic::catch_unwind</code> does not work on the Web. As of writing, the implementation to
catch these errors resides within the bodies of the workers, i.e. it is not straightforward enough to
generalize for other use-cases.</li>
<li><code>Int64List</code> and <code>Uint64List</code> throws when used on Web platforms. They are left intentionally
unimplemented by the Dart language developers, perhaps due to the differences between <code>int</code> and <code>BigInt</code>.
This library provides a barebones pure Dart shim whose behavior may differ from the specifications,
so please create an issue/PR if you encounter any significant digression.</li>
<li><code>Int64List</code> and <code>Uint64List</code> arithmetics clamp on native platforms, but wrap on the Web. If your use-case
requires precision around large integer values, please be mindful of these platform-specific differences.</li>
<li>Support for the various components of WASM is not universal among browsers. Here is a (non-exhaustive) list
of trackers for how widely available some of the features are across browsers:
<ul>
<li><a href="https://caniuse.com/mdn-api_messageport_messageerror_event"><code>MessagePort</code> error events</a></li>
<li><a href="https://caniuse.com/mdn-api_crossoriginisolated"><code>crossOriginIsolated</code></a></li>
<li><a href="https://caniuse.com/sharedarraybuffer">Shared Array Buffers</a></li>
<li><a href="https://caniuse.com/sharedarraybuffer"><code>BroadcastChannel</code></a></li>
<li><a href="https://caniuse.com/mdn-javascript_builtins_atomics">Atomics</a></li>
<li><a href="https://caniuse.com/mdn-javascript_builtins_bigint64array"><code>BigInt64Array</code></a></li>
<li><a href="https://caniuse.com/wasm">WebAssembly</a></li>
<li><a href="https://webassembly.org/roadmap/">WebAssembly roadmap</a></li>
</ul>
</li>
<li>JavaScript runtimes (Node.js, Deno, etc.) support is not yet implemented.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="articles"><a class="header" href="#articles">Articles</a></h1>
<p>This chapter contains some articles related to <code>flutter_rust_bridge</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-in-rust-1"><a class="header" href="#async-in-rust-1">Async in Rust</a></h1>
<blockquote>
<p>Author: @AlienKevin</p>
</blockquote>
<p>This library does not yet support returning a Future type from Rust and this has to do with the difficulty of uniting the various approaches to async in Rust. The <a href="https://rust-lang.github.io/async-book/01_getting_started/03_state_of_async_rust.html#language-and-library-support">Rust Book</a> summarized the current state of async support succinctly:</p>
<blockquote>
<p>The most fundamental traits, types and functions, such as the Future trait are provided by the standard library. The async/await syntax is supported directly by the Rust compiler.</p>
</blockquote>
<blockquote>
<p>Many utility types, macros and functions are provided by the futures crate. They can be used in any async Rust application.</p>
</blockquote>
<blockquote>
<p>Execution of async code, IO and task spawning are provided by "async runtimes", such as Tokio and async-std. Most async applications, and some async crates, depend on a specific runtime.</p>
</blockquote>
<p>While the futures crate provides an executor called <code>futures::executor::block_on</code>, libraries that use Tokio runtime cannot use this executor. According to <a href="https://runrust.miraheze.org/wiki/Async_crate_comparison">Rust-lang community wiki</a>, crates like Tokio that provide both a runtime and IO abstractions often have their IO depend on the runtime. This can make it difficult to write runtime-agnostic code. First, we demonstrate a common use case of async programming in Rust by attempting to fetch the content of a file from the internet using the popular HTTP Client <a href="https://docs.rs/reqwest/0.11.6/reqwest/">Reqwest</a>:</p>
<pre><code class="language-rust ignore">use anyhow;

async fn get() -&gt; anyhow::Result&lt;String&gt; {
    let url = "https://link/to/file/download";
    let data = reqwest::get(url).await?.text().await?;
    Ok(data)
}</code></pre>
<p>When you try to generate bindings for the <code>get</code> function, the generated code will contain errors because this library does not support returning Future from Rust.</p>
<h2 id="mismatched-runtime"><a class="header" href="#mismatched-runtime">Mismatched runtime</a></h2>
<p>The next logic thing to try would be to convert the asynchronous code to synchronous by directly blocking the current thread and execute the code. For our first attempt, we wrap <code>futures::executor::block_on</code> around an async block containing reqwest calls.</p>
<pre><code class="language-rust ignore">use anyhow;
use futures::executor::block_on;

fn get() -&gt; anyhow::Result&lt;String&gt; {
    block_on(async {
        let url = "https://link/to/file/download";
        let data = reqwest::get(url).await?.text().await?;
        Ok(data)
    })
}</code></pre>
<p>Since Reqwest uses the Tokio runtime instead of the futures runtime, our code panicked with the error "there is no reactor running, must be called from the context of a Tokio 1.x runtime". To fix this error, we have two ways to execute async codes using the Tokio runtime. Approach 1 is the simplest and uses the convenient <a href="https://docs.rs/tokio/1.14.0/tokio/attr.main.html"><code>tokio::main</code></a> macro to turn an async function to a synchronous one. Approach 2 requires you to explicitly create a new Tokio runtime and use its block_on function to run the future to completion.</p>
<h2 id="approach-1-macro"><a class="header" href="#approach-1-macro">Approach 1 (macro)</a></h2>
<pre><code class="language-rust ignore">use anyhow;

#[tokio::main(flavor = "current_thread")]
async fn get() -&gt; anyhow::Result&lt;String&gt; {
    let url = "https://link/to/file/download";
    let data = reqwest::get(url).await?.text().await?;
    Ok(data)
}</code></pre>
<p>It has the following dependencies:</p>
<pre><code class="language-toml">[dependencies]
futures = "0.3"
reqwest = "0.11.6"
tokio = { version = "1.14.0", features = ["rt", "macros"] }
anyhow = { version = "1.0.49" }
</code></pre>
<h2 id="approach-2-runtime"><a class="header" href="#approach-2-runtime">Approach 2 (runtime)</a></h2>
<pre><code class="language-rust ignore">use anyhow;
use tokio::runtime::Runtime;

fn get() -&gt; anyhow::Result&lt;String&gt; {
    let rt = Runtime::new().unwrap();
    rt.block_on(async {
        let url = "https://link/to/file/download";
        let data = reqwest::get(url).await?.text().await?;
        Ok(data)
    })
}</code></pre>
<p>It has the following dependencies:</p>
<pre><code class="language-toml">[dependencies]
futures = "0.3"
reqwest = "0.11.6"
tokio = { version = "1.14.0", features = ["rt-multi-thread"] }
anyhow = { version = "1.0.49" }
</code></pre>
<h2 id="plain-futures"><a class="header" href="#plain-futures">Plain futures</a></h2>
<p>If you are using the plain futures crate without runtimes like Tokio, you should be safe to wrap the asynchronous code in an async block and use the <a href="https://docs.rs/futures/0.3.18/futures/executor/fn.block_on.html"><code>futures::executor::block_on</code></a> to run the future to completion:</p>
<pre><code class="language-rust ignore">use futures::executor::block_on;

async fn hello_world() -&gt; String {
    "hello, world!".to_string()
}

fn get() -&gt; String {
    block_on(async {
        hello_world().await
    })
}

fn main() {
    println!("{}", get()); // prints "hello, world!"
}</code></pre>
<h2 id="avoid-async"><a class="header" href="#avoid-async">Avoid async</a></h2>
<p>Lastly, you can avoid async code all together by using synchronously/blocking version of the functions if they are available. In Reqwest, there's a module called <code>reqwest::blocking</code> designed specifically for this purpose. So you can achieve the same thing above without using async.</p>
<pre><code class="language-rust ignore">use anyhow;
use reqwest;

fn get() -&gt; anyhow::Result&lt;String&gt; {
    let url = "https://link/to/file/download";
    let data = reqwest::blocking::get(url)?.text()?;
    Ok(data)
}</code></pre>
<p>It has the following dependencies:</p>
<pre><code class="language-toml">[dependencies]
futures = "0.3"
reqwest = { version = "0.11.6", features = ["blocking"] }
anyhow = { version = "1.0.49" }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generating-multiple-files"><a class="header" href="#generating-multiple-files">Generating multiple files</a></h1>
<blockquote>
<p>Author: @dbsxdbsx</p>
</blockquote>
<p>This article describes some thoughts and implementations about the feature of generating multiple files.</p>
<p>Before, like the <a href="https://github.com/fzyzcjy/flutter_rust_bridge/blob/master/frb_example/pure_dart/rust/src/api.rs">pure_dart's api.rs</a>, all APIs are exposed together in a single file(block). This is not bad when the whole project is simple. But it would become quite hard to maintain or develop, when the project becomes more and more complex, especially when it is a team project. Therefore, it is time to reconstruct code --- classify the exposed Api into proper blocks(files).</p>
<p>(Before going on reading, make sure that you are quite familiar with how to use <a href="https://github.com/Desdaemon/flutter_rust_bridge_template">template</a> to generate code with flutter_rust_bridge. If not, take a look at the former chapters or <a href="https://github.com/fzyzcjy/flutter_rust_bridge/tree/master/frb_example/pure_dart">the basic example</a> again, please.)</p>
<h2 id="try-to-classify-api-into-different-blocksfiles"><a class="header" href="#try-to-classify-api-into-different-blocksfiles">Try to classify Api into different blocks(files)</a></h2>
<p>Suppose, you only have two Api in <code>api.rs</code> originally, like this:</p>
<pre><code class="language-rust noplayground">#![allow(unused_variables)]

pub fn simple_add(a: i32, b: i32) -&gt; i32 {
    a + b
}

pub fn simple_minus(a: i32, b: i32) -&gt; i32 {
    a - b
}</code></pre>
<p>Now you want to classify these 2 Api into 2 blocks for some reason-- say, you put the <code>simple_add</code> Api into file <code>api_1.rs</code> and the other into <code>api_2.rs</code>. And then make a little modification in <code>lib.rs</code>:</p>
<pre><code class="language-rust noplayground">mod api_1;
mod api_2;</code></pre>
<p>Ok, now the question is how to deal with them with flutter_rust_bridge? From the <a href="https://github.com/Desdaemon/flutter_rust_bridge_template/blob/main/justfile#L11">template justfile</a>, we know code from a single API file called <code>api_rs</code> can be generated with a command like this:</p>
<pre><code>gen:
    export REPO_DIR="$PWD"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input "$REPO_DIR/native/src/api.rs" \
        --dart-output "$REPO_DIR/lib/bridge_generated.dart" \
...
</code></pre>
<p>(For simplicity, only two necessary flags <code>rust-input</code> and <code>dart-output</code> here.)</p>
<p>Then, to generate code within 2 blocks(files), you may come out with an approach like this:</p>
<pre><code>gen:
    export REPO_DIR="$PWD"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input "$REPO_DIR/native/src/api_1.rs" \
        --dart-output "$REPO_DIR/lib/bridge_generated_api_1.dart" \

    export REPO_DIR="$PWD"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input "$REPO_DIR/native/src/api_2.rs" \
        --dart-output "$REPO_DIR/lib/bridge_generated_api_2.dart" \
...
</code></pre>
<p>But here comes a problem, how to use them in dart? Like <code>await API.simpleAdd(1,2)</code> or
<code>await API.simpleMinus(1,2)</code> as before? The point here is, to thoroughly decouple Api from different blocks (which is the main reason for using multiple blocks of API), <strong>flag <code>class-name</code> is needed</strong>. So the command should be modified like this:</p>
<pre><code>gen:
    export REPO_DIR="$PWD"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input "$REPO_DIR/native/src/api_1.rs" \
        --dart-output "$REPO_DIR/lib/bridge_generated_api_1.dart" \
        --class-name ApiClass1

    export REPO_DIR="$PWD"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input "$REPO_DIR/native/src/api_2.rs" \
        --dart-output "$REPO_DIR/lib/bridge_generated_api_2.dart" \
        --class-name ApiClass2
...
</code></pre>
<p>(The class name <code>ApiClass1</code> and <code>ApiClass2</code> are chosen arbitrarily here.)</p>
<p>So now it seems to be perfect to generate code and using Api in Dart like <code>ApiClass1.simpleAdd(1,2)</code> or <code>ApiClass2.simpleMinus(1,2)</code>.</p>
<p>But actually, the above command is still not enough to generate code correctly. Because multiple blocks need to be translated respectively through FFI. So on the rust side, instead of generating code to a single file <a href="https://github.com/Desdaemon/flutter_rust_bridge_template/blob/main/native/src/bridge_generated.rs"><code>bridge_generated.rs</code></a>, now there are 2 files needed. But, what are the names of these 2 auto-generated rust files?
Here, for less misunderstanding, flutter_rust_bridge decides to ask for another compulsory flag <code>rust-output</code>. So the command should be modified like this:</p>
<pre><code>gen:
    export REPO_DIR="$PWD"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input "$REPO_DIR/native/src/api_1.rs" \
        --dart-output "$REPO_DIR/lib/bridge_generated_api_1.dart" \
        --class-name ApiClass1 \
        --rust-output generated_api_1

    export REPO_DIR="$PWD"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input "$REPO_DIR/native/src/api_2.rs" \
        --dart-output "$REPO_DIR/lib/bridge_generated_api_2.dart" \
        --class-name ApiClass2 \
        --rust-output generated_api_2
...
</code></pre>
<p>(Still, the rust output name <code>generated_api_1</code> and <code>generated_api_2</code> are chosen arbitrarily here.)</p>
<p>That is, flutter_rust_bridge asks you to manually define the generated rust file names, feel free to choose any name you like.</p>
<h2 id="some-issues-with-separate-commands"><a class="header" href="#some-issues-with-separate-commands">Some issues with separate commands</a></h2>
<p>Based on the last commands we come up with, everything seems to be fine --- the code generated, you can use them in Dart, and the whole project is compilable. And you would also notice some changes in <code>lib.rs</code>:</p>
<pre><code class="language-rust noplayground">mod api_1;
mod api_2;
mod generated_api_1; /* AUTO INJECTED BY flutter_rust_bridge. This line may not be accurate, and you can change it according to your needs. */
mod generated_api_2; /* AUTO INJECTED BY flutter_rust_bridge. This line may not be accurate, and you can change it according to your needs. */</code></pre>
<p>But actually, it is not good enough.</p>
<h3 id="issue-from-explicit-api-conflict"><a class="header" href="#issue-from-explicit-api-conflict">issue from explicit Api conflict</a></h3>
<p>Let's say one day, you decide to add another API, say <code>simpleDivide</code>. But when you compile the whole project, the Dart compiler just complains "The symbol <code>simpleDivide</code> has already been defined ...". Then you check whether this <code>simpleDivide</code> is defined duplicated. Finally, you find that it's already defined in another block. This situation occurs quite a lot, when the other block is in the charge of someone else, especially in a big project. It is easy to see that the whole routine is a little inefficient since you don't realize the Api conflict until doing compiling when you've probably coded a lot with this "new defined" Api --- and the more time compiling takes, the more inefficient.</p>
<h3 id="issue-from-implicit-api-conflict"><a class="header" href="#issue-from-implicit-api-conflict">issue from implicit Api conflict</a></h3>
<p>And what makes the Api conflict issue more catastrophic? Say you define another Api with parameter <code>String</code> in <code>api_1.rs</code>:</p>
<pre><code class="language-rust noplayground">pub fn test_string_1(s1: String) {
    println!("test implicit parameter conflicts {}", s1);
}</code></pre>
<p>And then you put another Api with parameter <code>String</code> in <code>api_2.rs</code>:</p>
<pre><code class="language-rust noplayground">pub fn test_string_2(s2: String) {
    println!("test implicit parameter conflicts {}", s2);
}</code></pre>
<p>These 2 Apis don't violate the uniqueness required by FFI. They should be compilable with no error. But the truth is no! Why? Because for the <code>String</code> parameter, flutter_rust_bridge would automatically generate API like this:</p>
<pre><code class="language-rust noplayground">#[no_mangle]
pub extern "C" fn new_uint_8_list(len: i32) -&gt; *mut wire_uint_8_list</code></pre>
<p>which is used to let rust code easily cooperate with Dart through FFI. So if there are 2 APIs both taking <code>String</code> as parameters over blocks, you should notice a similar panic like "the symbol <code>new_uint_8_list</code> is already defined ..." during compiling(<a href="https://github.com/fzyzcjy/flutter_rust_bridge/issues/511">issue #511</a>).</p>
<p>(Actually, since version <a href="https://github.com/fzyzcjy/flutter_rust_bridge/releases/tag/v1.37.0">1.37</a>, even with the separated commands with no Api defined, the whole project is still not compilable with error "symbol <code>free_WireSyncRust2DartStruct</code> is already defined... ", the symbol <code>free_WireSyncRust2DartStruct</code> is another implicitly Api generated by flutter_rust_bridge.)</p>
<p>So these kinds of explicit/implicit Api conflicts are annoying and frustrating. How to resolve it?</p>
<p>Theoretically, the conflict can be detected earlier during generating code, when flutter_rust_bridge knows every detail about API. But the key is that <strong>flutter_rust_bridge has to know all Api over all blocks before generating code</strong>. That is, with the separated command stated above, flutter_rust_bridge can't do the check for you in practice. Therefore, it is necessary to unite the separated commands into ONE command.</p>
<h2 id="correct-command-for-generating-code-with-multiple-blocks"><a class="header" href="#correct-command-for-generating-code-with-multiple-blocks">correct command for generating code with multiple blocks</a></h2>
<p>Now comes the joined command to resolve the above issue:</p>
<pre><code>gen:
    export REPO_DIR="$PWD"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input "$REPO_DIR/native/src/api_1.rs" "$REPO_DIR/native/src/api_2.rs" \
        --dart-output "$REPO_DIR/lib/bridge_generated_api_1.dart" "$REPO_DIR/lib/bridge_generated_api_2.dart" \
        --class-name ApiClass1 ApiClass2 \
        --rust-output generated_api_1 generated_api_2
...
</code></pre>
<p>Here, with just 1 command, flutter_rust_bridge would smartly check if there are conflicts over all Api over all blocks, be it defined explicitly or implicitly.</p>
<p>That is, for the explicitly defined APIs like <code>simple_add</code> and <code>simple_minus</code>, if there are duplicated ones, flutter_rust_bridge would throw a panic like "thread 'main' panicked at 'symbol [simple_add] has already been defined'...", and you are responsible to fix it. And for the implicitly defined API like <code>new_uint_8_list</code>, since it is essential, flutter_rust_bridge would try to work around it by adding suffix starting from 0, like <code>new_uint_8_list_0</code> and <code>new_uint_8_list_1</code>.</p>
<p>To sum up, <strong>there are 4 compulsory flags when you deal with multiple blocks.</strong> They are <code>rust-input</code>, <code>dart-output</code>, <code>class-name</code> and <code>rust-output</code>. Also, the number of fields following each flag should be consistent. You can try to <code>cargo build</code> with fewer flags or inconsistent fields to see what kind of panic would be popped up with the <a href="https://github.com/fzyzcjy/flutter_rust_bridge/tree/master/frb_example/pure_dart_multi/rust/build.rs">pure_dart_multi</a> example when doing generation.</p>
<h2 id="bizarre-weird-but-compilable-command-with-the-disorder"><a class="header" href="#bizarre-weird-but-compilable-command-with-the-disorder">bizarre, weird but compilable command with the disorder</a></h2>
<p><strong>Flutter_rust_bridge doesn't do semantic correction over all flags.</strong> So, it is syntactically correct with the following generation command:</p>
<pre><code>gen:
    export REPO_DIR="$PWD"; cd /; flutter_rust_bridge_codegen {{llvm_path}} \
        --rust-input "$REPO_DIR/native/src/api_orange.rs" "$REPO_DIR/native/src/api_apple.rs" \
        --dart-output "$REPO_DIR/lib/gen_api_apple.dart" "$REPO_DIR/lib/gen_api_orange.dart" \
        --class-name ApiClassOrange ApiClassApple \
        --rust-output generated_api_apple generated_api_orange
</code></pre>
<p>NOTE: the suffix <code>apple</code> and <code>orange</code> are quite disordered for each flag here on purpose. It is compilable and usable. But as you should know, it is not a good practice, semantically. It is all up to you to decide the field names for each flag, so be beware of it!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
