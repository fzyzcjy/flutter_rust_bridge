"use strict";(self.webpackChunkflutter_rust_bridge=self.webpackChunkflutter_rust_bridge||[]).push([[8880],{15680:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>d});var r=n(96540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},y=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,u=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),y=l(n),d=a,g=y["".concat(u,".").concat(d)]||y[d]||p[d]||o;return n?r.createElement(g,i(i({ref:t},c),{},{components:n})):r.createElement(g,i({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=y;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}y.displayName="MDXCreateElement"},13711:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=n(58168),a=(n(96540),n(15680));const o={},i="Async in Rust",s={unversionedId:"manual/miscellaneous/article/async-in-rust",id:"manual/miscellaneous/article/async-in-rust",title:"Async in Rust",description:"Author: @AlienKevin",source:"@site/docs/manual/miscellaneous/91-article/01-async-in-rust.md",sourceDirName:"manual/miscellaneous/91-article",slug:"/manual/miscellaneous/article/async-in-rust",permalink:"/flutter_rust_bridge/manual/miscellaneous/article/async-in-rust",draft:!1,editUrl:"https://github.com/fzyzcjy/flutter_rust_bridge/tree/master/website/docs/manual/miscellaneous/91-article/01-async-in-rust.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Articles",permalink:"/flutter_rust_bridge/manual/miscellaneous/article/"},next:{title:"Archived documentations",permalink:"/flutter_rust_bridge/manual/miscellaneous/archived/"}},u={},l=[{value:"Mismatched runtime",id:"mismatched-runtime",level:2},{value:"Approach 1 (macro)",id:"approach-1-macro",level:2},{value:"Approach 2 (runtime)",id:"approach-2-runtime",level:2},{value:"Plain futures",id:"plain-futures",level:2},{value:"Avoid async",id:"avoid-async",level:2}],c={toc:l};function p(e){let{components:t,...n}=e;return(0,a.yg)("wrapper",(0,r.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"async-in-rust"},"Async in Rust"),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"Author: @AlienKevin")),(0,a.yg)("p",null,"This library does not yet support returning a Future type from Rust and this has to do with the difficulty of uniting the various approaches to async in Rust. The ",(0,a.yg)("a",{parentName:"p",href:"https://rust-lang.github.io/async-book/01_getting_started/03_state_of_async_rust.html#language-and-library-support"},"Rust Book")," summarized the current state of async support succinctly:"),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"The most fundamental traits, types and functions, such as the Future trait are provided by the standard library. The async/await syntax is supported directly by the Rust compiler.")),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"Many utility types, macros and functions are provided by the futures crate. They can be used in any async Rust application.")),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},'Execution of async code, IO and task spawning are provided by "async runtimes", such as Tokio and async-std. Most async applications, and some async crates, depend on a specific runtime.')),(0,a.yg)("p",null,"While the futures crate provides an executor called ",(0,a.yg)("inlineCode",{parentName:"p"},"futures::executor::block_on"),", libraries that use Tokio runtime cannot use this executor. According to ",(0,a.yg)("a",{parentName:"p",href:"https://runrust.miraheze.org/wiki/Async_crate_comparison"},"Rust-lang community wiki"),", crates like Tokio that provide both a runtime and IO abstractions often have their IO depend on the runtime. This can make it difficult to write runtime-agnostic code. First, we demonstrate a common use case of async programming in Rust by attempting to fetch the content of a file from the internet using the popular HTTP Client ",(0,a.yg)("a",{parentName:"p",href:"https://docs.rs/reqwest/0.11.6/reqwest/"},"Reqwest"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-rust,ignore"},'use anyhow;\n\nasync fn get() -> anyhow::Result<String> {\n    let url = "https://link/to/file/download";\n    let data = reqwest::get(url).await?.text().await?;\n    Ok(data)\n}\n')),(0,a.yg)("p",null,"When you try to generate bindings for the ",(0,a.yg)("inlineCode",{parentName:"p"},"get")," function, the generated code will contain errors because this library does not support returning Future from Rust."),(0,a.yg)("h2",{id:"mismatched-runtime"},"Mismatched runtime"),(0,a.yg)("p",null,"The next logic thing to try would be to convert the asynchronous code to synchronous by directly blocking the current thread and execute the code. For our first attempt, we wrap ",(0,a.yg)("inlineCode",{parentName:"p"},"futures::executor::block_on")," around an async block containing reqwest calls."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-rust,ignore"},'use anyhow;\nuse futures::executor::block_on;\n\nfn get() -> anyhow::Result<String> {\n    block_on(async {\n        let url = "https://link/to/file/download";\n        let data = reqwest::get(url).await?.text().await?;\n        Ok(data)\n    })\n}\n')),(0,a.yg)("p",null,'Since Reqwest uses the Tokio runtime instead of the futures runtime, our code panicked with the error "there is no reactor running, must be called from the context of a Tokio 1.x runtime". To fix this error, we have two ways to execute async codes using the Tokio runtime. Approach 1 is the simplest and uses the convenient ',(0,a.yg)("a",{parentName:"p",href:"https://docs.rs/tokio/1.14.0/tokio/attr.main.html"},(0,a.yg)("inlineCode",{parentName:"a"},"tokio::main"))," macro to turn an async function to a synchronous one. Approach 2 requires you to explicitly create a new Tokio runtime and use its block_on function to run the future to completion."),(0,a.yg)("h2",{id:"approach-1-macro"},"Approach 1 (macro)"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-rust,ignore"},'use anyhow;\n\n#[tokio::main(flavor = "current_thread")]\nasync fn get() -> anyhow::Result<String> {\n    let url = "https://link/to/file/download";\n    let data = reqwest::get(url).await?.text().await?;\n    Ok(data)\n}\n')),(0,a.yg)("p",null,"It has the following dependencies:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-toml"},'[dependencies]\nfutures = "0.3"\nreqwest = "0.11.6"\ntokio = { version = "1.14.0", features = ["rt", "macros"] }\nanyhow = { version = "1.0.49" }\n')),(0,a.yg)("h2",{id:"approach-2-runtime"},"Approach 2 (runtime)"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-rust,ignore"},'use anyhow;\nuse tokio::runtime::Runtime;\n\nfn get() -> anyhow::Result<String> {\n    let rt = Runtime::new().unwrap();\n    rt.block_on(async {\n        let url = "https://link/to/file/download";\n        let data = reqwest::get(url).await?.text().await?;\n        Ok(data)\n    })\n}\n')),(0,a.yg)("p",null,"It has the following dependencies:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-toml"},'[dependencies]\nfutures = "0.3"\nreqwest = "0.11.6"\ntokio = { version = "1.14.0", features = ["rt-multi-thread"] }\nanyhow = { version = "1.0.49" }\n')),(0,a.yg)("h2",{id:"plain-futures"},"Plain futures"),(0,a.yg)("p",null,"If you are using the plain futures crate without runtimes like Tokio, you should be safe to wrap the asynchronous code in an async block and use the ",(0,a.yg)("a",{parentName:"p",href:"https://docs.rs/futures/0.3.18/futures/executor/fn.block_on.html"},(0,a.yg)("inlineCode",{parentName:"a"},"futures::executor::block_on"))," to run the future to completion:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-rust,ignore"},'use futures::executor::block_on;\n\nasync fn hello_world() -> String {\n    "hello, world!".to_string()\n}\n\nfn get() -> String {\n    block_on(async {\n        hello_world().await\n    })\n}\n\nfn main() {\n    println!("{}", get()); // prints "hello, world!"\n}\n')),(0,a.yg)("h2",{id:"avoid-async"},"Avoid async"),(0,a.yg)("p",null,"Lastly, you can avoid async code all together by using synchronously/blocking version of the functions if they are available. In Reqwest, there's a module called ",(0,a.yg)("inlineCode",{parentName:"p"},"reqwest::blocking")," designed specifically for this purpose. So you can achieve the same thing above without using async."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-rust,ignore"},'use anyhow;\nuse reqwest;\n\nfn get() -> anyhow::Result<String> {\n    let url = "https://link/to/file/download";\n    let data = reqwest::blocking::get(url)?.text()?;\n    Ok(data)\n}\n')),(0,a.yg)("p",null,"It has the following dependencies:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-toml"},'[dependencies]\nfutures = "0.3"\nreqwest = { version = "0.11.6", features = ["blocking"] }\nanyhow = { version = "1.0.49" }\n')))}p.isMDXComponent=!0}}]);