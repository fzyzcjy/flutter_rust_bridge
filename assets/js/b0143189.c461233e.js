"use strict";(self.webpackChunkflutter_rust_bridge=self.webpackChunkflutter_rust_bridge||[]).push([[7587],{15680:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>m});var r=n(96540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=r.createContext({}),s=function(e){var t=r.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(o.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,u=p(e,["components","mdxType","originalType","parentName"]),d=s(n),m=a,y=d["".concat(o,".").concat(m)]||d[m]||c[m]||i;return n?r.createElement(y,l(l({ref:t},u),{},{components:n})):r.createElement(y,l({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=d;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:a,l[1]=p;for(var s=2;s<i;s++)l[s]=n[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},54577:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>p,toc:()=>s});var r=n(58168),a=(n(96540),n(15680));const i={},l="External types",p={unversionedId:"guides/third-party/manual/external-types",id:"guides/third-party/manual/external-types",title:"External types",description:"Third-party packages can be converted automatically; only use the feature in this page when the automation is unwanted.",source:"@site/docs/guides/third-party/manual/external-types.md",sourceDirName:"guides/third-party/manual",slug:"/guides/third-party/manual/external-types",permalink:"/flutter_rust_bridge/guides/third-party/manual/external-types",draft:!1,editUrl:"https://github.com/fzyzcjy/flutter_rust_bridge/tree/master/website/docs/guides/third-party/manual/external-types.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"External methods",permalink:"/flutter_rust_bridge/guides/third-party/manual/external-methods"},next:{title:"Wrappers",permalink:"/flutter_rust_bridge/guides/third-party/manual/wrappers"}},o={},s=[{value:"Remarks",id:"remarks",level:2},{value:"Example",id:"example",level:2},{value:"Traits",id:"traits",level:2},{value:"Example",id:"example-1",level:3},{value:"External crate",id:"external-crate",level:4},{value:"Our crate",id:"our-crate",level:4},{value:"Scenario 1",id:"scenario-1",level:5},{value:"Scenario 2",id:"scenario-2",level:5}],u={toc:s};function c(e){let{components:t,...n}=e;return(0,a.yg)("wrapper",(0,r.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("h1",{id:"external-types"},"External types"),(0,a.yg)("admonition",{type:"info"},(0,a.yg)("p",{parentName:"admonition"},"Third-party packages can be converted automatically; only use the feature in this page when the automation is unwanted.")),(0,a.yg)("p",null,'This page shows how to use translatable types defined in third party crates in an manual approach - the "mirroring" feature.'),(0,a.yg)("p",null,"This boilerplate is only needed for translatable types.\nFor ",(0,a.yg)("a",{parentName:"p",href:"../../types/arbitrary"},"arbitrary types"),", everything is automatic."),(0,a.yg)("p",null,"In short, you need to define the type again mirroring the external type that you want\nto use. That definition is only used at code-generation time to tell ",(0,a.yg)("inlineCode",{parentName:"p"},"flutter_rust_bridge")," type information."),(0,a.yg)("h2",{id:"remarks"},"Remarks"),(0,a.yg)("p",null,"No need to worry whether this breaks the DRY principle, or what happens when you accidentally write down a wrong field.\nThis is because compile errors will happen if your mirrored type is not exactly same as the original type."),(0,a.yg)("p",null,"When multiple structs have the same fields, you can mirror them ",(0,a.yg)("em",{parentName:"p"},"once")," using grammar\nlike ",(0,a.yg)("inlineCode",{parentName:"p"},"#[frb(mirror(FirstStruct, SecondStruct, ThirdStruct))]"),"."),(0,a.yg)("p",null,"When it comes to types in other crates,\n",(0,a.yg)("a",{parentName:"p",href:"https://crates.io/crates/serde"},"serde")," also has a similar developer-facing API,\nrequiring users to write down the details of the remote struct:\n",(0,a.yg)("a",{parentName:"p",href:"https://serde.rs/remote-derive.html"},"https://serde.rs/remote-derive.html"),"."),(0,a.yg)("h2",{id:"example"},"Example"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-rust"},'// Mirroring example:\n// The goal of mirroring is to use external objects without needing to convert them with an intermediate type\n// In this case, the struct ApplicationSettings is defined in another crate (called external-lib)\n\n// To use an external type with mirroring, it MUST be imported publicly (aka. re-export)\npub use external_lib::{ApplicationEnv, ApplicationMode, ApplicationSettings};\n\n// To mirror an external struct, you need to define a placeholder type with the same definition\n#[frb(mirror(ApplicationSettings))]\npub struct _ApplicationSettings {\n    pub name: String,\n    pub version: String,\n    pub mode: ApplicationMode,\n    pub env: Box<ApplicationEnv>,\n}\n\n// It works with basic enums too\n// Enums with struct variants are not yet supported\n#[frb(mirror(ApplicationMode))]\npub enum _ApplicationMode {\n    Standalone,\n    Embedded,\n}\n\n#[frb(mirror(ApplicationEnv))]\npub struct _ApplicationEnv {\n    pub vars: Vec<String>,\n}\n\n// This function can directly return an object of the external type ApplicationSettings because it has a mirror\npub fn get_app_settings() -> ApplicationSettings {\n    external_lib::get_app_settings()\n}\n\n// Similarly, receiving an object from Dart works. Please note that the mirror definition must match entirely and the original struct must have all its fields public.\npub fn is_app_embedded(app_settings: ApplicationSettings) -> bool {\n    // println!("env: {}", app_settings.env.vars[0]);\n    match app_settings.mode {\n        ApplicationMode::Standalone => false,\n        ApplicationMode::Embedded => true,\n    }\n}\n')),(0,a.yg)("p",null,"Another example using one struct to mirror multiple structs:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-rust"},"// *no* need to do these\n#[frb(mirror(MessageId))]\npub struct MId(pub [u8; 32]);\n\n#[frb(mirror(BlobId))]\npub struct BId(pub [u8; 32]);\n\n#[frb(mirror(FeedId))]\npub struct FId(pub [u8; 32]);\n\n// simply do this is sufficient\n#[frb(mirror(MessageId, BlobId, FeedId))]\npub struct Id(pub [u8; 32]);\n")),(0,a.yg)("h2",{id:"traits"},"Traits"),(0,a.yg)("p",null,"Before flutter_rust_bridge supports more advanced parsing,\ntraits in external third-party packages can be utilized\nthrough a proxy/wrapper/newtype design pattern as illustrated through the following example. "),(0,a.yg)("h3",{id:"example-1"},"Example"),(0,a.yg)("p",null,"In this example,\nassume there is an external crate/package called 'calc' that contains a trait by name ",(0,a.yg)("inlineCode",{parentName:"p"},"Calc")," (and an implementation ",(0,a.yg)("inlineCode",{parentName:"p"},"CalcImpl"),"),\nand we demonstrate how to use this trait and implementation in our ",(0,a.yg)("inlineCode",{parentName:"p"},"flutter_rust_bridge")," based package."),(0,a.yg)("h4",{id:"external-crate"},"External crate"),(0,a.yg)("p",null,(0,a.yg)("em",{parentName:"p"},"<external_crate>/calc.rs")," : "),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-rust"},"pub trait Calc {\n    fn add(&self, a: u32, b: u32) -> u32;\n}\n\npub struct CalcImpl {}\n\nimpl Calc for CalcImpl {\n    fn add(&self, a: u32, b: u32) -> u32 {\n        a + b\n    }\n}\n")),(0,a.yg)("h4",{id:"our-crate"},"Our crate"),(0,a.yg)("h5",{id:"scenario-1"},"Scenario 1"),(0,a.yg)("p",null,(0,a.yg)("em",{parentName:"p"},"rust/src/api/calc.rs")," "),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-rust"},"pub fn new_calc() -> Box<dyn Calc> {\n    Box::new(CalcImpl {})\n}\n")),(0,a.yg)("p",null,"Then we get an opaque object about ",(0,a.yg)("inlineCode",{parentName:"p"},"Calc"),", which can be passed back to Rust functions."),(0,a.yg)("h5",{id:"scenario-2"},"Scenario 2"),(0,a.yg)("p",null,"If we want to have the methods on the ",(0,a.yg)("inlineCode",{parentName:"p"},"Calc")," trait exposed as methods in Dart,\none approach is to use Rust's commonly-seen proxy/wrapper/newtype design pattern as follows."),(0,a.yg)("p",null,(0,a.yg)("em",{parentName:"p"},"rust/src/api/calc.rs")," "),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-rust"},'// So-called "newtype" pattern\npub struct CalcWrapper(Box<dyn Calc + Send + Sync>);\n\nimpl CalcWrapper {\n    pub fn new() -> Self {\n        Self(Box::new(CalcImpl {})) // or whatever else...\n    }\n    \n    pub fn add(&self, a: u32, b: u32) -> u32 {\n        self.0.add(a, b)\n    }\n}\n')),(0,a.yg)("p",null,"This should work now as you have an equivalent type in ",(0,a.yg)("inlineCode",{parentName:"p"},"dart")," to use all those member methods / functions in the underlying Rust trait."))}c.isMDXComponent=!0}}]);